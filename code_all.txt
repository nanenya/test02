import json
import subprocess
import sys

def run_command(command):
    try:
        result = subprocess.run(command, capture_output=True, text=True, encoding='utf-8')
        return result.stdout.strip()
    except FileNotFoundError:
        return f"Error: Command '{command[0]}' not found. Please ensure it's installed."
    except Exception as e:
        return f"An unexpected error occurred: {e}"

def analyze_files(file_list):
    analysis_results = {}
    for file_path in file_list:
        print(f"Analyzing {file_path}...")
        try:
            # Linting with flake8
            lint_result = run_command(['flake8', file_path])
            
            # Complexity with radon
            complexity_result = run_command(['radon', 'cc', '-s', file_path])
            
            analysis_results[file_path] = {
                'lint': lint_result or 'No issues found.',
                'complexity': complexity_result or 'Could not calculate.'
            }
        except Exception as e:
            analysis_results[file_path] = {'error': str(e)}
    return analysis_results

if __name__ == "__main__":
    files_to_analyze = sys.argv[1:]
    if not files_to_analyze:
        print("No files provided for analysis.", file=sys.stderr)
        sys.exit(1)

    report = analyze_files(files_to_analyze)
    
    with open('analysis_report.json', 'w', encoding='utf-8') as f:
        json.dump(report, f, indent=2, ensure_ascii=False)
    
    print("Analysis complete. Report saved to analysis_report.json")
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# main.py
import sys
import os
import inspect
import asyncio

# (ìˆ˜ì •) í•œê¸€ ê¹¨ì§ ë°©ì§€ë¥¼ ìœ„í•´ í‘œì¤€ ì…ì¶œë ¥ ì¸ì½”ë”©ì„ UTF-8ë¡œ ê°•ì œ ì„¤ì •
if sys.stdout.encoding.lower() != 'utf-8':
    sys.stdout.reconfigure(encoding='utf-8')
if sys.stdin.encoding.lower() != 'utf-8':
    sys.stdin.reconfigure(encoding='utf-8')

import typer
import httpx
import uvicorn
import subprocess
import time
import socket
import re
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.syntax import Syntax
from rich.prompt import Prompt, Confirm
from typing_extensions import Annotated
from typing import List, Dict, Any

# [ì‹ ê·œ] Shared ëª¨ë“ˆ ë° MCP ëª¨ë“ˆ ì„í¬íŠ¸
from shared.prompt_manager import prompt_manager
from orchestrator.history_manager import list_conversations, load_conversation, new_conversation
import mcp_modules # MCP ì§ì ‘ ì‹¤í–‰ì„ ìœ„í•´ ì„í¬íŠ¸

app = typer.Typer()
console = Console()

ORCHESTRATOR_URL = "http://127.0.0.1:8000"

# (ìˆ˜ì •) ëª¨ë°”ì¼/SSH í™˜ê²½ ë“±ì—ì„œ ì…ë ¥ ì˜¤ë¥˜ë¥¼ ì¤„ì´ê¸° ìœ„í•œ ì…ë ¥ í—¬í¼ í•¨ìˆ˜
def safe_input(prompt_text: str, default: str = None) -> str:
    """
    typer.prompt ëŒ€ì‹  rich.promptë¥¼ ì‚¬ìš©í•˜ì—¬ ì•ˆì „í•˜ê²Œ ì…ë ¥ì„ ë°›ìŠµë‹ˆë‹¤.
    ì´ëŠ” í„°ë¯¸ë„ ì¸ì½”ë”© ë¬¸ì œë‚˜ ëª¨ë°”ì¼ì—ì„œì˜ ì¤‘ë³µ ì…ë ¥ ë¬¸ì œë¥¼ ì™„í™”í•©ë‹ˆë‹¤.
    """
    return Prompt.ask(prompt_text, default=default)

def display_full_plan(plan: List[Dict[str, Any]]):
    table = Table(title="[bold]ì „ì²´ ì‹¤í–‰ ê³„íš[/bold]")
    table.add_column("No.", style="cyan")
    table.add_column("Group ID", style="magenta")
    table.add_column("Description")
    table.add_column("Tasks")

    for i, group in enumerate(plan, 1):
        group_id = group.get('group_id', 'N/A')
        description = group.get('description', 'N/A')
        tasks = group.get('tasks', [])
        
        task_details = []
        for j, task in enumerate(tasks, 1):
            tool_name = task.get('tool_name')
            model_pref = task.get('model_preference', 'auto')
            
            model_display = ""
            if tool_name in ["execute_shell_command", "execute_python_code"]:
                 model_display = f" ([bold red]ìœ„í—˜: {tool_name}[/bold red])"
            elif model_pref == 'high':
                 model_display = " (Model: [bold red]High[/bold red])"
            elif model_pref == 'standard':
                 model_display = " (Model: [bold blue]Standard[/bold blue])"
            
            task_details.append(f"  {i}.{j}) {task.get('tool_name')}{model_display}")
        
        table.add_row(str(i), group_id, description, "\n".join(task_details))
    
    console.print(table)

# -------------------------------------------
# [ì‹ ê·œ] tool ì»¤ë§¨ë“œ: Orchestrator ì—†ì´ ë¡œì»¬ì—ì„œ MCP ì§ì ‘ ì‹¤í–‰
# -------------------------------------------
@app.command()
def tool(
    name: Annotated[str, typer.Argument(help="ì‹¤í–‰í•  MCP ë„êµ¬ì˜ ì´ë¦„ (ì˜ˆ: ask_gemini)")],
    args: Annotated[List[str], typer.Argument(help="ë„êµ¬ì— ì „ë‹¬í•  ì¸ì (key=value í˜•íƒœ)")] = None
):
    """
    ë¡œì»¬ í™˜ê²½ì—ì„œ íŠ¹ì • MCP ë„êµ¬ë¥¼ ì§ì ‘ ì‹¤í–‰í•©ë‹ˆë‹¤. (ì„œë²„ ë¶ˆí•„ìš”)
    """
    # mcp_modules íŒ¨í‚¤ì§€ì—ì„œ í•¨ìˆ˜ ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰
    tool_func = getattr(mcp_modules, name, None)
    if not tool_func:
        console.print(f"[bold red]ì˜¤ë¥˜: '{name}' ë„êµ¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.[/bold red]")
        console.print(f"ì‚¬ìš© ê°€ëŠ¥í•œ ë„êµ¬: {', '.join([x for x in dir(mcp_modules) if not x.startswith('_')])}")
        return

    # ì¸ì íŒŒì‹± (key=value ë¦¬ìŠ¤íŠ¸ -> dict)
    kwargs = {}
    if args:
        for arg in args:
            if "=" in arg:
                k, v = arg.split("=", 1)
                kwargs[k] = v
            else:
                console.print(f"[yellow]ê²½ê³ : ì¸ì '{arg}'ëŠ” key=value í˜•ì‹ì´ ì•„ë‹ˆì–´ì„œ ë¬´ì‹œë©ë‹ˆë‹¤.[/yellow]")

    console.print(f"[cyan]ë„êµ¬ ì‹¤í–‰: {name}[/cyan]")
    try:
        # ë™ê¸°/ë¹„ë™ê¸° í•¨ìˆ˜ êµ¬ë¶„í•˜ì—¬ ì‹¤í–‰
        if hasattr(tool_func, '__code__'):
            if inspect.iscoroutinefunction(tool_func):
                result = asyncio.run(tool_func(**kwargs))
            else:
                result = tool_func(**kwargs)
            
            console.print(Panel(str(result), title="ì‹¤í–‰ ê²°ê³¼", border_style="green"))
        else:
            console.print(f"[bold red]ì˜¤ë¥˜: '{name}'ì€(ëŠ”) ì‹¤í–‰ ê°€ëŠ¥í•œ í•¨ìˆ˜ê°€ ì•„ë‹™ë‹ˆë‹¤.[/bold red]")

    except Exception as e:
        console.print(f"[bold red]ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}[/bold red]")


@app.command()
def list():
    try:
        convos = list_conversations()
        table = Table("ID (Filename)", "Title", "Last Updated")
        for convo in convos:
            table.add_row(convo['id'], convo['title'], convo['last_updated'])
        console.print(table)
    except Exception as e:
        console.print(f"[bold red]ì˜¤ë¥˜: ëŒ€í™” ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ({e})[/bold red]")

@app.command()
def run(
    query: Annotated[str, typer.Option("--query", "-q", help="AI ì—ì´ì „íŠ¸ì—ê²Œ ë‚´ë¦´ ìƒˆë¡œìš´ ëª…ë ¹ì–´")] = None,
    continue_id: Annotated[str, typer.Option("--continue", "-c", help="ì´ì–´ê°ˆ ëŒ€í™”ì˜ ID (íŒŒì¼ëª…)")] = None,
    requirement_paths: Annotated[List[str], typer.Option("--req", "-r", help="ì°¸ì¡°í•  ìš”êµ¬ì‚¬í•­ íŒŒì¼ ê²½ë¡œ")] = None,
    model_pref: Annotated[str, typer.Option("--model-pref", "-m", help="ëª¨ë¸ ì„ í˜¸ë„ (auto, standard, high)")] = "auto",
    system_prompts: Annotated[List[str], typer.Option("--gem", "-g", help="ì‚¬ìš©í•  ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ì´ë¦„ (ì˜ˆ: default, developer)")] = None,
):
    """
    AI ì—ì´ì „íŠ¸ì™€ ìƒí˜¸ì‘ìš©ì„ ì‹œì‘í•©ë‹ˆë‹¤.
    """
    if not query and not continue_id:
        console.print("[bold red]ì˜¤ë¥˜: --query ë˜ëŠ” --continue ì˜µì…˜ ì¤‘ í•˜ë‚˜ëŠ” ë°˜ë“œì‹œ í•„ìš”í•©ë‹ˆë‹¤.[/bold red]")
        raise typer.Exit()

    client = httpx.Client(timeout=300)
    
    # [ìˆ˜ì •] í”„ë¡¬í”„íŠ¸ ë§¤ë‹ˆì €ë¥¼ ì‚¬ìš©í•˜ì—¬ íŒŒì¼ ë¡œë“œ
    prompt_contents = []
    if system_prompts:
        for prompt_name in system_prompts:
            content = prompt_manager.load(prompt_name)
            if "System Error" in content or "System Warning" in content:
                console.print(f"[bold yellow]{content}[/bold yellow]")
            else:
                prompt_contents.append(content)

    if query:
        convo_id, history = new_conversation()
        console.print(f"ìƒˆë¡œìš´ ëŒ€í™”ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤. (ID: {convo_id})")
        
        safe_query = query
        
        request_data = {
            "conversation_id": convo_id, 
            "history": history, 
            "user_input": safe_query, 
            "requirement_paths": requirement_paths,
            "model_preference": model_pref,
            "system_prompts": prompt_contents
        }
        endpoint = "/agent/decide_and_act"
    else: 
        convo_id = continue_id
        data = load_conversation(convo_id)
        if not data:
            console.print(f"[bold red]ì˜¤ë¥˜: ID '{convo_id}'ì— í•´ë‹¹í•˜ëŠ” ëŒ€í™”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.[/bold red]")
            raise typer.Exit()
        
        history = data.get("history", [])
        convo_id = data.get("id", convo_id) 
        console.print(f"ëŒ€í™”ë¥¼ ì´ì–´í•©ë‹ˆë‹¤. (ID: {convo_id})")
        
        user_input = safe_input("ì¶”ê°€/ìˆ˜ì • ì§€ì‹œê°€ ìˆë‚˜ìš”? (ì—†ìœ¼ë©´ Enter í‚¤ë¡œ ê¸°ì¡´ ê³„íš ê³„ì†)")
        
        request_data = {
            "conversation_id": convo_id, 
            "history": history, 
            "user_input": user_input or None,
            "model_preference": model_pref,
            "system_prompts": prompt_contents
        }
        endpoint = "/agent/decide_and_act"

    # --- ìƒí˜¸ì‘ìš© ë£¨í”„ ---
    while True:
        try:
            response = client.post(f"{ORCHESTRATOR_URL}{endpoint}", json=request_data)
            response.raise_for_status()
            data = response.json()
            
            status = data.get("status")
            message = data.get("message")
            convo_id = data.get("conversation_id")
            history = data.get("history") 
            new_plan_data = data.get("plan")
            next_group = data.get("execution_group") 

            if status == "FINAL_ANSWER":
                console.print(f"\n[bold green]âœ… ìµœì¢… ë‹µë³€:[/bold green]\n{message}")
                break

            elif status == "PLAN_CONFIRMATION":
                if new_plan_data:
                    console.print("\n[bold yellow]ì „ì²´ ì‹¤í–‰ ê³„íšì´ ìˆ˜ë¦½ë˜ì—ˆìŠµë‹ˆë‹¤.[/bold yellow]")
                    display_full_plan(new_plan_data)
                else:
                    console.print(f"\n[bold yellow]ë‹¤ìŒ ì‹¤í–‰ ê³„íš:[/bold yellow]\n{message}")
                
                is_dangerous = False
                # ìœ„í—˜ ì‘ì—… ì²´í¬ ë¡œì§ (ê¸°ì¡´ê³¼ ë™ì¼)
                tasks_to_check = []
                if next_group:
                    tasks_to_check = next_group.get('tasks', [])
                elif new_plan_data and new_plan_data[0].get('tasks'):
                    tasks_to_check = new_plan_data[0].get('tasks', [])
                
                for task in tasks_to_check:
                    if task.get('tool_name') in ["execute_shell_command", "execute_python_code"]:
                        is_dangerous = True
                        break

                if is_dangerous:
                    console.print("[bold red]ê²½ê³ : ë‹¤ìŒ ë‹¨ê³„ì— ìœ„í—˜ ì‘ì—…ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.[/bold red]")
                    action = safe_input("ìŠ¹ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ? [Y(ì˜ˆ)/n(ì•„ë‹ˆì˜¤)/edit(ê³„íš ìˆ˜ì •)]", default="Y").lower()
                else:
                      action = safe_input("ê³„íšì„ ìŠ¹ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ? [Y(ì˜ˆ)/n(ì•„ë‹ˆì˜¤)/edit(ê³„íš ìˆ˜ì •)]", default="Y").lower()
                
                if action in ["y", "yes"]:
                    console.print("[cyan]...ìŠ¹ì¸ë¨. ê³„íš ê·¸ë£¹ì„ ì‹¤í–‰í•©ë‹ˆë‹¤...[/cyan]")
                    endpoint = "/agent/execute_group"
                    request_data = {
                        "conversation_id": convo_id, 
                        "history": history,
                        "model_preference": model_pref,
                        "user_decision": None
                    }
                elif action == 'edit':
                    edited_instruction = safe_input("ì–´ë–»ê²Œ ìˆ˜ì •í• ê¹Œìš”? (ìƒˆë¡œìš´ ê³„íš ìˆ˜ë¦½)")
                    endpoint = "/agent/decide_and_act"
                    request_data = {
                        "conversation_id": convo_id, 
                        "history": history, 
                        "user_input": edited_instruction,
                        "model_preference": model_pref,
                        "system_prompts": prompt_contents
                    }
                else:
                    console.print("[bold red]ì‘ì—…ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.[/bold red]")
                    break
            
            elif status == "DANGEROUS_TASK_CONFIRMATION":
                details = data.get("dangerous_task_details", {})
                task_name = details.get("tool_name")
                arguments = details.get("arguments", {})
                
                console.print(f"\n[bold red]ğŸš¨ ìœ„í—˜ ì‘ì—… í™•ì¸ ğŸš¨[/bold red]")
                console.print(f"ì„œë²„ê°€ '{task_name}' ì‘ì—…ì„ ì‹¤í–‰í•˜ë ¤ê³  í•©ë‹ˆë‹¤.")
                
                code_to_run = arguments.get("code_str") or arguments.get("command") or "N/A"
                lang = "python" if task_name == "execute_python_code" else "shell"

                console.print(Panel(Syntax(code_to_run, lang, theme="monokai", line_numbers=True), title="ì‹¤í–‰ë  ì½”ë“œ/ëª…ë ¹ì–´"))
                
                action = safe_input(
                    "ì–´ë–»ê²Œ í•˜ì‹œê² ìŠµë‹ˆê¹Œ? [P(ì¦‰ì‹œ ì‹¤í–‰) / m(ì‹ ê·œ MCP ìƒì„± ìš”ì²­) / n(ì‘ì—… ì¤‘ë‹¨)]", 
                    default="n"
                ).lower()

                if action == 'p':
                    console.print("[cyan]...ì‚¬ìš©ì ìŠ¹ì¸. ì‹¤í–‰í•©ë‹ˆë‹¤...[/cyan]")
                    endpoint = "/agent/execute_group"
                    request_data = {
                        "conversation_id": convo_id, "history": history, "model_preference": model_pref,
                        "user_decision": "proceed"
                    }
                elif action == 'm':
                    console.print("[cyan]...ì‹ ê·œ MCP ìƒì„± ìš”ì²­...[/cyan]")
                    mcp_instruction = safe_input("ìš”ì²­ ì‚¬í•­ ì…ë ¥:", default=f"'{task_name}'ì„(ë¥¼) ëŒ€ì²´í•  ì•ˆì „í•œ MCP ëª¨ë“ˆì„ ìƒì„±í•´ì¤˜.")
                    endpoint = "/agent/decide_and_act"
                    request_data = {
                        "conversation_id": convo_id, "history": history, "model_preference": model_pref,
                        "user_decision": "create_mcp", "user_input": mcp_instruction
                    }
                else:
                    console.print("[bold red]ì‘ì—…ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.[/bold red]")
                    break

            elif status == "EXECUTION_ERROR":
                console.print(f"\n[bold red]âŒ ì‘ì—… ì¤‘ ì˜¤ë¥˜ ë°œìƒ:[/bold red]\n{message}")
                
                edited_instruction = safe_input("ì˜¤ë¥˜ ìˆ˜ì • ì§€ì‹œ (ì¤‘ë‹¨: 'n'/'exit'):")
                
                if edited_instruction.lower() in ['n', 'exit']:
                    console.print("[bold red]ì‘ì—…ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.[/bold red]")
                    break
                
                endpoint = "/agent/decide_and_act"
                request_data = {
                    "conversation_id": convo_id, "history": history, "user_input": edited_instruction,
                    "model_preference": model_pref, "system_prompts": prompt_contents 
                }

            elif status == "ERROR":
                console.print(f"[bold red]ì„œë²„ ì˜¤ë¥˜: {message}[/bold red]")
                break

        except httpx.RequestError:
            console.print("[bold red]ì˜¤ë¥˜: ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.[/bold red]")
            break
        except httpx.HTTPStatusError as e:
            console.print(f"[bold red]ì˜¤ë¥˜: ì„œë²„ ì‘ë‹µ ì—ëŸ¬ {e.response.text}[/bold red]")
            break

# --- Server ---
def is_port_in_use(port: int, host: str = "127.0.0.1") -> bool:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        return s.connect_ex((host, port)) == 0

@app.command(name="server")
def run_server(
    host: Annotated[str, typer.Option(help="í˜¸ìŠ¤íŠ¸ ì£¼ì†Œ")] = "127.0.0.1",
    port: Annotated[int, typer.Option(help="í¬íŠ¸ ë²ˆí˜¸")] = 8000,
    reload: Annotated[bool, typer.Option(help="ìë™ ì¬ì‹œì‘ ì—¬ë¶€")] = True,
):
    """FastAPI ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì„œë²„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤."""
    
    typer.echo(f"{port}ë²ˆ í¬íŠ¸ í™•ì¸ ì¤‘...")
    try:
        subprocess.run(["fuser", "-k", f"{port}/tcp"], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        typer.secho("ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ì™„ë£Œ.", fg=typer.colors.GREEN)
        time.sleep(1)
    except (FileNotFoundError, subprocess.CalledProcessError):
        pass

    typer.echo(f"FastAPI ì„œë²„ ì‹œì‘: http://{host}:{port}")
    # (ìˆ˜ì •) loop="asyncio" ì¶”ê°€: nest_asyncio í˜¸í™˜ì„± ë¬¸ì œ í•´ê²°
    uvicorn.run("orchestrator.api:app", host=host, port=port, reload=reload, loop="asyncio")

if __name__ == "__main__":
    app()
# prompts.py
from typing import Dict, Any
import json

class PromptManager:
    def __init__(self):
        # ê° ì—­í• ë³„ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ ì •ì˜
        self._prompts = {
            "architect": self._get_architect_prompt(),
            # ì¶”í›„ ì¶”ê°€: "debugger": self._get_debugger_prompt(), ...
        }

    def get_prompt(self, role: str, **kwargs) -> str:
        """
        ì—­í• (role)ì— ë§ëŠ” í”„ë¡¬í”„íŠ¸ë¥¼ ê°€ì ¸ì™€ì„œ ë™ì  ë°ì´í„°(kwargs)ë¥¼ ì£¼ì…(formatting)í•˜ì—¬ ë°˜í™˜
        """
        if role not in self._prompts:
            raise ValueError(f"Undefined role: {role}")
        
        template = self._prompts[role]
        try:
            return template.format(**kwargs)
        except KeyError as e:
            raise ValueError(f"Missing context key for '{role}': {e}")

    def _get_architect_prompt(self) -> str:
        return """
You are the **Architect Agent**, the master planner of this software development workflow.
Your goal is to analyze the user's request and the current project structure to create a precise, step-by-step execution plan.

## Global Constraints (MUST FOLLOW)
1. **Output Format:** You must respond with VALID JSON only. No Markdown, no thinking blocks outside JSON.
2. **Safety:** If the user asks to delete files or change system settings, flag it in 'risk_assessment'.
3. **Role Assignment:** Assign one of the following agents for each step: [Developer, Debugger, Tool Maker, Refactoring, Gemini Loop, Test Engineer, Doc Writer].

## Context Information
- **User Request:** {user_request}
- **Current Project Structure (File List):**
{file_list}

## JSON Output Schema
{{
    "thought_process": "Brief reasoning behind the plan",
    "risk_assessment": "Low/Medium/High - Reason",
    "plan": [
        {{
            "step_id": 1,
            "role": "Agent Role Name",
            "task_description": "Detailed instruction for the agent",
            "expected_output": "What file or result is expected"
        }}
    ]
}}
"""
    
    # ë‹¤ë¥¸ ì—ì´ì „íŠ¸ í”„ë¡¬í”„íŠ¸ ë©”ì„œë“œë“¤ì€ ì´ê³³ì— ì¶”ê°€ (Hardening ë‹¨ê³„)
# test_architect.py
import os
import google.generativeai as genai
from prompts import PromptManager

# 1. Gemini ì„¤ì • (API KeyëŠ” í™˜ê²½ë³€ìˆ˜ ë“±ì—ì„œ ë¡œë“œ)
genai.configure(api_key=os.environ.get("GEMINI_API_KEY"))

# JSON ëª¨ë“œë¥¼ ê°•ì œí•˜ê¸° ìœ„í•œ ëª¨ë¸ ì„¤ì • (Gemini 1.5 Pro/Flash ê¶Œì¥)
model = genai.GenerativeModel(
    'gemini-1.5-flash',
    generation_config={"response_mime_type": "application/json"}
)

def test_architect():
    # 2. í”„ë¡¬í”„íŠ¸ ë§¤ë‹ˆì € ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
    pm = PromptManager()

    # 3. ì‹œë®¬ë ˆì´ì…˜ ìƒí™© ì„¤ì • (Mock Data)
    user_request = "í˜„ì¬ í”„ë¡œì íŠ¸ì˜ main.pyë¥¼ ë¶„ì„í•´ì„œ ë¡œê¹… ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ê³  ì‹¶ì–´. ë¡œê·¸ íŒŒì¼ì€ logs í´ë”ì— ì €ì¥í•´ì¤˜."
    file_list = """
    - main.py
    - requirements.txt
    - README.md
    """

    # 4. í”„ë¡¬í”„íŠ¸ ìƒì„± (ë™ì  ì»¨í…ìŠ¤íŠ¸ ì£¼ì…)
    try:
        final_prompt = pm.get_prompt(
            role="architect",
            user_request=user_request,
            file_list=file_list
        )
        print(f"--- [Generated Prompt] ---\n{final_prompt}\n--------------------------")
    except Exception as e:
        print(f"Prompt Error: {e}")
        return

    # 5. Gemini ì‹¤í–‰
    try:
        response = model.generate_content(final_prompt)
        print(f"--- [Gemini Response] ---\n{response.text}")
        
        # JSON íŒŒì‹± ê²€ì¦ í™•ì¸ (Python Body ì—­í• )
        import json
        plan_json = json.loads(response.text)
        print("\nâœ… JSON Parsing Successful!")
        print(f"Plan Steps: {len(plan_json.get('plan', []))}")
        
    except Exception as e:
        print(f"âŒ Execution Error: {e}")

if __name__ == "__main__":
    test_architect()
#!/usr/bin/env python3

import logging

# orchestrator íŒ¨í‚¤ì§€ê°€ ì²˜ìŒ importë  ë•Œ ë¡œê¹… ê¸°ë³¸ ì„¤ì •ì„ ìˆ˜í–‰
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

print("ğŸš€ Orchestrator package has been initialized.")
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# orchestrator/api.py

from fastapi import FastAPI, HTTPException
from .models import AgentRequest, AgentResponse, GeminiToolCall, ExecutionGroup
from .gemini_client import (
    generate_execution_plan, 
    generate_final_answer, 
    generate_title_for_conversation,
    generate_new_mcp_code
)
from . import tool_registry
from . import history_manager
import inspect
import os
import re
from datetime import datetime
import nest_asyncio # (ìˆ˜ì •) ì¶”ê°€: ì¤‘ì²© ì´ë²¤íŠ¸ ë£¨í”„ í—ˆìš© ë¼ì´ë¸ŒëŸ¬ë¦¬

# (ìˆ˜ì •) ì‹¤í–‰ ì¤‘ì¸ ì´ë²¤íŠ¸ ë£¨í”„ì—ì„œ asyncio.run() í˜¸ì¶œ ì‹œ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ ë°©ì§€
nest_asyncio.apply()

app = FastAPI(title="Gemini Agent Orchestrator")

# ìœ„í—˜í•˜ë‹¤ê³  ê°„ì£¼í•  ë„êµ¬ ëª©ë¡
DANGEROUS_TOOLS = ["execute_shell_command", "execute_python_code"]

@app.on_event("startup")
async def startup_event():
    tool_registry.load_tools()

@app.post("/agent/reload_tools", response_model=AgentResponse)
async def reload_tools(request: AgentRequest):
    """ìƒˆë¡œ ìƒì„±ëœ MCP íŒŒì¼ì„ ì½ì–´ ë„êµ¬ ëª©ë¡ì„ ë‹¤ì‹œ ë¡œë“œí•©ë‹ˆë‹¤."""
    try:
        tool_registry.load_tools()
        history = request.history or []
        history.append("ì‹œìŠ¤í…œ: ìƒˆ ë„êµ¬ë¥¼ ì„±ê³µì ìœ¼ë¡œ ë¦¬ë¡œë“œí–ˆìŠµë‹ˆë‹¤.")
        
        return AgentResponse(
            conversation_id=request.conversation_id,
            status="PLAN_CONFIRMATION",
            history=history,
            message="ìƒˆ ë„êµ¬ë¥¼ ë¦¬ë¡œë“œí–ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ê³„íšì„ ì§„í–‰í•©ë‹ˆë‹¤.",
        )
    except Exception as e:
        return AgentResponse(
            conversation_id=request.conversation_id,
            status="ERROR",
            history=request.history,
            message=f"ë„êµ¬ ë¦¬ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}",
        )


@app.post("/agent/decide_and_act", response_model=AgentResponse)
async def decide_and_act(request: AgentRequest):
    """
    ì‚¬ìš©ì ì…ë ¥(ì‹ ê·œ ë˜ëŠ” ìˆ˜ì •)ì— ë”°ë¼ 'Planner' ëª¨ë¸ì„ í˜¸ì¶œí•˜ì—¬ ì‹¤í–‰ ê³„íšì„ ìˆ˜ë¦½í•©ë‹ˆë‹¤.
    """
    
    data = history_manager.load_conversation(request.conversation_id)
    history = data.get("history", []) if data else request.history
    plan_dicts = data.get("plan", []) if data else []
    current_group_index = data.get("current_group_index", 0) if data else 0
    convo_id = data.get("id", request.conversation_id) if data else request.conversation_id

    # ì‚¬ìš©ìê°€ 'ìƒˆ MCP ìƒì„±'ì„ ì„ íƒí•œ ê²½ìš°
    if request.user_decision == "create_mcp" and request.user_input:
        try:
            mcp_code = await generate_new_mcp_code(
                user_instruction=request.user_input,
                history=history,
                model_preference=request.model_preference
            )
            
            history.append(f"ì‚¬ìš©ì ìš”ì²­: {request.user_input}")
            history.append(f"AI ì‘ë‹µ (ì‹ ê·œ MCP ì½”ë“œ ì œì•ˆ):\n```python\n{mcp_code}\n```")
            
            user_query = "ë°©ê¸ˆ ì œì•ˆëœ MCP ì½”ë“œë¥¼ 'mcp_modules/mcp_custom_tool.py' íŒŒì¼ë¡œ ì €ì¥í•˜ê³ , ë„êµ¬ë¥¼ ë¦¬ë¡œë“œí•œ ë’¤, ì›ë˜ ëª©í‘œë¥¼ ì´ ìƒˆ ë„êµ¬ë¡œ ë‹¤ì‹œ ì‹œë„í•˜ëŠ” ê³„íšì„ ìˆ˜ë¦½í•´ì¤˜."
            
            request.user_input = user_query 

        except Exception as e:
            history.append(f"MCP ì½”ë“œ ìƒì„± ì¤‘ ì˜¤ë¥˜: {e}")
            return AgentResponse(
                conversation_id=convo_id, status="ERROR", history=history,
                message=f"ìƒˆ MCP ìƒì„± AI í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}"
            )

    # 1. ì‚¬ìš©ì ì…ë ¥ì´ ìˆëŠ” ê²½ìš° (ì‹ ê·œ ì‘ì—… ë˜ëŠ” ê³„íš ìˆ˜ì •)
    if request.user_input:
        query = request.user_input
        if not query.startswith("ì‚¬ìš©ì ìš”ì²­:"):
            history.append(f"ì‚¬ìš©ì ìš”ì²­: {query}")
        
        requirements_content = ""
        if request.requirement_paths:
            pass
            
        try:
            plan_list = await generate_execution_plan(
                user_query=query, 
                requirements_content=requirements_content, 
                history=history,
                model_preference=request.model_preference,
                system_prompts=request.system_prompts or []
            )
            
            if not plan_list:
                raise HTTPException(status_code=500, detail="ê³„íš ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤ (ë¹ˆ ê³„íš ë°˜í™˜).")
            
            plan_dicts = [group.model_dump() for group in plan_list]
            current_group_index = 0
            title = f"ê³„íš ìˆ˜ë¦½: {plan_list[0].description[:20]}..."
            
            history_manager.save_conversation(
                convo_id, history, title, plan_dicts, current_group_index, is_final=False
            )
            
            return AgentResponse(
                conversation_id=convo_id,
                status="PLAN_CONFIRMATION",
                history=history,
                message=f"ì „ì²´ ê³„íšì´ ìˆ˜ë¦½ë˜ì—ˆìŠµë‹ˆë‹¤. {len(plan_list)}ê°œ ê·¸ë£¹.",
                plan=[group.model_dump() for group in plan_list]
            )

        except Exception as e:
            history.append(f"ê³„íš ìˆ˜ë¦½ ì˜¤ë¥˜: {e}")
            history_manager.save_conversation(convo_id, history, "ê³„íš ì‹¤íŒ¨", is_final=False)
            return AgentResponse(
                conversation_id=convo_id, status="ERROR", history=history,
                message=f"ê³„íš ìˆ˜ë¦½ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}"
            )

    # 5. ì‚¬ìš©ì ì…ë ¥ì´ ì—†ëŠ” ê²½ìš° (ê¸°ì¡´ ê³„íš ê³„ì†)
    else:
        if not plan_dicts or current_group_index >= len(plan_dicts):
            return AgentResponse(
                conversation_id=convo_id, status="FINAL_ANSWER", history=history,
                message="ëª¨ë“  ê³„íšì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
            )
            
        plan_list = [ExecutionGroup(**group) for group in plan_dicts]
        next_group = plan_list[current_group_index]
        
        return AgentResponse(
            conversation_id=convo_id,
            status="PLAN_CONFIRMATION",
            history=history,
            message=f"ì €ì¥ëœ ë‹¤ìŒ ê³„íš: [{next_group.group_id}] {next_group.description}",
            execution_group=next_group
        )


@app.post("/agent/execute_group", response_model=AgentResponse)
async def execute_group(request: AgentRequest):
    """
    ì‚¬ìš©ìê°€ ìŠ¹ì¸í•œ 'ExecutionGroup'ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
    """
    data = history_manager.load_conversation(request.conversation_id)
    if not data:
        raise HTTPException(status_code=404, detail="ëŒ€í™” IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    history = data.get("history", [])
    plan_dicts = data.get("plan", [])
    current_group_index = data.get("current_group_index", 0)
    convo_id = data.get("id", request.conversation_id)

    if not plan_dicts or current_group_index >= len(plan_dicts):
        raise HTTPException(status_code=400, detail="ì‹¤í–‰í•  ê³„íšì´ ì—†ìŠµë‹ˆë‹¤.")

    plan_list = [ExecutionGroup(**group) for group in plan_dicts]
    group_to_execute = plan_list[current_group_index]
    
    # 1. ì´ì „ ì‹¤í–‰ ê²°ê³¼ ìˆ˜ì§‘
    previous_results = []
    for item in history:
        if item.startswith("  - ì‹¤í–‰ ê²°ê³¼: "):
            result_content = item.split(": ", 1)[1]
            previous_results.append(result_content)
    merged_results = "\n\n".join(previous_results)
    last_result = previous_results[-1] if previous_results else ""
    
    history.append(f"ê·¸ë£¹ ì‹¤í–‰ ì‹œì‘: [{group_to_execute.group_id}] {group_to_execute.description}")

    try:
        # ê·¸ë£¹ ë‚´ì˜ ëª¨ë“  íƒœìŠ¤í¬(ë„êµ¬)ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰
        for task in group_to_execute.tasks:
            
            # ìœ„í—˜ ì‘ì—… ê°ì§€
            if task.tool_name in DANGEROUS_TOOLS and request.user_decision != "proceed":
                history.append(f"  - ìœ„í—˜ ì‘ì—… ê°ì§€: {task.tool_name}. ì‚¬ìš©ì í™•ì¸ í•„ìš”.")
                history_manager.save_conversation(
                    convo_id, history, data.get("title", "ìœ„í—˜ ì‘ì—… ëŒ€ê¸°"), 
                    plan_dicts, current_group_index, is_final=False
                )
                return AgentResponse(
                    conversation_id=convo_id,
                    status="DANGEROUS_TASK_CONFIRMATION",
                    history=history,
                    message=f"'{task.tool_name}'ì€(ëŠ”) ìœ„í—˜í•œ ì‘ì—…ì…ë‹ˆë‹¤. ì‹¤í–‰ ì½”ë“œë¥¼ í™•ì¸í•˜ì„¸ìš”.",
                    dangerous_task_details={
                        "tool_name": task.tool_name,
                        "arguments": task.arguments
                    }
                )

            # 'reload_tools'ëŠ” MCPê°€ ì•„ë‹ˆë¯€ë¡œ íŠ¹ë³„ ì²˜ë¦¬
            if task.tool_name == "reload_tools":
                history.append("  - íŠ¹ìˆ˜ ëª…ë ¹ ì‹¤í–‰: reload_tools")
                tool_registry.load_tools()
                history.append("  - ì‹¤í–‰ ê²°ê³¼: ë„êµ¬ ë¦¬ë¡œë“œ ì™„ë£Œ")
                continue

            tool_function = tool_registry.get_tool(task.tool_name)
            if not tool_function:
                raise ValueError(f"'{task.tool_name}' ë„êµ¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            
            # 2. ì¸ì ì¹˜í™˜ (ARGUMENT SUBSTITUTION)
            substituted_args = {}
            for key, value in task.arguments.items():
                if isinstance(value, str):
                    if value == "$MERGED_RESULTS":
                        substituted_args[key] = merged_results
                    elif value == "$LAST_RESULT":
                        substituted_args[key] = last_result
                    else:
                        substituted_args[key] = value
                else:
                    substituted_args[key] = value
            
            history.append(f"  - ë„êµ¬ ì‹¤í–‰: {task.tool_name} (ì¸ì: {substituted_args})")
            
            if inspect.iscoroutinefunction(tool_function):
                result = await tool_function(**substituted_args)
            else:
                result = tool_function(**substituted_args)
            
            result_str = str(result)
            history.append(f"  - ì‹¤í–‰ ê²°ê³¼: {result_str}")

        history.append(f"ê·¸ë£¹ ì‹¤í–‰ ì™„ë£Œ: [{group_to_execute.group_id}]")
        current_group_index += 1
        
        history_manager.save_conversation(
            convo_id, history, data.get("title", "ì‹¤í–‰ ì¤‘"), plan_dicts, current_group_index,
            is_final=False
        )

    except Exception as e:
        history.append(f"ê·¸ë£¹ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        history_manager.save_conversation(
            convo_id, history, "ì‹¤í–‰ ì˜¤ë¥˜", plan_dicts, current_group_index,
            is_final=False
        )
        return AgentResponse(
            conversation_id=convo_id,
            status="EXECUTION_ERROR",
            history=history,
            message=f"ê·¸ë£¹ '{group_to_execute.group_id}' ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {e}",
        )

    # 7. ë‹¤ìŒ ê³„íš í™•ì¸ ë˜ëŠ” ìµœì¢… ë‹µë³€
    if current_group_index < len(plan_list):
        next_group = plan_list[current_group_index]
        return AgentResponse(
            conversation_id=convo_id,
            status="PLAN_CONFIRMATION",
            history=history,
            message=f"ë‹¤ìŒ ê³„íš: [{next_group.group_id}] {next_group.description}",
            execution_group=next_group
        )
    else:
        final_answer = await generate_final_answer(
            history, model_preference=request.model_preference
        )
        history.append(f"ìµœì¢… ë‹µë³€: {final_answer}")
        
        title_summary = await generate_title_for_conversation(
            history, model_preference=request.model_preference
        )
        
        history_manager.save_conversation(
            convo_id, history, title_summary, plan_dicts, current_group_index,
            is_final=True
        )
        
        final_data = history_manager.load_conversation(convo_id)
        final_id = final_data.get("id", convo_id) if final_data else convo_id

        return AgentResponse(
            conversation_id=final_id, 
            status="FINAL_ANSWER",
            history=history,
            message=final_answer
        )
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# orchestrator/gemini_client.py

import google.generativeai as genai
import os
import json
import logging 
from dotenv import load_dotenv
from typing import List, Dict, Any, Literal
from pathlib import Path

# [ì‹ ê·œ] í”„ë¡¬í”„íŠ¸ ë§¤ë‹ˆì € ë„ì…
from shared.prompt_manager import prompt_manager

from .tool_registry import get_all_tool_descriptions, MCP_DIRECTORY
from .models import GeminiToolCall, ExecutionGroup

load_dotenv()
genai.configure(api_key=os.getenv("GEMINI_API_KEY"))

HIGH_PERF_MODEL_NAME = os.getenv("GEMINI_HIGH_PERF_MODEL", "gemini-1.5-pro-latest")
STANDARD_MODEL_NAME = os.getenv("GEMINI_STANDARD_MODEL", "gemini-1.5-flash-latest")
ModelPreference = Literal["auto", "standard", "high"]

# ë¡œê±° ì„¤ì •
logger = logging.getLogger(__name__)

# ëª¨ë¸ ì´ˆê¸°í™”
try:
    high_perf_model = genai.GenerativeModel(
        HIGH_PERF_MODEL_NAME,
        generation_config={"response_mime_type": "application/json"}
    )
    standard_model = genai.GenerativeModel(STANDARD_MODEL_NAME)
    standard_model_json = genai.GenerativeModel(
        STANDARD_MODEL_NAME,
        generation_config={"response_mime_type": "application/json"}
    )
except Exception as e:
    logger.error(f"ëª¨ë¸ ì´ˆê¸°í™” ì˜¤ë¥˜: {e}. ê¸°ë³¸ ëª¨ë¸ë¡œ í´ë°±í•©ë‹ˆë‹¤.")
    high_perf_model = genai.GenerativeModel('gemini-pro', generation_config={"response_mime_type": "application/json"})
    standard_model = genai.GenerativeModel('gemini-pro')
    standard_model_json = genai.GenerativeModel('gemini-pro', generation_config={"response_mime_type": "application/json"})


def get_model(
    model_preference: ModelPreference = "auto",
    default_type: Literal["high", "standard"] = "standard",
    needs_json: bool = False
) -> genai.GenerativeModel:
    if model_preference == "high":
        return high_perf_model if needs_json else genai.GenerativeModel(HIGH_PERF_MODEL_NAME)
    
    if model_preference == "standard":
        return standard_model_json if needs_json else standard_model
    
    if default_type == "high":
        return high_perf_model if needs_json else genai.GenerativeModel(HIGH_PERF_MODEL_NAME)
    else: 
        return standard_model_json if needs_json else standard_model


async def generate_execution_plan(
    user_query: str, 
    requirements_content: str, 
    history: list,
    model_preference: ModelPreference = "auto",
    system_prompts: List[str] = None
) -> List[ExecutionGroup]:
    """
    ì‚¬ìš©ì ìš”ì²­ì„ ë¶„ì„í•˜ì—¬ ì‹¤í–‰ ê³„íš(JSON)ì„ ìˆ˜ë¦½í•©ë‹ˆë‹¤.
    PromptManagerë¥¼ ì‚¬ìš©í•˜ì—¬ 'planner' í˜ë¥´ì†Œë‚˜ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.
    """
    
    model_to_use = get_model(model_preference, default_type="high", needs_json=True)

    tool_descriptions = get_all_tool_descriptions()
    formatted_history = "\n".join(history[-10:]) 
    
    # [ìˆ˜ì •] í”„ë¡¬í”„íŠ¸ ë§¤ë‹ˆì € ì‚¬ìš©
    # ì‚¬ìš©ìê°€ CLIì—ì„œ --gem ì˜µì…˜ìœ¼ë¡œ ì „ë‹¬í•œ í”„ë¡¬í”„íŠ¸ê°€ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš©í•˜ê³ ,
    # ì—†ìœ¼ë©´ ê¸°ë³¸ 'planner' í”„ë¡¬í”„íŠ¸ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.
    if system_prompts:
        base_system_prompt = "\n".join(system_prompts)
    else:
        # system_prompts/planner.txt ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ë°˜í™˜ë¨
        base_system_prompt = prompt_manager.load("planner")

    prompt = f"""
    {base_system_prompt}
    
    ë‹¹ì‹ ì€ ì‚¬ìš©ìì˜ ë³µì¡í•œ ëª©í‘œë¥¼ ë‹¬ì„±í•˜ê¸° ìœ„í•´, ì£¼ì–´ì§„ ë„êµ¬ë“¤ì„ í™œìš©í•˜ì—¬ ì²´ê³„ì ì¸ ì‹¤í–‰ ê³„íšì„ ìˆ˜ë¦½í•˜ëŠ” 'ë§ˆìŠ¤í„° í”Œë˜ë„ˆ'ì…ë‹ˆë‹¤.

    ## ìµœì¢… ëª©í‘œ:
    {user_query}

    ## ì‚¬ìš©ìê°€ ì œê³µí•œ ì¶”ê°€ ìš”êµ¬ì‚¬í•­ ë° ì»¨í…ìŠ¤íŠ¸:
    {requirements_content if requirements_content else "ì—†ìŒ"}

    ## ì‚¬ìš© ê°€ëŠ¥í•œ ë„êµ¬ ëª©ë¡:
    {tool_descriptions}
    
    ## (íŠ¹ìˆ˜ ëª…ë ¹)
    - reload_tools: ìƒˆë¡œ ìƒì„±ëœ MCP íŒŒì¼ì„ mcp_modulesì—ì„œ ë‹¤ì‹œ ë¡œë“œí•˜ì—¬ ì¦‰ì‹œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤. MCP íŒŒì¼ ì‘ì„±(write_file) ì§í›„ì— ì´ ë„êµ¬ë¥¼ í˜¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤.

    ## ì´ì „ ëŒ€í™” ìš”ì•½ (ì°¸ê³ ìš©):
    {formatted_history}

    ## [ë§¤ìš° ì¤‘ìš”] ì§€ì‹œì‚¬í•­:
    1. ì‚¬ìš©ìì˜ 'ìµœì¢… ëª©í‘œ'ì™€ 'ì´ì „ ëŒ€í™”'ë¥¼ ë¶„ì„í•˜ì—¬, ëª©í‘œ ë‹¬ì„±ì— í•„ìš”í•œ ëª¨ë“  ì‘ì—…ì„ ì‹ë³„í•©ë‹ˆë‹¤.
    2. ì‘ì—…ë“¤ì„ ë…¼ë¦¬ì ì¸ ìˆœì„œì— ë”°ë¼ 'ì‹¤í–‰ ê·¸ë£¹(ExecutionGroup)' ë‹¨ìœ„ë¡œ ë¬¶ì–´ì£¼ì„¸ìš”.
    3. (ì¤‘ìš”) í•œ íƒœìŠ¤í¬ê°€ ì´ì „ ê·¸ë£¹ì˜ ê²°ê³¼(ì˜ˆ: 'find_files'ì˜ ê²°ê³¼)ë¥¼ ì¸ìë¡œ ì‚¬ìš©í•´ì•¼ í•œë‹¤ë©´, `arguments` ê°’ì— `"$LAST_RESULT"` ë˜ëŠ” `"$MERGED_RESULTS"` í”Œë ˆì´ìŠ¤í™€ë”ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.
    
    ## [ì ˆëŒ€ ê·œì¹™] ì¶œë ¥ í˜•ì‹:
    ë°˜ë“œì‹œ ë‹¤ìŒ JSON ìŠ¤í‚¤ë§ˆë¥¼ 'ì •í™•í•˜ê²Œ' ë”°ë¥´ëŠ” 'ExecutionGroup' ê°ì²´ì˜ ë¦¬ìŠ¤íŠ¸(ë°°ì—´) í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µí•´ì•¼ í•©ë‹ˆë‹¤.
    'thought', 'group_name', 'args' ê°™ì€ ì„ì˜ì˜ í‚¤ë¥¼ ì ˆëŒ€ ì‚¬ìš©í•˜ì§€ ë§ˆì„¸ìš”.
    ì˜¤ì§ 'group_id', 'description', 'tasks', 'tool_name', 'arguments', 'model_preference' ë§Œ ì‚¬ìš©í•˜ì„¸ìš”.

    [
      {{
        "group_id": "group_1",
        "description": "ì²« ë²ˆì§¸ ì‹¤í–‰ ê·¸ë£¹ì— ëŒ€í•œ ì‚¬ìš©ì ì¹œí™”ì  ì„¤ëª…",
        "tasks": [
          {{ 
            "tool_name": "ì‚¬ìš©í• _ë„êµ¬_ì´ë¦„_1", 
            "arguments": {{"ì¸ì1": "ê°’1"}},
            "model_preference": "standard" 
          }}
        ]
      }},
      {{
        "group_id": "group_2",
        "description": "ë‘ ë²ˆì§¸ ì‹¤í–‰ ê·¸ë£¹ì— ëŒ€í•œ ì„¤ëª… (ì˜ˆ: ì´ì „ ê²°ê³¼ ì‚¬ìš©)",
        "tasks": [
          {{ 
            "tool_name": "ì‚¬ìš©í• _ë„êµ¬_ì´ë¦„_2", 
            "arguments": {{"content": "$LAST_RESULT", "path": "./output.txt"}},
            "model_preference": "high"
          }}
        ]
      }}
    ]

    ## ì‹¤í–‰ ê³„íš (JSON):
    """

    try:
        response = await model_to_use.generate_content_async(prompt)
        cleaned_text = response.text.strip().replace("```json", "").replace("```", "").strip()
        
        parsed_json = json.loads(cleaned_text)
        
        plan = [ExecutionGroup(**group) for group in parsed_json]
        return plan
        
    except (json.JSONDecodeError, TypeError, ValueError) as e:
        logger.error(f"JSON íŒŒì‹± ì˜¤ë¥˜: {e}\në°›ì€ ì‘ë‹µ: {response.text}")
        raise ValueError(f"Planner ëª¨ë¸ì´ ìœ íš¨í•œ JSON ê³„íšì„ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: {e}")
    except Exception as e:
        logger.error(f"Planner ëª¨ë¸ í˜¸ì¶œ ì˜¤ë¥˜: {e}")
        raise e


async def generate_new_mcp_code(
    user_instruction: str,
    history: list,
    model_preference: ModelPreference = "auto"
) -> str:
    """
    'Agent Developer' í˜ë¥´ì†Œë‚˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒˆë¡œìš´ MCP ëª¨ë“ˆ ì½”ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
    """
    
    model_to_use = get_model(model_preference, default_type="high", needs_json=False)

    # ìŠ¤íƒ€ì¼ ê°€ì´ë“œ íŒŒì¼ ë¡œë“œ
    style_guide_files = [
        "file_content_operations.py", 
        "code_execution_atomic.py",   
        "web_network_atomic.py"       
    ]
    style_guide_code = ""

    for file_name in style_guide_files:
        style_guide_path = Path(MCP_DIRECTORY) / file_name
        try:
            if style_guide_path.exists():
                header = f"\n# --- ì˜ˆì‹œ: {file_name} ---\n"
                code = style_guide_path.read_text(encoding='utf-8')
                code = code.replace("{", "{{").replace("}", "}}") # f-string ì´ìŠ¤ì¼€ì´í”„
                style_guide_code += header + code
            else:
                logging.warning(f"MCP ìŠ¤íƒ€ì¼ ê°€ì´ë“œ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: {file_name}")
        except Exception as e:
            logging.warning(f"MCP ìŠ¤íƒ€ì¼ ê°€ì´ë“œ ë¡œë“œ ì‹¤íŒ¨ ({file_name}): {e}")

    if not style_guide_code:
        style_guide_code = "# (ìŠ¤íƒ€ì¼ ê°€ì´ë“œ ë¡œë“œ ì‹¤íŒ¨. ê¸°ë³¸ Python ìŠ¤íƒ€ì¼ì„ ì‚¬ìš©í•˜ì„¸ìš”.)"

    formatted_history = "\n".join(history[-10:]) 

    # [ìˆ˜ì •] PromptManagerì—ì„œ 'developer' í˜ë¥´ì†Œë‚˜ ë¡œë“œ
    developer_persona = prompt_manager.load("developer")

    prompt = f"""
    {developer_persona}
    
    ì‚¬ìš©ìê°€ 'ìœ„í—˜í•œ ì‘ì—…' ëŒ€ì‹  ë” ì•ˆì „í•˜ê³  ì¬ì‚¬ìš© ê°€ëŠ¥í•œ Python MCP ëª¨ë“ˆ ìƒì„±ì„ ìš”ì²­í–ˆìŠµë‹ˆë‹¤.

    ## ì‚¬ìš©ìì˜ ìš”ì²­:
    {user_instruction}

    ## í˜„ì¬ ëŒ€í™” ë° ì˜¤ë¥˜ ë§¥ë½:
    {formatted_history}

    ## [ë§¤ìš° ì¤‘ìš”] ì½”ë”© ìŠ¤íƒ€ì¼ ê°€ì´ë“œ:
    ìƒˆë¡œ ìƒì„±í•˜ëŠ” MCP ì½”ë“œëŠ” ë°˜ë“œì‹œ ë‹¤ìŒ 'ì˜ˆì‹œ ì½”ë“œ'ì˜ ìŠ¤íƒ€ì¼ì„ ë”°ë¼ì•¼ í•©ë‹ˆë‹¤.
    - `logging` ì‚¬ìš© í•„ìˆ˜
    - `pathlib.Path` ì‚¬ìš© í•„ìˆ˜
    - `typing` (List, Union, Optional ë“±) ì‚¬ìš© í•„ìˆ˜
    - ëª…í™•í•œ Docstring í¬í•¨ (Plannerê°€ ì¸ì‹í•˜ëŠ” ë° í•„ìˆ˜)
    - ê°•ë ¥í•œ ì˜ˆì™¸ ì²˜ë¦¬(try...except, raise) í¬í•¨

    ## ì˜ˆì‹œ ì½”ë“œ (ìŠ¤íƒ€ì¼ ê°€ì´ë“œ):
    ```python
    {style_guide_code}
    ```

    ## ì§€ì‹œì‚¬í•­:
    ì‚¬ìš©ìì˜ ìš”ì²­ì„ í•´ê²°í•  ìˆ˜ ìˆëŠ” **ë‹¨ì¼ Python í•¨ìˆ˜**ë¥¼ í¬í•¨í•œ **ì™„ì „í•œ MCP ëª¨ë“ˆ íŒŒì¼ ì½”ë“œ**ë¥¼ ìƒì„±í•˜ì„¸ìš”.
    - ë§ˆí¬ë‹¤ìš´ ë˜í¼ ì—†ì´ **ì˜¤ì§ Python ì½”ë“œ**ë§Œ ë°˜í™˜í•˜ì„¸ìš”.
    - í•¨ìˆ˜ ì´ë¦„ì€ ëª…í™•í•˜ê²Œ (ì˜ˆ: `show_and_confirm_changes`) ì§€ì–´ì£¼ì„¸ìš”.

    ## ì‹ ê·œ MCP ëª¨ë“ˆ ì½”ë“œ:
    """

    try:
        response = await model_to_use.generate_content_async(prompt)
        code_content = response.text.strip()
        # ë§ˆí¬ë‹¤ìš´ ë˜í¼ ì œê±°
        if code_content.startswith("```python"):
            code_content = code_content[9:]
        if code_content.endswith("```"):
            code_content = code_content[:-3]
        return code_content.strip()
    except Exception as e:
        logging.error(f"MCP ìƒì„± AI í˜¸ì¶œ ì‹¤íŒ¨: {e}")
        raise

async def generate_final_answer(
    history: list, 
    model_preference: ModelPreference = "auto"
) -> str:
    model_to_use = get_model(model_preference, default_type="standard", needs_json=False)
    
    if len(history) > 15:
        truncated_history_list = history[:2] + ["... (ì¤‘ê°„ ê¸°ë¡ ìƒëµ) ..."] + history[-13:]
        history_str = '\n'.join(truncated_history_list)
    else:
        history_str = '\n'.join(history)

    # [ìˆ˜ì •] PromptManager ì‚¬ìš© (ê¸°ë³¸ê°’: summarizer.txt)
    summary_prompt = prompt_manager.load("summarizer")
    
    full_prompt = f"""
    {summary_prompt}
    
    --- ì‘ì—… ê¸°ë¡ ìš”ì•½ ---
    {history_str}
    ---

    ìµœì¢… ë‹µë³€:
    """
    try:
        response = await model_to_use.generate_content_async(full_prompt)
        if not response.parts:
                raise ValueError("ëª¨ë¸ì´ ë¹ˆ ì‘ë‹µì„ ë°˜í™˜í–ˆìŠµë‹ˆë‹¤.")
        return response.text.strip()
    except Exception as e:
        logging.error(f"Executor (generate_final_answer) ì˜¤ë¥˜: {e}", exc_info=True)
        return "ìµœì¢… ìš”ì•½ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."

async def generate_title_for_conversation(
    history: list, 
    model_preference: ModelPreference = "auto"
) -> str:
    model_to_use = get_model(model_preference, default_type="standard", needs_json=False)
    if len(history) < 2:
        return "ìƒˆë¡œìš´_ëŒ€í™”"
        
    summary_prompt = f"""
    ë‹¤ìŒ ëŒ€í™” ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ, ì–´ë–¤ ì‘ì—…ì„ ìˆ˜í–‰í–ˆëŠ”ì§€ ì•Œ ìˆ˜ ìˆë„ë¡ 5ë‹¨ì–´ ì´ë‚´ì˜ ê°„ê²°í•œ 'ìš”ì•½'ì„ í•œêµ­ì–´ë¡œ ë§Œë“¤ì–´ì¤˜.

    --- ëŒ€í™” ë‚´ìš© (ì´ˆë°˜ 2ê°œ) ---
    {history[0]}
    {history[1] if len(history) > 1 else ""}
    ---

    ìš”ì•½:
    """
    try:
        response = await model_to_use.generate_content_async(summary_prompt)
        if not response.parts:
                return "ìš”ì•½_ì‹¤íŒ¨"
        return response.text.strip().replace("*", "").replace("`", "").replace("\"", "")
    except Exception:
        return "Untitled_Conversation"
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# orchestrator/history_manager.py

import os
import json
import re
from datetime import datetime
from typing import List, Dict, Any, Tuple, Optional
import uuid

HISTORY_DIR = "history"
os.makedirs(HISTORY_DIR, exist_ok=True)

def _sanitize_title(title: str, max_length: int = 20) -> str:
    """
    (ìš”ì²­ì‚¬í•­ 3) íŒŒì¼ëª…ì— ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì œëª©ì„ ì •ë¦¬í•©ë‹ˆë‹¤.
    í•œê¸€, ì˜ë¬¸, ìˆ«ì, ê³µë°±, (-, _)ë§Œ í—ˆìš©í•˜ê³  ê¸¸ì´ë¥¼ ì œí•œí•©ë‹ˆë‹¤.
    """
    # í—ˆìš© ë¬¸ì ì™¸ ëª¨ë“  ë¬¸ì ì œê±°
    sanitized = re.sub(r'[^\w\sê°€-í£-]', '', title)
    # ê³µë°±ì„ ë°‘ì¤„ë¡œ ë³€ê²½
    sanitized = sanitized.replace(' ', '_')
    # ê¸¸ì´ ì œí•œ
    return sanitized[:max_length]

def new_conversation() -> Tuple[str, List[str]]:
    """ìƒˆ ëŒ€í™” ID(UUID)ì™€ ì´ˆê¸° íˆìŠ¤í† ë¦¬ ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤."""
    return str(uuid.uuid4()), []

def save_conversation(
    convo_id: str, 
    history: List[str], 
    title: str = "Untitled", 
    plan: List[Dict] = None, 
    current_group_index: int = 0,
    is_final: bool = False # (ìš”ì²­ì‚¬í•­ 3)
):
    """
    ëŒ€í™” ë‚´ìš©, ì‹¤í–‰ ê³„íš, ì§„í–‰ ìƒíƒœë¥¼ JSON íŒŒì¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤.
    (ìš”ì²­ì‚¬í•­ 3) is_final=True ì´ë©´ íŒŒì¼ëª…ì„ 'ì‹œê°„-ìš”ì•½.json'ìœ¼ë¡œ ë³€ê²½í•©ë‹ˆë‹¤.
    """
    
    data = {
        "id": convo_id, # ì´ˆê¸° ID (UUID)
        "title": title,
        "last_updated": datetime.now().isoformat(),
        "history": history,
        "plan": plan or [], 
        "current_group_index": current_group_index
    }

    if is_final:
        # (ìš”ì²­ì‚¬í•­ 3) ìµœì¢… ì €ì¥: ìƒˆ íŒŒì¼ëª… ìƒì„±
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        safe_title = _sanitize_title(title)
        new_filename = f"{timestamp}-{safe_title}.json"
        
        # ë°ì´í„° ë‚´ë¶€ì˜ IDë„ ìƒˆ íŒŒì¼ëª…ìœ¼ë¡œ ì—…ë°ì´íŠ¸ (listì—ì„œ ì‚¬ìš©)
        data["id"] = new_filename 
        
        filepath = os.path.join(HISTORY_DIR, new_filename)
        
        # ê¸°ì¡´ UUID ê¸°ë°˜ íŒŒì¼ ì‚­ì œ ì‹œë„
        old_filepath = os.path.join(HISTORY_DIR, f"{convo_id}.json")
        if os.path.exists(old_filepath):
            try:
                os.remove(old_filepath)
            except OSError as e:
                print(f"ê¸°ì¡´ íŒŒì¼ ì‚­ì œ ì˜¤ë¥˜ {old_filepath}: {e}")
                
    else:
        # (ìš”ì²­ì‚¬í•­ 3) ì„ì‹œ ì €ì¥: UUID ê¸°ë°˜ íŒŒì¼ëª… ì‚¬ìš©
        filepath = os.path.join(HISTORY_DIR, f"{convo_id}.json")

    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    except IOError as e:
        print(f"íŒŒì¼ ì €ì¥ ì˜¤ë¥˜ {filepath}: {e}")


def load_conversation(convo_id: str) -> Optional[Dict[str, Any]]:
    """
    íŒŒì¼ì—ì„œ ëŒ€í™” ìƒíƒœ(íˆìŠ¤í† ë¦¬, ê³„íš, ì§„í–‰ë„ í¬í•¨)ë¥¼ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤.
    (ìš”ì²­ì‚¬í•­ 3) UUID ë˜ëŠ” ìµœì¢… íŒŒì¼ëª…(YYYYMMDD...json)ìœ¼ë¡œ ë¡œë“œ ì‹œë„.
    """
    
    # 1. convo_idê°€ .jsonì„ í¬í•¨í•˜ëŠ”ì§€ í™•ì¸ (listì—ì„œ í´ë¦­í•œ ê²½ìš°)
    if not convo_id.endswith(".json"):
        filename = f"{convo_id}.json"
    else:
        filename = convo_id

    filepath = os.path.join(HISTORY_DIR, filename)
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
            return data
    except FileNotFoundError:
        # (ìš”ì²­ì‚¬í•­ 3) .jsonì„ ë¶™ì´ì§€ ì•Šì€ UUIDë¡œ ì‹œë„ (e.g. --continue <uuid>)
        if not convo_id.endswith(".json"):
            try:
                filepath_uuid = os.path.join(HISTORY_DIR, f"{convo_id}.json")
                with open(filepath_uuid, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    return data
            except FileNotFoundError:
                return None
        return None
    except json.JSONDecodeError:
        print(f"JSON íŒŒì‹± ì˜¤ë¥˜: {filepath}")
        return None

def list_conversations() -> List[Dict[str, Any]]:
    """ì €ì¥ëœ ëª¨ë“  ëŒ€í™”ì˜ ë©”íƒ€ë°ì´í„° ëª©ë¡ì„ ë°˜í™˜í•©ë‹ˆë‹¤."""
    conversations = []
    for filename in os.listdir(HISTORY_DIR):
        if filename.endswith(".json"):
            filepath = os.path.join(HISTORY_DIR, filename)
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    conversations.append({
                        # (ìš”ì²­ì‚¬í•­ 3) IDë¥¼ íŒŒì¼ëª…ìœ¼ë¡œ ë°˜í™˜ (load_conversationì„ ìœ„í•´)
                        "id": filename, 
                        "title": data.get("title", "ì œëª© ì—†ìŒ"),
                        "last_updated": data.get("last_updated", "ë‚ ì§œ ì—†ìŒ")
                    })
            except (IOError, json.JSONDecodeError):
                print(f"ëŒ€í™” ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨: {filename}")
                
    # ìµœê·¼ìˆœìœ¼ë¡œ ì •ë ¬
    conversations.sort(key=lambda x: x.get("last_updated", ""), reverse=True)
    return conversations
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# orchestrator/models.py

from pydantic import BaseModel, Field
from typing import Dict, Any, List, Literal

class AgentRequest(BaseModel):
    """CLIê°€ ì„œë²„ë¡œ ë³´ë‚´ëŠ” ìš”ì²­ ëª¨ë¸"""
    conversation_id: str
    history: List[str]
    user_input: str | None = None 
    requirement_paths: List[str] | None = None
    model_preference: str = "auto" # (ìš”ì²­ì‚¬í•­ 1)
    system_prompts: List[str] | None = None # (ìš”ì²­ì‚¬í•­ 4)
    # (ì‹ ê·œ) ìœ„í—˜ ì‘ì—…ì— ëŒ€í•œ ì‚¬ìš©ì ê²°ì • ì¶”ê°€
    user_decision: Literal["proceed", "create_mcp", "abort"] | None = None

class GeminiToolCall(BaseModel):
    """ë‹¨ì¼ ë„êµ¬ í˜¸ì¶œ(MCP)ì„ ì •ì˜í•˜ëŠ” ëª¨ë¸"""
    tool_name: str
    arguments: Dict[str, Any]
    # (ìš”ì²­ì‚¬í•­ 2) íƒœìŠ¤í¬ë³„ ëª¨ë¸ ì„ í˜¸ë„
    model_preference: str = Field(
        default="auto", 
        description="ì´ íƒœìŠ¤í¬ì— ì‚¬ìš©í•  ëª¨ë¸ (standard, high, auto)"
    )


class ExecutionGroup(BaseModel):
    """ì—¬ëŸ¬ íƒœìŠ¤í¬ë¥¼ ë¬¶ëŠ” ì‹¤í–‰ ê·¸ë£¹ ëª¨ë¸"""
    group_id: str = Field(..., description="ê·¸ë£¹ì˜ ê³ ìœ  ID (ì˜ˆ: 'group_1')")
    description: str = Field(..., description="ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì¤„ ê·¸ë£¹ì— ëŒ€í•œ ì„¤ëª…")
    tasks: List[GeminiToolCall] = Field(..., description="ì´ ê·¸ë£¹ì—ì„œ ì‹¤í–‰í•  ë„êµ¬ í˜¸ì¶œ ëª©ë¡")

class AgentResponse(BaseModel):
    """ì„œë²„ê°€ CLIë¡œ ë³´ë‚´ëŠ” ì‘ë‹µ ëª¨ë¸"""
    conversation_id: str
    # (ìˆ˜ì •) status ë¦¬í„°ëŸ´ í™•ì¥
    status: Literal[
        "PLAN_CONFIRMATION", 
        "DANGEROUS_TASK_CONFIRMATION", # (ì‹ ê·œ) ìœ„í—˜ ì‘ì—… í™•ì¸
        "EXECUTION_ERROR",             # (ì‹ ê·œ) ì‹¤í–‰ ì˜¤ë¥˜
        "FINAL_ANSWER", 
        "ERROR"                        # (ìœ ì§€) ê³„íš ìˆ˜ë¦½ ë“± ì¹˜ëª…ì  ì˜¤ë¥˜
    ]
    history: List[str]
    message: str 
    execution_group: ExecutionGroup | None = None # ë‹¤ìŒ 1ê°œ ê·¸ë£¹ í™•ì¸ìš©
    plan: List[ExecutionGroup] | None = None # (ìš”ì²­ì‚¬í•­ 2) ì „ì²´ ê³„íš í™•ì¸ìš©
    # (ì‹ ê·œ) ìœ„í—˜ ì‘ì—… ì›ë³¸ ì½”ë“œë¥¼ CLIë¡œ ì „ë‹¬
    dangerous_task_details: Dict[str, Any] | None = None
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# orchestrator/tool_registry.py

import os
import importlib
import inspect
from typing import Dict, Any, Callable

MCP_DIRECTORY = "mcp_modules"
TOOLS: Dict[str, Callable] = {}
TOOL_DESCRIPTIONS: Dict[str, str] = {}

def load_tools():
    """mcp_modules ë””ë ‰í† ë¦¬ì—ì„œ ëª¨ë“  MCPë¥¼ ë™ì ìœ¼ë¡œ ë¡œë“œí•©ë‹ˆë‹¤."""
    # (ìˆ˜ì •) ë””ë ‰í† ë¦¬ê°€ ì—†ì„ ê²½ìš° ìƒì„±
    if not os.path.exists(MCP_DIRECTORY):
        os.makedirs(MCP_DIRECTORY)
        print(f"ê²½ê³ : '{MCP_DIRECTORY}' ë””ë ‰í† ë¦¬ê°€ ì—†ì–´ ìƒì„±í–ˆìŠµë‹ˆë‹¤. ë„êµ¬ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        return

    for filename in os.listdir(MCP_DIRECTORY):
        if filename.endswith(".py") and not filename.startswith("__"):
            module_name = f"{MCP_DIRECTORY}.{filename[:-3]}"
            try:
                module = importlib.import_module(module_name)
                for name, func in inspect.getmembers(module, inspect.isfunction):
                    if not name.startswith("_"):
                        TOOLS[name] = func
                        description = func.__doc__.strip() if func.__doc__ else name 
                        TOOL_DESCRIPTIONS[name] = description 
                        print(f"Tool loaded: {name}")
            except ImportError as e:
                print(f"ëª¨ë“ˆ ë¡œë“œ ì‹¤íŒ¨: {module_name} ({e})")


def get_tool(name: str) -> Callable:
    """ì´ë¦„ìœ¼ë¡œ MCP í•¨ìˆ˜ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤."""
    return TOOLS.get(name)

def get_all_tool_descriptions() -> str:
    """Gemini í”„ë¡¬í”„íŠ¸ì— ì‚¬ìš©í•  ëª¨ë“  MCPì˜ ì„¤ëª… ë¬¸ìì—´ì„ ìƒì„±í•©ë‹ˆë‹¤."""
    return "\n".join(
        f"- {name}: {desc}" for name, desc in TOOL_DESCRIPTIONS.items()
    )

# ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì‹œ í•œ ë²ˆë§Œ ë¡œë“œ (api.pyì˜ @app.on_event("startup")ë¡œ ì´ë™ë¨)
# load_tools()
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
MCP ëª¨ë“ˆ íŒ¨í‚¤ì§€ì˜ ë©”ì¸ __init__ íŒŒì¼.
ëª¨ë“  í•˜ìœ„ MCP ëª¨ë“ˆì˜ í•µì‹¬ í•¨ìˆ˜ë“¤ì„ ì„í¬íŠ¸í•©ë‹ˆë‹¤.
"""

import logging

logger = logging.getLogger(__name__)

def _safe_import(module_name, elements):
    """ëª¨ë“ˆ ì„í¬íŠ¸ ì‹¤íŒ¨ ì‹œ ê²½ê³ ë§Œ í•˜ê³  ë„˜ì–´ê°€ê¸° ìœ„í•œ í—¬í¼ í•¨ìˆ˜"""
    try:
        module = __import__(module_name, globals(), locals(), elements, 1)
        for element in elements:
            globals()[element] = getattr(module, element)
    except ImportError as e:
        logger.warning(f"ëª¨ë“ˆ ë¡œë“œ ì‹¤íŒ¨: {module_name} ({e})")

from .file_content_operations import read_file, read_binary_file, write_file, write_binary_file, append_to_file

from .file_management import create_directory, list_directory, rename, delete_file, delete_empty_directory

from .file_system_composite import move, copy_directory, find_files, find_text_in_files, find_large_files, read_specific_lines, replace_text_in_file, get_directory_size, batch_rename, delete_directory_recursively, read_multiple_files

from .user_interaction_atomic import ask_user_for_input, ask_for_multiline_input, ask_user_for_confirmation, ask_for_password, show_message, display_table, show_progress_bar, clear_screen, show_alert, render_markdown, show_spinner, update_last_line

from .user_interaction_composite import present_options_and_get_choice, present_checkbox_and_get_choices, ask_for_file_path, ask_for_directory_path, confirm_critical_action, get_form_input, ask_for_validated_input, select_file_from_directory, show_diff, prompt_with_autocomplete

from .code_execution_atomic import execute_shell_command, execute_python_code, read_code_file, get_environment_variable, set_environment_variable, execute_sql_query, check_port_status, get_code_complexity, get_function_signature, list_installed_packages, docker_list_containers, docker_list_images

from .code_execution_composite import run_python_script, install_python_package, uninstall_python_package, lint_code_file, format_code_file, get_git_status, clone_git_repository, setup_python_venv, build_docker_image, run_container_from_image, get_container_logs

from .web_network_atomic import fetch_url_content, download_file_from_url, api_get_request, api_post_request, api_put_request, api_delete_request, get_http_status, ping_host, resolve_dns, parse_rss_feed, send_email_smtp, get_http_headers, get_ssl_certificate_info, fetch_dynamic_content, ftp_upload_file, ftp_download_file

# AIê°€ Git ë„êµ¬ë¥¼ ì¸ì‹í•˜ê³  ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ __init__.pyì— ì¶”ê°€í•©ë‹ˆë‹¤.
from .git_version_control import (
    git_init, git_clone, git_status, git_add, git_commit, git_push, git_pull, 
    git_fetch, git_create_branch, git_switch_branch, git_list_branches, 
    git_merge, git_log, git_diff, git_add_remote, git_create_tag, 
    git_list_tags, git_revert_commit, git_show_commit_details, 
    git_get_current_branch, git_list_all_files
)

from .gemini_atomic import ask_gemini

_safe_import("project_workflows", [
    "initialize_project_repository",
    "start_new_feature_branch",
    "commit_and_push_changes",
    "analyze_and_lint_project",
    "revert_last_ai_commit",
    "load_and_analyze_project_code",
    "switch_to_main_and_pull",
    "publish_new_version_tag",
    "run_project_tests",
    "request_ai_code_review",
    "clean_up_merged_branches"
])
# --- ì˜¤ë¥˜ ë¡œê·¸ì— ë‚˜íƒ€ë‚œ ì¶”ê°€ ëª¨ë“ˆ (ì•ˆì „í•˜ê²Œ ì„í¬íŠ¸) ---
_safe_import("file_attributes", [])
_safe_import("mcp_custom_tool", [])
_safe_import("create_code_bundle", [])

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
code_execution_atomic.py: AI ì—ì´ì „íŠ¸ë¥¼ ìœ„í•œ ë ˆë²¨ 1 ì›ì(Atomic) MCP í•µì‹¬ ë¼ì´ë¸ŒëŸ¬ë¦¬

ì´ ëª¨ë“ˆì€ AI ì—ì´ì „íŠ¸ê°€ ìš´ì˜ì²´ì œ, íŒŒì¼ ì‹œìŠ¤í…œ, ì½”ë“œ ë¶„ì„ ë“± ê¸°ë³¸ì ì¸ ì‘ì—…ì„
ìˆ˜í–‰í•  ìˆ˜ ìˆë„ë¡ ë•ëŠ” ì €ìˆ˜ì¤€(low-level)ì˜ ì›ìì  ê¸°ëŠ¥ë“¤ì„ ì œê³µí•©ë‹ˆë‹¤.
ê° í•¨ìˆ˜ëŠ” í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ ì‚¬ìš©ë  ê²ƒì„ ê°€ì •í•˜ì—¬ ë³´ì•ˆ, ë¡œê¹…, ì˜ˆì™¸ ì²˜ë¦¬ë¥¼
ì¤‘ì ì ìœ¼ë¡œ ê³ ë ¤í•˜ì—¬ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.
"""

import logging
import os
import shlex
import socket
import subprocess
import sys
import ast
import json
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

# --- ë¡œê¹… ì„¤ì • ---
# ë‹¤ë¥¸ ì‹œìŠ¤í…œê³¼ í†µí•©ì„ ìœ„í•´, ë¼ì´ë¸ŒëŸ¬ë¦¬ ì½”ë“œì—ì„œëŠ” ë¡œê±°ë¥¼ ì§ì ‘ ì„¤ì •í•˜ê¸°ë³´ë‹¤
# í˜¸ì¶œí•˜ëŠ” ìª½ì—ì„œ ì„¤ì •í•˜ë„ë¡ í•˜ëŠ” ê²ƒì´ ê°€ì¥ ì¢‹ìŠµë‹ˆë‹¤.
# ì—¬ê¸°ì„œëŠ” ì˜ˆì‹œë¥¼ ìœ„í•´ ê¸°ë³¸ ë¡œê±°ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    stream=sys.stdout
)
logger = logging.getLogger(__name__)

# --- ë³´ì•ˆ ê´€ë ¨ ì„¤ì • ---
# ì‹¤ì œ ìš´ì˜ í™˜ê²½ì—ì„œëŠ” í—ˆìš©/ì°¨ë‹¨ ëª©ë¡ì„ ì™¸ë¶€ ì„¤ì • íŒŒì¼ì´ë‚˜ í™˜ê²½ ë³€ìˆ˜ì—ì„œ ê´€ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤.
FORBIDDEN_COMMANDS = {'rm', 'mv', 'dd', 'mkfs'} # ë§¤ìš° ìœ„í—˜í•œ ëª…ë ¹ì–´ ì˜ˆì‹œ ì§‘í•©
ALLOWED_BASE_PATH = Path(os.getcwd()).resolve() # íŒŒì¼ ì ‘ê·¼ì„ í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬ë¡œ ì œí•œ

def execute_shell_command(command: str, timeout: int = 10) -> str:
    """ì•ˆì „í•˜ê²Œ ì…¸ ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•˜ê³  ê²°ê³¼ë¥¼ ë¬¸ìì—´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

    ë³´ì•ˆì„ ìœ„í•´ ëª…ë ¹ì–´ì™€ ì¸ìë¥¼ ë¶„ë¦¬í•˜ê³ , ì‹¤í–‰ ì‹œê°„ì„ ì œí•œí•˜ë©°, ìœ„í—˜í•œ ëª…ë ¹ì–´ ì‹¤í–‰ì„ ì°¨ë‹¨í•©ë‹ˆë‹¤.
    ì…¸ ì£¼ì…(Shell Injection) ê³µê²©ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ `shlex.split`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

    Args:
        command (str): ì‹¤í–‰í•  ì…¸ ëª…ë ¹ì–´ ë¬¸ìì—´. (ì˜ˆ: "ls -l /tmp")
        timeout (int, optional): ëª…ë ¹ì–´ ì‹¤í–‰ ìµœëŒ€ ëŒ€ê¸° ì‹œê°„(ì´ˆ). ê¸°ë³¸ê°’ì€ 10.

    Returns:
        str: ëª…ë ¹ì–´ ì‹¤í–‰ ì„±ê³µ ì‹œ stdout ì¶œë ¥ ê²°ê³¼. ì‹¤íŒ¨ ì‹œ stderr ë‚´ìš©ì„ í¬í•¨í•œ ì˜¤ë¥˜ ë©”ì‹œì§€.

    Raises:
        ValueError: ì‹¤í–‰ì´ ê¸ˆì§€ëœ ìœ„í—˜í•œ ëª…ë ¹ì–´ê°€ í¬í•¨ëœ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
        TimeoutError: ì§€ì •ëœ ì‹œê°„ ë‚´ì— ëª…ë ¹ì–´ê°€ ì™„ë£Œë˜ì§€ ì•Šì€ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> result = execute_shell_command("echo 'hello world'")
        >>> print(result)
        hello world
    """
    logger.info(f"ì…¸ ëª…ë ¹ì–´ ì‹¤í–‰ ì‹œë„: {command}")
    try:
        # ì…¸ ì£¼ì… ê³µê²© ë°©ì§€ë¥¼ ìœ„í•´ ëª…ë ¹ì–´ë¥¼ ì•ˆì „í•˜ê²Œ ë¶„ë¦¬
        args = shlex.split(command)
        
        # ë³´ì•ˆ ê²€ì‚¬: ê¸ˆì§€ëœ ëª…ë ¹ì–´ ì‹¤í–‰ ì°¨ë‹¨
        if args and args[0] in FORBIDDEN_COMMANDS:
            logger.error(f"ê¸ˆì§€ëœ ëª…ë ¹ì–´ ì‹¤í–‰ ì‹œë„ ì°¨ë‹¨: {args[0]}")
            raise ValueError(f"ë³´ì•ˆ ì˜¤ë¥˜: '{args[0]}' ëª…ë ¹ì–´ëŠ” ì‹¤í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

        # ìì‹ í”„ë¡œì„¸ìŠ¤ë¡œ ëª…ë ¹ì–´ ì‹¤í–‰
        process = subprocess.run(
            args,
            capture_output=True,
            text=True,
            check=False, # ì˜¤ë¥˜ ë°œìƒ ì‹œ ì˜ˆì™¸ë¥¼ ìë™ìœ¼ë¡œ ë°œìƒì‹œí‚¤ì§€ ì•ŠìŒ (ìˆ˜ë™ ì²˜ë¦¬)
            timeout=timeout
        )

        if process.returncode == 0:
            logger.info(f"ëª…ë ¹ì–´ ì‹¤í–‰ ì„±ê³µ: {command}")
            return process.stdout.strip()
        else:
            logger.error(f"ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨: {command}, ì˜¤ë¥˜: {process.stderr.strip()}")
            return f"ì˜¤ë¥˜ ë°œìƒ: {process.stderr.strip()}"

    except FileNotFoundError:
        logger.error(f"ëª…ë ¹ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: {command.split()[0]}")
        return f"ì˜¤ë¥˜ ë°œìƒ: '{command.split()[0]}' ëª…ë ¹ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
    except subprocess.TimeoutExpired:
        logger.error(f"ëª…ë ¹ì–´ ì‹¤í–‰ ì‹œê°„ ì´ˆê³¼: {command}")
        raise TimeoutError(f"'{command}' ëª…ë ¹ì–´ê°€ {timeout}ì´ˆ ë‚´ì— ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
    except ValueError as e: # ëª…ì‹œì ìœ¼ë¡œ ValueErrorë¥¼ ì¡ì•„ì„œ ë‹¤ì‹œ raise í•©ë‹ˆë‹¤.
        logger.error(f"ë³´ì•ˆ ì˜¤ë¥˜ ë°œìƒ: {e}")
        raise e # ì¡ì€ ì˜ˆì™¸ë¥¼ ê·¸ëŒ€ë¡œ ë‹¤ì‹œ ë°œìƒì‹œí‚´
    except Exception as e:
        logger.exception(f"ì…¸ ëª…ë ¹ì–´ ì‹¤í–‰ ì¤‘ ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜ ë°œìƒ: {command}")
        return f"ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜: {e}"

def execute_python_code(code_str: str, sandboxed: bool = False) -> Any:
    """íŒŒì´ì¬ ì½”ë“œ ë¬¸ìì—´ì„ ì‹¤í–‰í•˜ê³  ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. (ë§¤ìš° ìœ„í—˜)

    ì´ í•¨ìˆ˜ëŠ” `exec`ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ ê·¹ë„ì˜ ì£¼ì˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.
    ë°˜ë“œì‹œ ê²©ë¦¬ëœ ìƒŒë“œë°•ìŠ¤ í™˜ê²½(ì˜ˆ: Docker ì»¨í…Œì´ë„ˆ)ì—ì„œë§Œ í˜¸ì¶œë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
    ì•ˆì „ì¥ì¹˜ë¡œ `sandboxed` ì¸ìë¥¼ Trueë¡œ ëª…ì‹œí•´ì•¼ë§Œ ì‹¤í–‰ë©ë‹ˆë‹¤.

    Args:
        code_str (str): ì‹¤í–‰í•  íŒŒì´ì¬ ì½”ë“œ.
        sandboxed (bool, optional): ì½”ë“œê°€ ìƒŒë“œë°•ìŠ¤ í™˜ê²½ì—ì„œ ì‹¤í–‰ë˜ëŠ”ì§€ ì—¬ë¶€.
            ì´ ê°’ì´ Trueê°€ ì•„ë‹ˆë©´ ë³´ì•ˆì„ ìœ„í•´ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê¸°ë³¸ê°’ì€ False.

    Returns:
        Any: ì½”ë“œ ì‹¤í–‰ ê²°ê³¼. `result` ë³€ìˆ˜ì— í• ë‹¹ëœ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
             ê²°ê³¼ê°€ ì—†ìœ¼ë©´ Noneì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        PermissionError: `sandboxed` ì¸ìê°€ Trueë¡œ ì„¤ì •ë˜ì§€ ì•Šì€ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
        Exception: ì½”ë“œ ì‹¤í–‰ ì¤‘ ë°œìƒí•˜ëŠ” ëª¨ë“  ì˜ˆì™¸.

    Example:
        >>> code = "result = 1 + 1"
        >>> execute_python_code(code, sandboxed=True)
        2
    """
    logger.warning(f"íŒŒì´ì¬ ì½”ë“œ ì‹¤í–‰ ì‹œë„ (ìƒŒë“œë°•ìŠ¤: {sandboxed}): {code_str[:50]}...")
    if not sandboxed:
        logger.critical("ë³´ì•ˆ ìœ„í—˜: ìƒŒë“œë°•ìŠ¤ í™˜ê²½ì´ ì•„ë‹Œ ê³³ì—ì„œ ì½”ë“œ ì‹¤í–‰ ì‹œë„ê°€ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.")
        raise PermissionError("ë³´ì•ˆ ì˜¤ë¥˜: ì´ ê¸°ëŠ¥ì€ ë°˜ë“œì‹œ ìƒŒë“œë°•ìŠ¤ í™˜ê²½ì—ì„œë§Œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.")

    try:
        # ì‹¤í–‰ ê²°ê³¼ë¥¼ ë‹´ì„ ë¡œì»¬ ë„¤ì„ìŠ¤í˜ì´ìŠ¤
        local_scope = {}
        exec(code_str, {}, local_scope)
        result = local_scope.get('result', None)
        logger.info("íŒŒì´ì¬ ì½”ë“œ ì‹¤í–‰ ì„±ê³µ.")
        return result
    except Exception as e:
        logger.exception("íŒŒì´ì¬ ì½”ë“œ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ.")
        raise e

def read_code_file(path: str) -> str:
    """ì§€ì •ëœ ê²½ë¡œì˜ ì½”ë“œ íŒŒì¼ ë‚´ìš©ì„ ì•ˆì „í•˜ê²Œ ì½ì–´ ë¬¸ìì—´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

    ê²½ë¡œ ì¡°ì‘(Path Traversal) ê³µê²©ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ íŒŒì¼ ê²½ë¡œë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.

    Args:
        path (str): ì½ì„ íŒŒì¼ì˜ ê²½ë¡œ.

    Returns:
        str: íŒŒì¼ì˜ ì „ì²´ ë‚´ìš©.

    Raises:
        ValueError: íŒŒì¼ ê²½ë¡œê°€ ìœ íš¨í•˜ì§€ ì•Šê±°ë‚˜ í—ˆìš©ëœ ê²½ë¡œë¥¼ ë²—ì–´ë‚˜ëŠ” ê²½ìš°.
        FileNotFoundError: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°.
        PermissionError: íŒŒì¼ì— ëŒ€í•œ ì½ê¸° ê¶Œí•œì´ ì—†ëŠ” ê²½ìš°.
    """
    logger.info(f"íŒŒì¼ ì½ê¸° ì‹œë„: {path}")
    try:
        # ê²½ë¡œ ì¡°ì‘ ê³µê²© ë°©ì§€
        file_path = Path(path).resolve()
        if not file_path.is_relative_to(ALLOWED_BASE_PATH):
            logger.error(f"í—ˆìš©ë˜ì§€ ì•Šì€ ê²½ë¡œ ì ‘ê·¼ ì‹œë„: {path}")
            raise ValueError("ë³´ì•ˆ ì˜¤ë¥˜: í—ˆìš©ëœ ë””ë ‰í† ë¦¬ ì™¸ë¶€ì˜ íŒŒì¼ì—ëŠ” ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        
        if not file_path.is_file():
            raise FileNotFoundError(f"íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {path}")

        return file_path.read_text(encoding='utf-8')
    
    except (FileNotFoundError, PermissionError, ValueError) as e:
        logger.error(f"íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: {path}, ì´ìœ : {e}")
        raise e
    except Exception as e:
        logger.exception(f"íŒŒì¼ ì½ê¸° ì¤‘ ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜ ë°œìƒ: {path}")
        raise IOError(f"íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")

def get_environment_variable(var_name: str) -> Optional[str]:
    """íŠ¹ì • í™˜ê²½ ë³€ìˆ˜ì˜ ê°’ì„ ì¡°íšŒí•©ë‹ˆë‹¤.

    Args:
        var_name (str): ì¡°íšŒí•  í™˜ê²½ ë³€ìˆ˜ì˜ ì´ë¦„.

    Returns:
        Optional[str]: í™˜ê²½ ë³€ìˆ˜ì˜ ê°’. ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ Noneì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Example:
        >>> # 'PATH' í™˜ê²½ ë³€ìˆ˜ê°€ ìˆë‹¤ê³  ê°€ì •
        >>> get_environment_variable('PATH') is not None
        True
        >>> get_environment_variable('NON_EXISTENT_VAR_12345') is None
        True
    """
    logger.info(f"í™˜ê²½ ë³€ìˆ˜ ì¡°íšŒ: {var_name}")
    return os.getenv(var_name)

def set_environment_variable(var_name: str, value: str) -> bool:
    """íŠ¹ì • í™˜ê²½ ë³€ìˆ˜ì˜ ê°’ì„ ì„¤ì •í•˜ê±°ë‚˜ ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤.

    Args:
        var_name (str): ì„¤ì •í•  í™˜ê²½ ë³€ìˆ˜ì˜ ì´ë¦„.
        value (str): í• ë‹¹í•  ê°’.

    Returns:
        bool: ì„¤ì • ì„±ê³µ ì‹œ True.
    
    Raises:
        ValueError: ë³€ìˆ˜ ì´ë¦„ì´ë‚˜ ê°’ì´ ìœ íš¨í•˜ì§€ ì•Šì„ ê²½ìš°.
    """
    logger.info(f"í™˜ê²½ ë³€ìˆ˜ ì„¤ì •: {var_name}")
    if not var_name or not isinstance(var_name, str):
        raise ValueError("í™˜ê²½ ë³€ìˆ˜ ì´ë¦„ì€ ë¹ˆ ë¬¸ìì—´ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    try:
        os.environ[var_name] = str(value)
        return True
    except Exception as e:
        logger.error(f"í™˜ê²½ ë³€ìˆ˜ ì„¤ì • ì‹¤íŒ¨: {var_name}, ì˜¤ë¥˜: {e}")
        return False

# execute_sql_queryëŠ” ì‹¤ì œ êµ¬í˜„ ì‹œ SQLAlchemyì™€ ê°™ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©ì„ ê¶Œì¥í•©ë‹ˆë‹¤.
# ì—¬ê¸°ì„œëŠ” ê°œë…ì„ ë³´ì—¬ì£¼ê¸° ìœ„í•œ ì˜ì‚¬(pseudo) ì½”ë“œì…ë‹ˆë‹¤.
def execute_sql_query(db_uri: str, query: str, params: Optional[Dict] = None) -> List[Dict]:
    """ì§€ì •ëœ ë°ì´í„°ë² ì´ìŠ¤ì— ì ‘ì†í•˜ì—¬ SQL ì¿¼ë¦¬ë¥¼ ì•ˆì „í•˜ê²Œ ì‹¤í–‰í•˜ê³  ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    SQL ì£¼ì…(SQL Injection) ê³µê²©ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ë°˜ë“œì‹œ íŒŒë¼ë¯¸í„°í™”ëœ ì¿¼ë¦¬ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.
    ì´ í•¨ìˆ˜ëŠ” ê°œë… ì¦ëª…ì„ ìœ„í•œ ê²ƒì´ë©°, ì‹¤ì œ í”„ë¡œë•ì…˜ì—ì„œëŠ” SQLAlchemy ì‚¬ìš©ì„ ê¶Œì¥í•©ë‹ˆë‹¤.

    Args:
        db_uri (str): ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì •ë³´ (ì˜ˆ: "postgresql://user:pass@host/dbname").
        query (str): ì‹¤í–‰í•  SQL ì¿¼ë¦¬ë¬¸. ë°”ì¸ë”© ë³€ìˆ˜ëŠ” `:key` í˜•íƒœë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.
        params (Optional[Dict]): ì¿¼ë¦¬ì— ë°”ì¸ë”©í•  íŒŒë¼ë¯¸í„° ë”•ì…”ë„ˆë¦¬.

    Returns:
        List[Dict]: ì¿¼ë¦¬ ê²°ê³¼. ê° í–‰ì€ ë”•ì…”ë„ˆë¦¬ë¡œ í‘œí˜„ë©ë‹ˆë‹¤.

    Raises:
        ImportError: `sqlalchemy` ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì€ ê²½ìš°.
        Exception: ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ë˜ëŠ” ì¿¼ë¦¬ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ ì‹œ.

    Example:
        >>> # ì•„ë˜ëŠ” sqlalchemyê°€ ì„¤ì¹˜ë˜ì–´ ìˆê³  DBê°€ ì‹¤í–‰ì¤‘ì¼ ë•Œ ë™ì‘í•©ë‹ˆë‹¤.
        >>> # db_uri = "sqlite:///:memory:"
        >>> # query = "SELECT :p1 as col1, :p2 as col2;"
        >>> # params = {"p1": 1, "p2": "test"}
        >>> # result = execute_sql_query(db_uri, query, params)
        >>> # print(result)
        >>> # [{'col1': 1, 'col2': 'test'}]
    """
    logger.info(f"SQL ì¿¼ë¦¬ ì‹¤í–‰ ì‹œë„: {query[:50]}...")
    try:
        from sqlalchemy import create_engine, text
    except ImportError:
        logger.critical("SQLAlchemy ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ í•„ìš”í•©ë‹ˆë‹¤. 'pip install sqlalchemy'ë¡œ ì„¤ì¹˜í•´ì£¼ì„¸ìš”.")
        raise ImportError("SQLAlchemy is not installed.")

    try:
        engine = create_engine(db_uri)
        with engine.connect() as connection:
            # SQL Injection ë°©ì§€ë¥¼ ìœ„í•´ text()ì™€ íŒŒë¼ë¯¸í„° ë°”ì¸ë”© ì‚¬ìš©
            stmt = text(query)
            result = connection.execute(stmt, params or {})
            
            # ê²°ê³¼ë¥¼ dict ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜
            result_dicts = [row._asdict() for row in result]
            logger.info("SQL ì¿¼ë¦¬ ì‹¤í–‰ ì„±ê³µ.")
            return result_dicts
    except Exception as e:
        logger.exception("SQL ì¿¼ë¦¬ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ.")
        raise e

def check_port_status(host: str, port: int, timeout: int = 3) -> Tuple[bool, str]:
    """íŠ¹ì • í˜¸ìŠ¤íŠ¸ì˜ í¬íŠ¸ê°€ ì—´ë ¤ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.

    Args:
        host (str): ëŒ€ìƒ í˜¸ìŠ¤íŠ¸ì˜ ì£¼ì†Œ (ì˜ˆ: "google.com", "127.0.0.1").
        port (int): í™•ì¸í•  í¬íŠ¸ ë²ˆí˜¸.
        timeout (int, optional): ì—°ê²° ì‹œë„ ëŒ€ê¸° ì‹œê°„(ì´ˆ). ê¸°ë³¸ê°’ì€ 3.

    Returns:
        Tuple[bool, str]: (í¬íŠ¸ ì—´ë¦¼ ì—¬ë¶€, ìƒíƒœ ë©”ì‹œì§€) íŠœí”Œ.
    """
    logger.info(f"í¬íŠ¸ ìƒíƒœ í™•ì¸ ì‹œë„: {host}:{port}")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    try:
        result = sock.connect_ex((host, port))
        if result == 0:
            status_message = f"ì„±ê³µ: {host}:{port} í¬íŠ¸ê°€ ì—´ë ¤ ìˆìŠµë‹ˆë‹¤."
            logger.info(status_message)
            return True, status_message
        else:
            status_message = f"ì‹¤íŒ¨: {host}:{port} í¬íŠ¸ê°€ ë‹«í˜€ ìˆê±°ë‚˜ ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
            logger.warning(status_message)
            return False, status_message
    except socket.gaierror:
        error_message = f"ì˜¤ë¥˜: í˜¸ìŠ¤íŠ¸ ì´ë¦„ì„ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {host}"
        logger.error(error_message)
        return False, error_message
    except Exception as e:
        error_message = f"ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜ ë°œìƒ: {e}"
        logger.exception(error_message)
        return False, error_message
    finally:
        sock.close()

def get_code_complexity(file_path: str) -> Dict[str, Any]:
    """ì½”ë“œ íŒŒì¼ì˜ ìˆœí™˜ ë³µì¡ë„(Cyclomatic Complexity)ë¥¼ ì¸¡ì •í•©ë‹ˆë‹¤.

    `radon` ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ì½”ë“œì˜ ìœ ì§€ë³´ìˆ˜ì„±ì„ í‰ê°€í•©ë‹ˆë‹¤.

    Args:
        file_path (str): ë¶„ì„í•  íŒŒì´ì¬ íŒŒì¼ì˜ ê²½ë¡œ.

    Returns:
        Dict[str, Any]: íŒŒì¼ì˜ ë³µì¡ë„ ë¶„ì„ ê²°ê³¼ ë”•ì…”ë„ˆë¦¬.

    Raises:
        FileNotFoundError: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°.
        ValueError: radon ì‹¤í–‰ ì‹¤íŒ¨ ë˜ëŠ” ê²°ê³¼ íŒŒì‹± ì‹¤íŒ¨ ì‹œ.
    """
    logger.info(f"ì½”ë“œ ë³µì¡ë„ ë¶„ì„ ì‹œë„: {file_path}")
    if not Path(file_path).is_file():
        raise FileNotFoundError(f"íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {file_path}")
    
    try:
        # radonì„ JSON ì¶œë ¥ ëª¨ë“œë¡œ ì‹¤í–‰í•˜ì—¬ ì•ˆì •ì ìœ¼ë¡œ ê²°ê³¼ íŒŒì‹±
        command = f"radon cc -s -j {file_path}"
        result_json = execute_shell_command(command)
        
        if "ì˜¤ë¥˜ ë°œìƒ" in result_json:
            raise ValueError(f"radon ì‹¤í–‰ ì‹¤íŒ¨: {result_json}")
        
        complexity_data = json.loads(result_json)
        logger.info(f"ì½”ë“œ ë³µì¡ë„ ë¶„ì„ ì„±ê³µ: {file_path}")
        return complexity_data.get(file_path, {})
        
    except (json.JSONDecodeError, ValueError) as e:
        logger.error(f"ì½”ë“œ ë³µì¡ë„ ë¶„ì„ ê²°ê³¼ íŒŒì‹± ì‹¤íŒ¨: {e}")
        raise ValueError(f"radon ê²°ê³¼ íŒŒì‹± ì‹¤íŒ¨: {e}")
    except Exception as e:
        logger.exception(f"ì½”ë“œ ë³µì¡ë„ ë¶„ì„ ì¤‘ ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜ ë°œìƒ: {file_path}")
        raise e

def get_function_signature(file_path: str, function_name: str) -> Optional[str]:
    """íŒŒì´ì¬ íŒŒì¼ ë‚´ì—ì„œ íŠ¹ì • í•¨ìˆ˜ì˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.

    `ast` ëª¨ë“ˆì„ ì‚¬ìš©í•˜ì—¬ ì½”ë“œë¥¼ ì •ì ìœ¼ë¡œ ë¶„ì„í•˜ë¯€ë¡œ ì½”ë“œë¥¼ ì§ì ‘ ì‹¤í–‰í•˜ì§€ ì•Šì•„ ì•ˆì „í•©ë‹ˆë‹¤.

    Args:
        file_path (str): ë¶„ì„í•  íŒŒì´ì¬ íŒŒì¼ì˜ ê²½ë¡œ.
        function_name (str): ì‹œê·¸ë‹ˆì²˜ë¥¼ ì¶”ì¶œí•  í•¨ìˆ˜ì˜ ì´ë¦„.

    Returns:
        Optional[str]: ì°¾ì€ í•¨ìˆ˜ì˜ ì „ì²´ ì‹œê·¸ë‹ˆì²˜ ë¬¸ìì—´. í•¨ìˆ˜ë¥¼ ì°¾ì§€ ëª»í•˜ë©´ None.

    Raises:
        FileNotFoundError: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°.
    """
    logger.info(f"í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ ì¶”ì¶œ ì‹œë„: {file_path}ì˜ {function_name}")
    try:
        code = read_code_file(file_path)
        tree = ast.parse(code)

        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)) and node.name == function_name:
                # astunparseì™€ ê°™ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ë©´ ë” ì •í™•í•˜ì§€ë§Œ,
                # í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë§Œìœ¼ë¡œ êµ¬í˜„í•˜ê¸° ìœ„í•´ ì†ŒìŠ¤ ì½”ë“œì—ì„œ ì§ì ‘ ì¶”ì¶œ
                lines = code.splitlines()
                # ë°ì½”ë ˆì´í„°ë¥¼ í¬í•¨í•œ ì‹œì‘ì ë¶€í„° ì‹œê·¸ë‹ˆì²˜ ëê¹Œì§€ ì¶”ì¶œ
                start_lineno = node.decorator_list[0].lineno if node.decorator_list else node.lineno
                end_lineno = node.body[0].lineno - 1
                
                signature_lines = lines[start_lineno-1:end_lineno]
                signature = ' '.join(line.strip() for line in signature_lines)
                logger.info(f"í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ ì¶”ì¶œ ì„±ê³µ: {function_name}")
                return signature
        
        logger.warning(f"í•¨ìˆ˜ë¥¼ ì°¾ì§€ ëª»í•¨: {function_name}")
        return None
    except FileNotFoundError:
        raise
    except Exception as e:
        logger.exception("í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ ì¶”ì¶œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ.")
        return None

def list_installed_packages() -> List[Tuple[str, str]]:
    """í˜„ì¬ íŒŒì´ì¬ í™˜ê²½ì— ì„¤ì¹˜ëœ íŒ¨í‚¤ì§€ì™€ ë²„ì „ì„ ëª©ë¡ìœ¼ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

    `pip` ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•˜ëŠ” ëŒ€ì‹  `importlib.metadata`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë” ì•ˆì •ì ì…ë‹ˆë‹¤.

    Returns:
        List[Tuple[str, str]]: (íŒ¨í‚¤ì§€ ì´ë¦„, ë²„ì „) íŠœí”Œì˜ ë¦¬ìŠ¤íŠ¸.
    """
    logger.info("ì„¤ì¹˜ëœ íŒ¨í‚¤ì§€ ëª©ë¡ ì¡°íšŒ ì‹œë„.")
    try:
        from importlib import metadata
        packages = [(dist.metadata['name'], dist.version) for dist in metadata.distributions()]
        logger.info(f"{len(packages)}ê°œì˜ ì„¤ì¹˜ëœ íŒ¨í‚¤ì§€ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤.")
        return sorted(packages, key=lambda x: x[0].lower())
    except Exception as e:
        logger.exception("ì„¤ì¹˜ëœ íŒ¨í‚¤ì§€ ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ.")
        return []

def docker_list_containers() -> List[Dict]:
    """ì‹¤í–‰ ì¤‘ì´ê±°ë‚˜ ì •ì§€ëœ ëª¨ë“  ë„ì»¤ ì»¨í…Œì´ë„ˆ ëª©ë¡ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Returns:
        List[Dict]: ê° ì»¨í…Œì´ë„ˆì˜ ì •ë³´ë¥¼ ë‹´ì€ ë”•ì…”ë„ˆë¦¬ ë¦¬ìŠ¤íŠ¸.
    
    Raises:
        ValueError: `docker` ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨ ì‹œ.
    """
    logger.info("ë„ì»¤ ì»¨í…Œì´ë„ˆ ëª©ë¡ ì¡°íšŒ ì‹œë„.")
    command = "docker ps -a --format '{{json .}}'"
    try:
        result = execute_shell_command(command)
        if not result:
            return []
        
        containers = [json.loads(line) for line in result.strip().split('\n')]
        logger.info(f"{len(containers)}ê°œì˜ ë„ì»¤ ì»¨í…Œì´ë„ˆë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤.")
        return containers
    except Exception as e:
        logger.error(f"ë„ì»¤ ì»¨í…Œì´ë„ˆ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise ValueError("ë„ì»¤ ì»¨í…Œì´ë„ˆ ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë„ì»¤ê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•˜ì„¸ìš”.")

def docker_list_images() -> List[Dict]:
    """ë¡œì»¬ì— ì €ì¥ëœ ëª¨ë“  ë„ì»¤ ì´ë¯¸ì§€ ëª©ë¡ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Returns:
        List[Dict]: ê° ì´ë¯¸ì§€ì˜ ì •ë³´ë¥¼ ë‹´ì€ ë”•ì…”ë„ˆë¦¬ ë¦¬ìŠ¤íŠ¸.

    Raises:
        ValueError: `docker` ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨ ì‹œ.
    """
    logger.info("ë„ì»¤ ì´ë¯¸ì§€ ëª©ë¡ ì¡°íšŒ ì‹œë„.")
    command = "docker images --format '{{json .}}'"
    try:
        result = execute_shell_command(command)
        if not result:
            return []

        images = [json.loads(line) for line in result.strip().split('\n')]
        logger.info(f"{len(images)}ê°œì˜ ë„ì»¤ ì´ë¯¸ì§€ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤.")
        return images
    except Exception as e:
        logger.error(f"ë„ì»¤ ì´ë¯¸ì§€ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise ValueError("ë„ì»¤ ì´ë¯¸ì§€ ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë„ì»¤ê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•˜ì„¸ìš”.")


#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Composite Code & Execution Primitives
=====================================
ì´ ëª¨ë“ˆì€ íŒŒì¼ ì‹¤í–‰, íŒ¨í‚¤ì§€ ê´€ë¦¬, ë²„ì „ ê´€ë¦¬, ì»¨í…Œì´ë„ˆ ì œì–´ ë“±
ë³µì¡í•œ ì½”ë“œ ë° ì‹œìŠ¤í…œ ì‹¤í–‰ ì‘ì—…ì„ ìœ„í•œ ë³µí•© MCP(Mission Control Primitives)ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
ëª¨ë“  í•¨ìˆ˜ëŠ” ë³´ì•ˆì„ ìœ„í•´ ì™¸ë¶€ ì…ë ¥ì„ ì‹ ì¤‘í•˜ê²Œ ê²€ì¦í•˜ê³  ì²˜ë¦¬í•©ë‹ˆë‹¤.
"""

import logging
import re
import shlex
import subprocess
from pathlib import Path
from typing import Dict, List

# --- ë¡œê±° ì„¤ì • ---
# í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œëŠ” JSON í¬ë§·í„° ë“±ì„ ì‚¬ìš©í•˜ì—¬ ë” êµ¬ì¡°í™”ëœ ë¡œê¹…ì„ êµ¬ì„±í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# --- ë³´ì•ˆì„ ìœ„í•œ ìƒìˆ˜ ì •ì˜ ---
# íŒ¨í‚¤ì§€ ì´ë¦„ì— í—ˆìš©ë˜ëŠ” ì •ê·œì‹ (ì•ŒíŒŒë²³, ìˆ«ì, -, _, .)
VALID_PACKAGE_NAME_REGEX = re.compile(r"^[a-zA-Z0-9\-_.]+$")
# Git URLì— ëŒ€í•œ ê¸°ë³¸ì ì¸ ì •ê·œì‹ (http(s) ë˜ëŠ” git@ìœ¼ë¡œ ì‹œì‘)
VALID_GIT_URL_REGEX = re.compile(r"^(https?://|git@).*")
# Docker ì´ë¯¸ì§€/ì»¨í…Œì´ë„ˆ ì´ë¦„ì— ëŒ€í•œ ì •ê·œì‹
VALID_DOCKER_NAME_REGEX = re.compile(r"^[a-zA-Z0-9\-_./:]+$")


def _run_command(command_parts: List[str], cwd: str = None) -> str:
    """
    ë‚´ë¶€ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ì…¸ ëª…ë ¹ì–´ ì‹¤í–‰ í•¨ìˆ˜.

    ë³´ì•ˆì„ ìœ„í•´ ëª…ë ¹ì–´ì™€ ì¸ìë¥¼ ë¶„ë¦¬ëœ ë¦¬ìŠ¤íŠ¸ë¡œ ë°›ì•„ ì‹¤í–‰í•©ë‹ˆë‹¤.
    ì´ë¥¼ í†µí•´ ì…¸ ì¸ì ì…˜ ê³µê²©ì„ ë°©ì§€í•©ë‹ˆë‹¤.

    Args:
        command_parts (List[str]): ëª…ë ¹ì–´ì™€ ê° ì¸ìë¥¼ í¬í•¨í•˜ëŠ” ë¦¬ìŠ¤íŠ¸.
        cwd (str, optional): ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•  ì‘ì—… ë””ë ‰í† ë¦¬. Defaults to None.

    Returns:
        str: ëª…ë ¹ì–´ ì‹¤í–‰ ê²°ê³¼ì˜ í‘œì¤€ ì¶œë ¥(stdout).

    Raises:
        FileNotFoundError: ëª…ë ¹ì–´ê°€ ì‹œìŠ¤í…œì— ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
        subprocess.CalledProcessError: ëª…ë ¹ì–´ê°€ 0ì´ ì•„ë‹Œ ì¢…ë£Œ ì½”ë“œë¡œ ì‹¤íŒ¨í–ˆì„ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
        subprocess.TimeoutExpired: ëª…ë ¹ì–´ê°€ ì§€ì •ëœ ì‹œê°„ ë‚´ì— ì™„ë£Œë˜ì§€ ì•Šì„ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
    """
    logger.info(f"ëª…ë ¹ì–´ ì‹¤í–‰: {' '.join(command_parts)} (ì‘ì—… ë””ë ‰í† ë¦¬: {cwd or '.'})")
    try:
        # shlex.joinì„ ì‚¬ìš©í•˜ë©´ ë¦¬ìŠ¤íŠ¸ë¥¼ ì•ˆì „í•œ ë¬¸ìì—´ë¡œ ë³´ì—¬ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        # ì‹¤ì œ ì‹¤í–‰ì€ ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ ì „ë‹¬í•˜ì—¬ ì…¸ ì¸ì ì…˜ì„ ë°©ì§€í•©ë‹ˆë‹¤.
        process = subprocess.run(
            command_parts,
            check=True,  # ì‹¤íŒ¨ ì‹œ CalledProcessError ë°œìƒ
            capture_output=True,
            text=True,
            encoding='utf-8',
            timeout=300,  # 5ë¶„ íƒ€ì„ì•„ì›ƒ
            cwd=cwd
        )
        logger.info(f"ëª…ë ¹ì–´ ì„±ê³µ: {' '.join(command_parts)}")
        # stdoutì˜ ë§ˆì§€ë§‰ ê°œí–‰ ë¬¸ìë¥¼ ì œê±°í•˜ì—¬ ë°˜í™˜
        return process.stdout.strip()
    except FileNotFoundError as e:
        logger.error(f"ëª…ë ¹ì–´ '{command_parts[0]}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}")
        raise
    except subprocess.CalledProcessError as e:
        error_message = (
            f"ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨: {' '.join(command_parts)}\n"
            f"ì¢…ë£Œ ì½”ë“œ: {e.returncode}\n"
            f"í‘œì¤€ ì¶œë ¥: {e.stdout.strip()}\n"
            f"í‘œì¤€ ì—ëŸ¬: {e.stderr.strip()}"
        )
        logger.error(error_message)
        raise
    except subprocess.TimeoutExpired as e:
        logger.error(f"ëª…ë ¹ì–´ ì‹œê°„ ì´ˆê³¼: {' '.join(command_parts)}: {e}")
        raise
    except Exception as e:
        logger.error(f"ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ ë°œìƒ: {' '.join(command_parts)}: {e}")
        raise


def run_python_script(script_path: str) -> str:
    """
    ì§€ì •ëœ ê²½ë¡œì˜ íŒŒì´ì¬ ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ì„ ì‹¤í–‰í•˜ê³  ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        script_path (str): ì‹¤í–‰í•  íŒŒì´ì¬ ìŠ¤í¬ë¦½íŠ¸ì˜ ê²½ë¡œ.

    Returns:
        str: ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ì˜ í‘œì¤€ ì¶œë ¥(stdout) ê²°ê³¼.

    Raises:
        FileNotFoundError: ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
        ValueError: ì œê³µëœ ê²½ë¡œê°€ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
        subprocess.CalledProcessError: ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí•œ ê²½ìš°.

    Example:
        >>> # test_script.py ë‚´ìš©: print("Hello World")
        >>> run_python_script("test_script.py")
        'Hello World'
    """
    logger.debug(f"ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ ìš”ì²­: {script_path}")
    path = Path(script_path)
    if not path.is_file():
        raise FileNotFoundError(f"ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {script_path}")

    command = ["python", str(path.resolve())]
    return _run_command(command)


def install_python_package(package_name: str) -> str:
    """
    pipì„ ì´ìš©í•´ íŠ¹ì • íŒŒì´ì¬ íŒ¨í‚¤ì§€ë¥¼ ì„¤ì¹˜í•©ë‹ˆë‹¤.

    Args:
        package_name (str): ì„¤ì¹˜í•  íŒŒì´ì¬ íŒ¨í‚¤ì§€ì˜ ì´ë¦„. (ì˜ˆ: "requests", "numpy==1.23.5")

    Returns:
        str: pip install ëª…ë ¹ì–´ì˜ í‘œì¤€ ì¶œë ¥ ê²°ê³¼.

    Raises:
        ValueError: íŒ¨í‚¤ì§€ ì´ë¦„ì´ ìœ íš¨í•˜ì§€ ì•Šì€ í˜•ì‹ì´ê±°ë‚˜ ìœ„í—˜í•œ ë¬¸ìë¥¼ í¬í•¨í•œ ê²½ìš°.
        subprocess.CalledProcessError: íŒ¨í‚¤ì§€ ì„¤ì¹˜ì— ì‹¤íŒ¨í•œ ê²½ìš°.

    Example:
        >>> install_python_package("requests")
        '...Successfully installed requests-x.y.z...'
    """
    logger.debug(f"íŒ¨í‚¤ì§€ ì„¤ì¹˜ ìš”ì²­: {package_name}")
    # ë³´ì•ˆ: íŒ¨í‚¤ì§€ ì´ë¦„ì— ìœ„í—˜í•œ ë¬¸ìê°€ ìˆëŠ”ì§€ í™•ì¸
    if not VALID_PACKAGE_NAME_REGEX.match(package_name.split("==")[0]):
        raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ íŒ¨í‚¤ì§€ ì´ë¦„ì…ë‹ˆë‹¤: {package_name}")

    command = ["python", "-m", "pip", "install", package_name]
    return _run_command(command)


def uninstall_python_package(package_name: str) -> str:
    """
    pipì„ ì´ìš©í•´ ì„¤ì¹˜ëœ íŒŒì´ì¬ íŒ¨í‚¤ì§€ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.

    Args:
        package_name (str): ì‚­ì œí•  íŒŒì´ì¬ íŒ¨í‚¤ì§€ì˜ ì´ë¦„.

    Returns:
        str: pip uninstall ëª…ë ¹ì–´ì˜ í‘œì¤€ ì¶œë ¥ ê²°ê³¼.

    Raises:
        ValueError: íŒ¨í‚¤ì§€ ì´ë¦„ì´ ìœ íš¨í•˜ì§€ ì•Šì€ í˜•ì‹ì´ê±°ë‚˜ ìœ„í—˜í•œ ë¬¸ìë¥¼ í¬í•¨í•œ ê²½ìš°.
        subprocess.CalledProcessError: íŒ¨í‚¤ì§€ ì‚­ì œì— ì‹¤íŒ¨í•œ ê²½ìš°.

    Example:
        >>> uninstall_python_package("requests")
        '...Successfully uninstalled requests-x.y.z...'
    """
    logger.debug(f"íŒ¨í‚¤ì§€ ì‚­ì œ ìš”ì²­: {package_name}")
    if not VALID_PACKAGE_NAME_REGEX.match(package_name):
        raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ íŒ¨í‚¤ì§€ ì´ë¦„ì…ë‹ˆë‹¤: {package_name}")

    command = ["python", "-m", "pip", "uninstall", "-y", package_name]
    return _run_command(command)


def lint_code_file(file_path: str, linter: str = "flake8") -> str:
    """
    ì½”ë“œ íŒŒì¼ì˜ ë¬¸ë²• ì˜¤ë¥˜ë‚˜ ìŠ¤íƒ€ì¼ ë¬¸ì œë¥¼ ê²€ì‚¬(linting)í•©ë‹ˆë‹¤.

    Args:
        file_path (str): ë¦°íŠ¸ ê²€ì‚¬ë¥¼ ìˆ˜í–‰í•  íŒŒì¼ì˜ ê²½ë¡œ.
        linter (str, optional): ì‚¬ìš©í•  ë¦°í„°. ê¸°ë³¸ê°’ì€ "flake8".

    Returns:
        str: ë¦°íŠ¸ ê²€ì‚¬ ê²°ê³¼. ë¬¸ì œê°€ ì—†ëŠ” ê²½ìš° ë¹ˆ ë¬¸ìì—´ì„ ë°˜í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

    Raises:
        FileNotFoundError: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
        ValueError: ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¦°í„°ë¥¼ ì§€ì •í•œ ê²½ìš°.
        subprocess.CalledProcessError: ë¦°íŠ¸ ê²€ì‚¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí•œ ê²½ìš°(ë³´í†µ ë¦°íŠ¸ ìœ„ë°˜ ì‚¬í•­ì´ ë°œê²¬ë˜ì—ˆì„ ë•Œ).

    Example:
        >>> # test.py ë‚´ìš©: import os; x = 1 # E702, F401 ì˜¤ë¥˜ ë°œìƒ
        >>> lint_code_file("test.py")
        "test.py:1:1: F401 'os' imported but unused\ntest.py:1:11: E702 multiple statements on one line (semicolon)"
    """
    logger.debug(f"ì½”ë“œ ë¦°íŠ¸ ìš”ì²­: {file_path} (ë¦°í„°: {linter})")
    if linter not in ["flake8", "black"]: # ì§€ì›í•˜ëŠ” ë¦°í„° ëª©ë¡
        raise ValueError(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¦°í„°ì…ë‹ˆë‹¤: {linter}")

    path = Path(file_path)
    if not path.is_file():
        raise FileNotFoundError(f"íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {file_path}")

    command = [linter, str(path.resolve())]
    if linter == "black":
        command.append("--check") # blackì€ --check ì˜µì…˜ìœ¼ë¡œ ê²€ì‚¬ë§Œ ìˆ˜í–‰

    try:
        return _run_command(command)
    except subprocess.CalledProcessError as e:
        # ë¦°í„°ëŠ” ë¬¸ì œë¥¼ ë°œê²¬í•˜ë©´ 0ì´ ì•„ë‹Œ ì½”ë“œë¥¼ ë°˜í™˜í•˜ëŠ” ê²½ìš°ê°€ ë§ìœ¼ë¯€ë¡œ,
        # í‘œì¤€ ì¶œë ¥/ì—ëŸ¬ë¥¼ ê²°ê³¼ë¡œ ë°˜í™˜í•˜ëŠ” ê²ƒì´ ë” ìœ ìš©í•©ë‹ˆë‹¤.
        return f"Lint issues found:\nSTDOUT:\n{e.stdout.strip()}\nSTDERR:\n{e.stderr.strip()}"


def format_code_file(file_path: str) -> str:
    """
    ì½”ë“œ í¬ë§¤í„°(black)ë¥¼ ì‹¤í–‰í•˜ì—¬ ì½”ë“œ ìŠ¤íƒ€ì¼ì„ ìë™ìœ¼ë¡œ ì •ë¦¬í•©ë‹ˆë‹¤.

    Args:
        file_path (str): ì½”ë“œ í¬ë§·íŒ…ì„ ì ìš©í•  íŒŒì¼ì˜ ê²½ë¡œ.

    Returns:
        str: í¬ë§·íŒ… ê²°ê³¼ ë©”ì‹œì§€.

    Raises:
        FileNotFoundError: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
        subprocess.CalledProcessError: í¬ë§·íŒ… ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí•œ ê²½ìš°.

    Example:
        >>> # test.py ë‚´ìš©: x=1
        >>> format_code_file("test.py")
        'reformatted test.py'
    """
    logger.debug(f"ì½”ë“œ í¬ë§·íŒ… ìš”ì²­: {file_path}")
    path = Path(file_path)
    if not path.is_file():
        raise FileNotFoundError(f"íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {file_path}")

    command = ["black", str(path.resolve())]
    return _run_command(command)


def get_git_status(repo_path: str) -> str:
    """
    ì§€ì •ëœ ë¡œì»¬ ì €ì¥ì†Œì˜ git ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): git ì €ì¥ì†Œì˜ ê²½ë¡œ.

    Returns:
        str: 'git status' ëª…ë ¹ì–´ì˜ ì‹¤í–‰ ê²°ê³¼.

    Raises:
        FileNotFoundError: ì§€ì •ëœ ê²½ë¡œê°€ ë””ë ‰í† ë¦¬ê°€ ì•„ë‹ˆê±°ë‚˜ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°.
        subprocess.CalledProcessError: git ëª…ë ¹ì–´ ì‹¤í–‰ì— ì‹¤íŒ¨í•œ ê²½ìš° (ì˜ˆ: git ì €ì¥ì†Œê°€ ì•„ë‹˜).

    Example:
        >>> get_git_status(".")
        'On branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean'
    """
    logger.debug(f"Git ìƒíƒœ í™•ì¸ ìš”ì²­: {repo_path}")
    path = Path(repo_path)
    if not path.is_dir():
        raise FileNotFoundError(f"ë””ë ‰í† ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {repo_path}")

    command = ["git", "status"]
    return _run_command(command, cwd=str(path.resolve()))


def clone_git_repository(repo_url: str, clone_path: str) -> str:
    """
    ì›ê²© Git ì €ì¥ì†Œë¥¼ ì§€ì •ëœ ê²½ë¡œì— ë³µì œ(clone)í•©ë‹ˆë‹¤.

    Args:
        repo_url (str): ë³µì œí•  ì›ê²© ì €ì¥ì†Œì˜ URL.
        clone_path (str): ì €ì¥ì†Œë¥¼ ë³µì œí•  ë¡œì»¬ ë””ë ‰í† ë¦¬ ê²½ë¡œ.

    Returns:
        str: ì„±ê³µì ìœ¼ë¡œ ë³µì œë˜ì—ˆë‹¤ëŠ” ë©”ì‹œì§€.

    Raises:
        ValueError: Git URLì´ ìœ íš¨í•˜ì§€ ì•Šì€ í˜•ì‹ì¼ ê²½ìš°.
        FileExistsError: ë³µì œí•  ê²½ë¡œì— ì´ë¯¸ íŒŒì¼ì´ë‚˜ ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš°.
        subprocess.CalledProcessError: git clone ëª…ë ¹ì–´ ì‹¤í–‰ì— ì‹¤íŒ¨í•œ ê²½ìš°.

    Example:
        >>> clone_git_repository("https://github.com/user/repo.git", "./my-repo")
        "Cloning into './my-repo'..."
    """
    logger.debug(f"Git í´ë¡  ìš”ì²­: {repo_url} -> {clone_path}")
    if not VALID_GIT_URL_REGEX.match(repo_url):
        raise ValueError("ìœ íš¨í•˜ì§€ ì•Šì€ Git URL í˜•ì‹ì…ë‹ˆë‹¤.")

    path = Path(clone_path)
    if path.exists():
        raise FileExistsError(f"ì§€ì •í•œ ê²½ë¡œê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤: {clone_path}")

    command = ["git", "clone", repo_url, str(path.resolve())]
    result = _run_command(command)
    return f"ì €ì¥ì†Œ {repo_url}ì„(ë¥¼) {clone_path}ì— ì„±ê³µì ìœ¼ë¡œ ë³µì œí–ˆìŠµë‹ˆë‹¤.\n{result}"


def setup_python_venv(path: str) -> str:
    """
    ì§€ì •ëœ ê²½ë¡œì— íŒŒì´ì¬ ê°€ìƒ í™˜ê²½ì„ ìƒì„±í•©ë‹ˆë‹¤.

    Args:
        path (str): ê°€ìƒ í™˜ê²½ì„ ìƒì„±í•  ë””ë ‰í† ë¦¬ ê²½ë¡œ.

    Returns:
        str: ê°€ìƒ í™˜ê²½ì´ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆë‹¤ëŠ” ë©”ì‹œì§€.

    Raises:
        FileExistsError: ì§€ì •ëœ ê²½ë¡œê°€ ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê²½ìš°.
        subprocess.CalledProcessError: ê°€ìƒ í™˜ê²½ ìƒì„±ì— ì‹¤íŒ¨í•œ ê²½ìš°.

    Example:
        >>> setup_python_venv("./my-venv")
        'ê°€ìƒ í™˜ê²½ì´ ./my-venv ì— ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.'
    """
    logger.debug(f"ê°€ìƒ í™˜ê²½ ìƒì„± ìš”ì²­: {path}")
    venv_path = Path(path)
    if venv_path.exists():
        raise FileExistsError(f"ì§€ì •í•œ ê²½ë¡œê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤: {path}")

    command = ["python", "-m", "venv", str(venv_path.resolve())]
    _run_command(command)
    return f"ê°€ìƒ í™˜ê²½ì´ {path} ì— ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤."


def build_docker_image(dockerfile_path: str, image_name: str) -> str:
    """
    ì§€ì •ëœ Dockerfileì„ ì‚¬ìš©í•˜ì—¬ ìƒˆë¡œìš´ ë„ì»¤ ì´ë¯¸ì§€ë¥¼ ë¹Œë“œí•©ë‹ˆë‹¤.

    Args:
        dockerfile_path (str): Dockerfileì´ ìœ„ì¹˜í•œ ë””ë ‰í† ë¦¬ ê²½ë¡œ.
        image_name (str): ë¹Œë“œí•  ì´ë¯¸ì§€ì˜ ì´ë¦„ê³¼ íƒœê·¸ (ì˜ˆ: "my-app:1.0").

    Returns:
        str: 'docker build' ëª…ë ¹ì–´ì˜ ì‹¤í–‰ ê²°ê³¼.

    Raises:
        FileNotFoundError: Dockerfile ê²½ë¡œê°€ ë””ë ‰í† ë¦¬ê°€ ì•„ë‹ˆê±°ë‚˜ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°.
        ValueError: ì´ë¯¸ì§€ ì´ë¦„ì´ ìœ íš¨í•˜ì§€ ì•Šì€ í˜•ì‹ì¼ ê²½ìš°.
        subprocess.CalledProcessError: ì´ë¯¸ì§€ ë¹Œë“œì— ì‹¤íŒ¨í•œ ê²½ìš°.

    Example:
        >>> build_docker_image(".", "my-test-app:latest")
        '...Successfully built a1b2c3d4e5f6\nSuccessfully tagged my-test-app:latest'
    """
    logger.debug(f"Docker ì´ë¯¸ì§€ ë¹Œë“œ ìš”ì²­: {image_name} from {dockerfile_path}")
    if not VALID_DOCKER_NAME_REGEX.match(image_name):
        raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ Docker ì´ë¯¸ì§€ ì´ë¦„ì…ë‹ˆë‹¤: {image_name}")

    path = Path(dockerfile_path)
    if not path.is_dir():
        raise FileNotFoundError(f"Dockerfile ë””ë ‰í† ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {dockerfile_path}")

    command = ["docker", "build", "-t", image_name, "."]
    return _run_command(command, cwd=str(path.resolve()))


def run_container_from_image(image_name: str, ports: Dict[int, int] = None) -> str:
    """
    ì§€ì •ëœ ë„ì»¤ ì´ë¯¸ì§€ë¡œ ì»¨í…Œì´ë„ˆë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    Args:
        image_name (str): ì‹¤í–‰í•  ë„ì»¤ ì´ë¯¸ì§€ì˜ ì´ë¦„.
        ports (Dict[int, int], optional): í¬íŠ¸ ë§¤í•‘. {host_port: container_port}. Defaults to None.

    Returns:
        str: ì‹¤í–‰ëœ ì»¨í…Œì´ë„ˆì˜ ID.

    Raises:
        ValueError: ì´ë¯¸ì§€ ì´ë¦„ì´ ìœ íš¨í•˜ì§€ ì•Šê±°ë‚˜ í¬íŠ¸ ë²ˆí˜¸ê°€ ì˜ëª»ëœ ê²½ìš°.
        subprocess.CalledProcessError: ì»¨í…Œì´ë„ˆ ì‹¤í–‰ì— ì‹¤íŒ¨í•œ ê²½ìš°.

    Example:
        >>> run_container_from_image("hello-world")
        'abcdef123456...'
        >>> run_container_from_image("nginx:latest", ports={8080: 80})
        'fedcba654321...'
    """
    logger.debug(f"Docker ì»¨í…Œì´ë„ˆ ì‹¤í–‰ ìš”ì²­: {image_name}, í¬íŠ¸: {ports}")
    if not VALID_DOCKER_NAME_REGEX.match(image_name):
        raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ Docker ì´ë¯¸ì§€ ì´ë¦„ì…ë‹ˆë‹¤: {image_name}")

    command = ["docker", "run", "-d"] # -d: detached mode

    if ports:
        for host_port, container_port in ports.items():
            if not (0 < host_port < 65536 and 0 < container_port < 65536):
                raise ValueError("í¬íŠ¸ ë²ˆí˜¸ëŠ” 1ê³¼ 65535 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤.")
            command.extend(["-p", f"{host_port}:{container_port}"])

    command.append(image_name)
    return _run_command(command)


def get_container_logs(container_id: str) -> str:
    """
    ì‹¤í–‰ ì¤‘ì¸ ë„ì»¤ ì»¨í…Œì´ë„ˆì˜ ë¡œê·¸ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.

    Args:
        container_id (str): ë¡œê·¸ë¥¼ ì¡°íšŒí•  ì»¨í…Œì´ë„ˆì˜ ID ë˜ëŠ” ì´ë¦„.

    Returns:
        str: í•´ë‹¹ ì»¨í…Œì´ë„ˆì˜ ë¡œê·¸.

    Raises:
        ValueError: ì»¨í…Œì´ë„ˆ ID í˜•ì‹ì´ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°.
        subprocess.CalledProcessError: ì»¨í…Œì´ë„ˆ ë¡œê·¸ ì¡°íšŒì— ì‹¤íŒ¨í•œ ê²½ìš° (ì˜ˆ: ì»¨í…Œì´ë„ˆê°€ ì—†ìŒ).

    Example:
        >>> get_container_logs("my-running-container")
        'Server started on port 80...'
    """
    logger.debug(f"Docker ë¡œê·¸ ìš”ì²­: {container_id}")
    if not VALID_DOCKER_NAME_REGEX.match(container_id):
        raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ ì»¨í…Œì´ë„ˆ ID í˜•ì‹ì…ë‹ˆë‹¤: {container_id}")

    command = ["docker", "logs", container_id]
    return _run_command(command)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# mcp_modules/create_code_bundle.py

import logging
from pathlib import Path
from typing import List
import sys # sysëŠ” ë¡œê¹…ì´ë‚˜ print ì™¸ì˜ ìš©ë„ë¡œ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

# --- [1. ë¬¸ì œì˜ ì½”ë“œ (ì¶”ì •)] ---
#
# try:
#     import pathspec
# except ImportError:
#     print("Error: pathspec library is not installed...", file=sys.stderr)
#     exit(1) # <-- ì´ ì½”ë“œê°€ ì„œë²„ ì „ì²´ë¥¼ ì¤‘ë‹¨ì‹œí‚µë‹ˆë‹¤!
#
# --- [1. ìˆ˜ì • ì™„ë£Œ] ---

logger = logging.getLogger(__name__)

def create_code_bundle_with_gitignore(repo_path: str) -> str:
    """
    ì§€ì •ëœ ê²½ë¡œì—ì„œ .gitignore ê·œì¹™ì„ ì¡´ì¤‘í•˜ë©´ì„œ ëª¨ë“  í…ìŠ¤íŠ¸ ê¸°ë°˜ íŒŒì¼ì„
    í•˜ë‚˜ì˜ 'ì½”ë“œ ë²ˆë“¤' ë¬¸ìì—´ë¡œ ê²°í•©í•©ë‹ˆë‹¤.
    AIì—ê²Œ ì „ì²´ ì½”ë“œë² ì´ìŠ¤ë¥¼ í•œ ë²ˆì— ì œê³µí•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.

    [Dependency] ì´ MCPëŠ” 'pathspec' ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ í•„ìš”í•©ë‹ˆë‹¤.
    """
    
    # --- [2. ì˜¬ë°”ë¥¸ ìˆ˜ì •] ---
    # ì„í¬íŠ¸(import)ëŠ” í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ì‹œë„í•´ì•¼ í•©ë‹ˆë‹¤.
    try:
        import pathspec
    except ImportError:
        logger.error("create_code_bundle_with_gitignore: 'pathspec' ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.")
        # exit() ëŒ€ì‹ , ì´ ì˜¤ë¥˜ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤.
        # api.pyì˜ execute_groupì´ ì´ ì˜¤ë¥˜ë¥¼ ì¡ì•„ EXECUTION_ERRORë¡œ ì‚¬ìš©ìì—ê²Œ ë³´ê³ í•©ë‹ˆë‹¤.
        raise ModuleNotFoundError(
            "ì´ ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ 'pathspec' ë¼ì´ë¸ŒSëŸ¬ë¦¬ê°€ í•„ìš”í•©ë‹ˆë‹¤. "
            "ì‚¬ìš©ìì—ê²Œ 'pip install pathspec'ì„ ìš”ì²­í•˜ì„¸ìš”."
        )
    # --- [2. ìˆ˜ì • ì™„ë£Œ] ---

    logger.info(f"'{repo_path}'ì—ì„œ .gitignoreë¥¼ ë°˜ì˜í•œ ì½”ë“œ ë²ˆë“¤ ìƒì„±ì„ ì‹œì‘í•©ë‹ˆë‹¤.")
    
    base_dir = Path(repo_path).resolve()
    gitignore_path = base_dir / ".gitignore"
    
    lines = []
    if gitignore_path.exists():
        try:
            with open(gitignore_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
        except Exception as e:
            logger.warning(f".gitignore íŒŒì¼({gitignore_path})ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
    else:
        logger.warning(f".gitignore íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ì–´({gitignore_path}), ì¼ë¶€ ë¶ˆí•„ìš”í•œ íŒŒì¼ì´ í¬í•¨ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
    
    # .gitignore ê·œì¹™ ë¡œë“œ (gitwildmatch ìŠ¤íƒ€ì¼)
    spec = pathspec.PathSpec.from_lines('gitwildmatch', lines)
    
    all_files = []
    # ì¼ë°˜ì ìœ¼ë¡œ ì œì™¸í•  ë””ë ‰í† ë¦¬ ë° íŒŒì¼ íŒ¨í„´
    exclude_patterns = {'.git', 'venv', '__pycache__', '.vscode', '.idea'}
    
    for file_path in base_dir.rglob('*'):
        if file_path.is_file():
            relative_path = file_path.relative_to(base_dir)
            
            # 1. ì¼ë°˜ì ì¸ ì œì™¸ íŒ¨í„´ í™•ì¸
            if any(part in exclude_patterns for part in relative_path.parts):
                continue
                
            # 2. .gitignore ê·œì¹™ í™•ì¸
            if not spec.match_file(str(relative_path)):
                all_files.append(file_path)
    
    logger.info(f".gitignoreë¥¼ ì ìš©í•˜ì—¬ ì´ {len(all_files)}ê°œì˜ íŒŒì¼ì„ ì°¾ì•˜ìŠµë‹ˆë‹¤.")
    
    combined_content = ""
    for file_path in all_files:
        try:
            # ë°”ì´ë„ˆë¦¬ íŒŒì¼ì´ë‚˜ ë„ˆë¬´ í° íŒŒì¼ì€ ê±´ë„ˆë›°ê¸°
            if file_path.stat().st_size > 5_000_000: # 5MB
                logger.warning(f"'{file_path}' íŒŒì¼ì´ ë„ˆë¬´ ì»¤ì„œ(5MB ì´ˆê³¼) ê±´ë„ˆëœë‹ˆë‹¤.")
                continue

            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # AIê°€ íŒŒì¼ ê²½ë¡œë¥¼ ëª…í™•íˆ ì¸ì§€í•˜ë„ë¡ í—¤ë” ì¶”ê°€
            combined_content += f"\n--- START OF {file_path.relative_to(base_dir)} ---\n"
            combined_content += content
            combined_content += f"\n--- END OF {file_path.relative_to(base_dir)} ---\n"
            
        except (UnicodeDecodeError, PermissionError):
            logger.warning(f"'{file_path}'ëŠ” í…ìŠ¤íŠ¸ íŒŒì¼ì´ ì•„ë‹ˆê±°ë‚˜ ì½ì„ ìˆ˜ ì—†ì–´ ê±´ë„ˆëœë‹ˆë‹¤.")
        except Exception as e:
            logger.warning(f"'{file_path}' íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: {e}. ê±´ë„ˆëœë‹ˆë‹¤.")
    
    logger.info("ëª¨ë“  íŒŒì¼ ì½ê¸° ë° ì½”ë“œ ë²ˆë“¤ ê²°í•© ì™„ë£Œ.")
    return combined_content

# (ì°¸ê³ ) ë§Œì•½ íŒŒì¼ì— í•¨ìˆ˜ê°€ ì—¬ëŸ¬ ê°œ ìˆë‹¤ë©´, pathspecì„ ì‚¬ìš©í•˜ëŠ” ëª¨ë“  í•¨ìˆ˜ì—
# try-except ì„í¬íŠ¸ êµ¬ë¬¸ì„ ë„£ì–´ì£¼ì–´ì•¼ í•©ë‹ˆë‹¤.
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""íŒŒì¼ ì‹œìŠ¤í…œ ê²½ë¡œì˜ ì†ì„±ê³¼ ìƒíƒœë¥¼ í™•ì¸í•˜ëŠ” ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ëª¨ìŒì…ë‹ˆë‹¤."""

import logging
import os
from datetime import datetime
from pathlib import Path
from typing import Union

# ë¡œê±° ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# --- Helper Function ---
def _validate_and_get_path(path: Union[str, Path]) -> Path:
    """ë‚´ë¶€ìš© í—¬í¼: ê²½ë¡œ ìœ íš¨ì„±ì„ ê²€ì‚¬í•˜ê³  Path ê°ì²´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤."""
    if not path:
        raise ValueError("íŒŒì¼ ê²½ë¡œëŠ” ë¹„ì–´ìˆê±°ë‚˜ Noneì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    return Path(path)

# --- MCP Functions ---

def path_exists(path: Union[str, Path]) -> bool:
    """í•´ë‹¹ ê²½ë¡œì— íŒŒì¼ì´ë‚˜ ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ì¡´ì¬ ì—¬ë¶€ë¥¼ í™•ì¸í•  ê²½ë¡œì…ë‹ˆë‹¤.

    Returns:
        bool: ê²½ë¡œê°€ ì¡´ì¬í•˜ë©´ True, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ Falseë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Example:
        >>> path_exists('C:/Users')
        True
        >>> path_exists('non_existent_folder/file.txt')
        False
    """
    try:
        p = _validate_and_get_path(path)
        return p.exists()
    except ValueError:
        return False # ì˜ëª»ëœ ê²½ë¡œëŠ” ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²ƒìœ¼ë¡œ ê°„ì£¼

def is_file(path: Union[str, Path]) -> bool:
    """í•´ë‹¹ ê²½ë¡œê°€ ì‹¤ì œ íŒŒì¼ì„ ê°€ë¦¬í‚¤ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): íŒŒì¼ì¸ì§€ í™•ì¸í•  ê²½ë¡œì…ë‹ˆë‹¤.

    Returns:
        bool: ê²½ë¡œê°€ ì¡´ì¬í•˜ë©° íŒŒì¼ì´ë©´ True, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ Falseë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Example:
        >>> is_file('my_document.txt')
        True
        >>> is_file('my_folder/')
        False
    """
    try:
        p = _validate_and_get_path(path)
        return p.is_file()
    except ValueError:
        return False

def is_directory(path: Union[str, Path]) -> bool:
    """í•´ë‹¹ ê²½ë¡œê°€ ì‹¤ì œ ë””ë ‰í† ë¦¬(í´ë”)ë¥¼ ê°€ë¦¬í‚¤ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ë””ë ‰í† ë¦¬ì¸ì§€ í™•ì¸í•  ê²½ë¡œì…ë‹ˆë‹¤.

    Returns:
        bool: ê²½ë¡œê°€ ì¡´ì¬í•˜ë©° ë””ë ‰í† ë¦¬ì´ë©´ True, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ Falseë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Example:
        >>> is_directory('C:/Windows')
        True
        >>> is_directory('my_script.py')
        False
    """
    try:
        p = _validate_and_get_path(path)
        return p.is_dir()
    except ValueError:
        return False

def get_file_size(path: Union[str, Path]) -> int:
    """íŒŒì¼ì˜ í¬ê¸°ë¥¼ ë°”ì´íŠ¸(byte) ë‹¨ìœ„ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): í¬ê¸°ë¥¼ ì¡°íšŒí•  íŒŒì¼ì˜ ê²½ë¡œì…ë‹ˆë‹¤.

    Returns:
        int: íŒŒì¼ì˜ í¬ê¸°(bytes).

    Raises:
        FileNotFoundError: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
        IsADirectoryError: ê²½ë¡œê°€ íŒŒì¼ì´ ì•„ë‹Œ ë””ë ‰í† ë¦¬ì¼ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
        PermissionError: íŒŒì¼ì— ì ‘ê·¼í•  ê¶Œí•œì´ ì—†ì„ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
    """
    logger.info(f"Requesting file size for: {path}")
    p = _validate_and_get_path(path)
    if not p.exists():
        raise FileNotFoundError(f"íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {p}")
    if not p.is_file():
        raise IsADirectoryError(f"ê²½ë¡œê°€ íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤. ë””ë ‰í† ë¦¬ì˜ í¬ê¸°ë¥¼ ì¡°íšŒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {p}")
    
    try:
        size = p.stat().st_size
        logger.info(f"File size of {p} is {size} bytes.")
        return size
    except PermissionError as e:
        logger.error(f"Permission denied for {p}: {e}")
        raise

def get_modification_time(path: Union[str, Path]) -> datetime:
    """íŒŒì¼ì´ ë§ˆì§€ë§‰ìœ¼ë¡œ ìˆ˜ì •ëœ ì‹œê°„ì„ datetime ê°ì²´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ìˆ˜ì • ì‹œê°„ì„ ì¡°íšŒí•  íŒŒì¼ ë˜ëŠ” ë””ë ‰í† ë¦¬ì˜ ê²½ë¡œì…ë‹ˆë‹¤.

    Returns:
        datetime: ë§ˆì§€ë§‰ ìˆ˜ì • ì‹œê°„ì„ ë‹´ì€ datetime ê°ì²´.

    Raises:
        FileNotFoundError: ê²½ë¡œê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
    """
    logger.info(f"Requesting modification time for: {path}")
    p = _validate_and_get_path(path)
    if not p.exists():
        raise FileNotFoundError(f"ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {p}")
        
    timestamp = p.stat().st_mtime
    mod_time = datetime.fromtimestamp(timestamp)
    logger.info(f"Modification time for {p} is {mod_time}.")
    return mod_time

def get_creation_time(path: Union[str, Path]) -> datetime:
    """íŒŒì¼ì´ ìƒì„±ëœ ì‹œê°„ì„ datetime ê°ì²´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

    ì°¸ê³ : Unix/Linux ê³„ì—´ ì‹œìŠ¤í…œì—ì„œëŠ” 'ìƒì„± ì‹œê°„'ì´ ì•„ë‹Œ 'ë§ˆì§€ë§‰ ë©”íƒ€ë°ì´í„°
    ë³€ê²½ ì‹œê°„(ctime)'ì„ ë°˜í™˜í•  ìˆ˜ ìˆì–´ ì‹œìŠ¤í…œì— ë”°ë¼ ì˜ë¯¸ê°€ ë‹¤ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ìƒì„± ì‹œê°„ì„ ì¡°íšŒí•  íŒŒì¼ ë˜ëŠ” ë””ë ‰í† ë¦¬ì˜ ê²½ë¡œì…ë‹ˆë‹¤.

    Returns:
        datetime: ìƒì„± ì‹œê°„ì„ ë‹´ì€ datetime ê°ì²´.

    Raises:
        FileNotFoundError: ê²½ë¡œê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
    """
    logger.info(f"Requesting creation time for: {path}")
    p = _validate_and_get_path(path)
    if not p.exists():
        raise FileNotFoundError(f"ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {p}")
        
    try:
        # os.path.getctime()ëŠ” í”Œë«í¼ë³„ ìƒì„± ì‹œê°„ì„ ë” ì˜ ì²˜ë¦¬í•¨
        timestamp = os.path.getctime(p)
        cre_time = datetime.fromtimestamp(timestamp)
        logger.info(f"Creation time for {p} is {cre_time}.")
        return cre_time
    except OSError as e:
        logger.error(f"Could not get creation time for {p}: {e}")
        raise FileNotFoundError(f"ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {p}")


def get_current_working_directory() -> str:
    """í˜„ì¬ ìŠ¤í¬ë¦½íŠ¸ê°€ ì‹¤í–‰ ì¤‘ì¸ ì‘ì—… ë””ë ‰í† ë¦¬ì˜ ì ˆëŒ€ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Returns:
        str: í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬ì˜ ì ˆëŒ€ ê²½ë¡œ.
    """
    cwd = Path.cwd()
    logger.info(f"Current working directory is: {cwd}")
    return str(cwd)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
íŒŒì¼ ë‚´ìš©(Content) ì²˜ë¦¬ë¥¼ ìœ„í•œ ì›ì(Atomic) MCP ëª¨ìŒ.

ì´ ëª¨ë“ˆì€ í…ìŠ¤íŠ¸ ë° ë°”ì´ë„ˆë¦¬ íŒŒì¼ì— ëŒ€í•œ ê¸°ë³¸ì ì¸ CRUD(Create, Read, Update)
ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ê³ í’ˆì§ˆì˜ í•¨ìˆ˜ë“¤ì„ ì œê³µí•©ë‹ˆë‹¤. ëª¨ë“  í•¨ìˆ˜ëŠ” ë³´ì•ˆ, ì•ˆì •ì„±,
ê·¸ë¦¬ê³  ëª…í™•í•œ ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ìµœìš°ì„ ìœ¼ë¡œ ê³ ë ¤í•˜ì—¬ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.
"""

import logging
from pathlib import Path
from typing import Union, List, ByteString

# --- ëª¨ë“ˆ ë ˆë²¨ ë¡œê±° ì„¤ì • ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def _prepare_write_path(path: Union[str, Path]) -> Path:
    """ì“°ê¸° ì‘ì—…ì„ ìœ„í•´ ê²½ë¡œë¥¼ ê²€ì¦í•˜ê³  ì¤€ë¹„í•˜ëŠ” ë‚´ë¶€ í—¬í¼ í•¨ìˆ˜."""
    if not path:
        raise ValueError("íŒŒì¼ ê²½ë¡œëŠ” ë¹„ì–´ìˆê±°ë‚˜ Noneì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    p = Path(path).resolve()

    if p.is_dir():
        raise IsADirectoryError(f"íŒŒì¼ì„ ì“¸ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í•´ë‹¹ ê²½ë¡œëŠ” ë””ë ‰í† ë¦¬ì…ë‹ˆë‹¤: {p}")

    # ìƒìœ„ ë””ë ‰í† ë¦¬ê°€ ì—†ìœ¼ë©´ ì¬ê·€ì ìœ¼ë¡œ ìƒì„±
    p.parent.mkdir(parents=True, exist_ok=True)
    return p


def read_file(path: Union[str, Path], encoding: str = 'utf-8') -> str:
    """ì§€ì •ëœ ê²½ë¡œì˜ í…ìŠ¤íŠ¸ íŒŒì¼ ë‚´ìš©ì„ ì „ë¶€ ì½ì–´ ë¬¸ìì—´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ì½ì„ íŒŒì¼ì˜ ê²½ë¡œ.
        encoding (str, optional): íŒŒì¼ì„ ì½ì„ ë•Œ ì‚¬ìš©í•  ì¸ì½”ë”©. ê¸°ë³¸ê°’ 'utf-8'.

    Returns:
        str: íŒŒì¼ì˜ ì „ì²´ í…ìŠ¤íŠ¸ ë‚´ìš©.

    Raises:
        FileNotFoundError: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°.
        PermissionError: íŒŒì¼ì„ ì½ì„ ê¶Œí•œì´ ì—†ì„ ê²½ìš°.
        IsADirectoryError: ê²½ë¡œê°€ íŒŒì¼ì´ ì•„ë‹Œ ë””ë ‰í† ë¦¬ì¼ ê²½ìš°.
        UnicodeDecodeError: ì§€ì •ëœ ì¸ì½”ë”©ìœ¼ë¡œ íŒŒì¼ì„ ë””ì½”ë”©í•  ìˆ˜ ì—†ì„ ê²½ìš°.
        ValueError: ê²½ë¡œê°€ ìœ íš¨í•˜ì§€ ì•Šì„ ê²½ìš°.
    
    Example:
        >>> content = read_file('my_document.txt')
        >>> print(content)
    """
    logger.info(f"Attempting to read text file: {path}")
    if not path:
        raise ValueError("íŒŒì¼ ê²½ë¡œëŠ” ë¹„ì–´ìˆê±°ë‚˜ Noneì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        
    try:
        p = Path(path).resolve(strict=True)
        if not p.is_file():
            raise IsADirectoryError(f"í•´ë‹¹ ê²½ë¡œëŠ” íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤: {p}")
        
        content = p.read_text(encoding=encoding)
        logger.info(f"Successfully read {len(content)} characters from {p}")
        return content
    except (FileNotFoundError, PermissionError, IsADirectoryError, UnicodeDecodeError) as e:
        logger.error(f"Failed to read file {path}: {e}")
        raise
    except Exception as e:
        logger.critical(f"Unexpected error reading file {path}: {e}")
        raise IOError(f"íŒŒì¼ ì½ê¸° ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")

def read_binary_file(path: Union[str, Path]) -> bytes:
    """ì§€ì •ëœ ê²½ë¡œì˜ ë°”ì´ë„ˆë¦¬ íŒŒì¼(ì´ë¯¸ì§€ ë“±) ë‚´ìš©ì„ ë°”ì´íŠ¸ í˜•íƒœë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ì½ì„ ë°”ì´ë„ˆë¦¬ íŒŒì¼ì˜ ê²½ë¡œ.

    Returns:
        bytes: íŒŒì¼ì˜ ì „ì²´ ë°”ì´ë„ˆë¦¬ ë°ì´í„°.

    Raises:
        FileNotFoundError, PermissionError, IsADirectoryError, ValueError ë“±
    
    Example:
        >>> image_data = read_binary_file('photo.jpg')
    """
    logger.info(f"Attempting to read binary file: {path}")
    if not path:
        raise ValueError("íŒŒì¼ ê²½ë¡œëŠ” ë¹„ì–´ìˆê±°ë‚˜ Noneì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    try:
        p = Path(path).resolve(strict=True)
        if not p.is_file():
            raise IsADirectoryError(f"í•´ë‹¹ ê²½ë¡œëŠ” íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤: {p}")

        content = p.read_bytes()
        logger.info(f"Successfully read {len(content)} bytes from {p}")
        return content
    except (FileNotFoundError, PermissionError, IsADirectoryError) as e:
        logger.error(f"Failed to read binary file {path}: {e}")
        raise
    except Exception as e:
        logger.critical(f"Unexpected error reading binary file {path}: {e}")
        raise IOError(f"ë°”ì´ë„ˆë¦¬ íŒŒì¼ ì½ê¸° ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")

def write_file(path: Union[str, Path], content: str, encoding: str = 'utf-8') -> str:
    """ì§€ì •ëœ ê²½ë¡œì— í…ìŠ¤íŠ¸ ë‚´ìš©ì„ ì”ë‹ˆë‹¤. ê¸°ì¡´ íŒŒì¼ì€ ë®ì–´ì”ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ë‚´ìš©ì„ ì“¸ íŒŒì¼ì˜ ê²½ë¡œ.
        content (str): íŒŒì¼ì— ì“¸ í…ìŠ¤íŠ¸ ë‚´ìš©.
        encoding (str, optional): íŒŒì¼ì„ ì“¸ ë•Œ ì‚¬ìš©í•  ì¸ì½”ë”©. ê¸°ë³¸ê°’ 'utf-8'.

    Returns:
        str: ì„±ê³µ ì‹œ, ê¸°ë¡ëœ íŒŒì¼ì˜ ì ˆëŒ€ ê²½ë¡œ.

    Raises:
        PermissionError, IsADirectoryError, ValueError ë“±
    
    Example:
        >>> final_path = write_file('log.txt', 'This is a log message.')
    """
    logger.info(f"Attempting to write text file: {path}")
    try:
        p = _prepare_write_path(path)
        p.write_text(content, encoding=encoding)
        logger.info(f"Successfully wrote {len(content)} characters to {p}")
        return str(p)
    except (PermissionError, IsADirectoryError) as e:
        logger.error(f"Failed to write file {path}: {e}")
        raise
    except Exception as e:
        logger.critical(f"Unexpected error writing file {path}: {e}")
        raise IOError(f"íŒŒì¼ ì“°ê¸° ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")

def write_binary_file(path: Union[str, Path], content: ByteString) -> str:
    """ì§€ì •ëœ ê²½ë¡œì— ë°”ì´ë„ˆë¦¬ ë°ì´í„°ë¥¼ ì”ë‹ˆë‹¤. ê¸°ì¡´ íŒŒì¼ì€ ë®ì–´ì”ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ë‚´ìš©ì„ ì“¸ íŒŒì¼ì˜ ê²½ë¡œ.
        content (ByteString): íŒŒì¼ì— ì“¸ ë°”ì´ë„ˆë¦¬ ë°ì´í„° (bytes, bytearray ë“±).

    Returns:
        str: ì„±ê³µ ì‹œ, ê¸°ë¡ëœ íŒŒì¼ì˜ ì ˆëŒ€ ê²½ë¡œ.

    Raises:
        PermissionError, IsADirectoryError, ValueError ë“±
    
    Example:
        >>> data = b'\\xDE\\xAD\\xBE\\xEF'
        >>> final_path = write_binary_file('data.bin', data)
    """
    logger.info(f"Attempting to write binary file: {path}")
    try:
        p = _prepare_write_path(path)
        p.write_bytes(content)
        logger.info(f"Successfully wrote {len(content)} bytes to {p}")
        return str(p)
    except (PermissionError, IsADirectoryError) as e:
        logger.error(f"Failed to write binary file {path}: {e}")
        raise
    except Exception as e:
        logger.critical(f"Unexpected error writing binary file {path}: {e}")
        raise IOError(f"ë°”ì´ë„ˆë¦¬ íŒŒì¼ ì“°ê¸° ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")

def append_to_file(path: Union[str, Path], content: str, encoding: str = 'utf-8') -> str:
    """ê¸°ì¡´ í…ìŠ¤íŠ¸ íŒŒì¼ì˜ ëì— ë‚´ìš©ì„ ì¶”ê°€í•©ë‹ˆë‹¤. íŒŒì¼ì´ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ë‚´ìš©ì„ ì¶”ê°€í•  íŒŒì¼ì˜ ê²½ë¡œ.
        content (str): íŒŒì¼ì— ì¶”ê°€í•  í…ìŠ¤íŠ¸ ë‚´ìš©.
        encoding (str, optional): íŒŒì¼ì„ ì—´ ë•Œ ì‚¬ìš©í•  ì¸ì½”ë”©. ê¸°ë³¸ê°’ 'utf-8'.

    Returns:
        str: ì„±ê³µ ì‹œ, ê¸°ë¡ëœ íŒŒì¼ì˜ ì ˆëŒ€ ê²½ë¡œ.

    Raises:
        PermissionError, IsADirectoryError, ValueError ë“±
    
    Example:
        >>> final_path = append_to_file('log.txt', '\\nAnother log message.')
    """
    logger.info(f"Attempting to append to text file: {path}")
    try:
        p = _prepare_write_path(path)
        with p.open(mode='a', encoding=encoding) as f:
            f.write(content)
        logger.info(f"Successfully appended {len(content)} characters to {p}")
        return str(p)
    except (PermissionError, IsADirectoryError) as e:
        logger.error(f"Failed to append to file {path}: {e}")
        raise
    except Exception as e:
        logger.critical(f"Unexpected error appending to file {path}: {e}")
        raise IOError(f"íŒŒì¼ ì´ì–´ì“°ê¸° ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""íŒŒì¼ ë° ë””ë ‰í† ë¦¬ ê´€ë¦¬ë¥¼ ìœ„í•œ í•µì‹¬ ì›ì(Atomic) MCPs ëª¨ìŒ."""

import logging
import os
import shutil
from pathlib import Path
from typing import List, Union

# ë¡œê±° ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def create_directory(path: Union[str, Path], exist_ok: bool = True) -> str:
    """ì§€ì •ëœ ê²½ë¡œì— ìƒˆë¡œìš´ ë””ë ‰í† ë¦¬(í´ë”)ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    ì´ í•¨ìˆ˜ëŠ” ë©±ë“±ì„±(Idempotency)ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ ê¸°ë³¸ì ìœ¼ë¡œ ëŒ€ìƒ ë””ë ‰í† ë¦¬ê°€
    ì´ë¯¸ ì¡´ì¬í•˜ë”ë¼ë„ ì˜¤ë¥˜ë¥¼ ë°œìƒì‹œí‚¤ì§€ ì•ŠìŠµë‹ˆë‹¤ (`exist_ok=True`).
    ì¤‘ì²©ëœ ê²½ë¡œ(ì˜ˆ: 'a/b/c')ê°€ ì£¼ì–´ì§€ë©´ ëª¨ë“  ì¤‘ê°„ ë””ë ‰í† ë¦¬ë„ í•¨ê»˜ ìƒì„±í•©ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ìƒì„±í•  ë””ë ‰í† ë¦¬ì˜ ê²½ë¡œì…ë‹ˆë‹¤.
        exist_ok (bool, optional): ë””ë ‰í† ë¦¬ê°€ ì´ë¯¸ ì¡´ì¬í•  ë•Œ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¬ì§€
            ì—¬ë¶€ì…ë‹ˆë‹¤. Trueì´ë©´ ì˜ˆì™¸ ì—†ì´ ë„˜ì–´ê°‘ë‹ˆë‹¤. ê¸°ë³¸ê°’ì€ Trueì…ë‹ˆë‹¤.

    Returns:
        str: ì„±ê³µ ì‹œ, ìƒì„±ëœ ë””ë ‰í† ë¦¬ì˜ ì ˆëŒ€ ê²½ë¡œë¥¼ ë¬¸ìì—´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        ValueError: ì œê³µëœ ê²½ë¡œê°€ ìœ íš¨í•˜ì§€ ì•Šì€ ê°’(None ë˜ëŠ” ë¹ˆ ë¬¸ìì—´)ì¼ ê²½ìš°.
        PermissionError: ë””ë ‰í† ë¦¬ë¥¼ ìƒì„±í•  ê¶Œí•œì´ ì—†ì„ ê²½ìš°.
        FileExistsError: ê²½ë¡œì— ì´ë¯¸ íŒŒì¼ì´ ì¡´ì¬í•˜ê±°ë‚˜, `exist_ok=False`ì¸ë°
            ë””ë ‰í† ë¦¬ê°€ ì´ë¯¸ ì¡´ì¬í•  ê²½ìš°.

    Example:
        >>> new_dir_path = create_directory('./my_new_folder')
        >>> print(f"ë””ë ‰í† ë¦¬ ìƒì„± ì™„ë£Œ: {new_dir_path}")
    """
    if not path:
        raise ValueError("ë””ë ‰í† ë¦¬ ê²½ë¡œëŠ” ë¹„ì–´ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    logger.info(f"Attempting to create directory: {path}")

    try:
        dir_path = Path(path)
        dir_path.mkdir(parents=True, exist_ok=exist_ok)
        resolved_path = str(dir_path.resolve())
        logger.info(f"Successfully created or ensured directory exists: {resolved_path}")
        return resolved_path
    except PermissionError as e:
        logger.error(f"Permission denied to create directory at {path}: {e}")
        raise
    except FileExistsError as e:
        logger.error(f"Path {path} already exists and is a file, or exist_ok=False: {e}")
        raise
    except Exception as e:
        logger.critical(f"An unexpected error occurred while creating directory {path}: {e}")
        raise IOError(f"ë””ë ‰í† ë¦¬ ìƒì„± ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")


def list_directory(path: Union[str, Path]) -> List[str]:
    """ì§€ì •ëœ ë””ë ‰í† ë¦¬ì˜ íŒŒì¼ ë° í•˜ìœ„ ë””ë ‰í† ë¦¬ ëª©ë¡ì„ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ë‚´ìš©ì„ ì¡°íšŒí•  ë””ë ‰í† ë¦¬ì˜ ê²½ë¡œì…ë‹ˆë‹¤.

    Returns:
        List[str]: ë””ë ‰í† ë¦¬ ë‚´ì˜ íŒŒì¼ ë° í´ë” ì´ë¦„ ëª©ë¡ì…ë‹ˆë‹¤.

    Raises:
        ValueError: ê²½ë¡œê°€ ìœ íš¨í•˜ì§€ ì•Šì€ ê°’ì¼ ê²½ìš°.
        FileNotFoundError: ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°.
        NotADirectoryError: ì§€ì •ëœ ê²½ë¡œê°€ ë””ë ‰í† ë¦¬ê°€ ì•„ë‹ ê²½ìš°.
        PermissionError: ë””ë ‰í† ë¦¬ì— ì ‘ê·¼í•  ê¶Œí•œì´ ì—†ì„ ê²½ìš°.

    Example:
        >>> contents = list_directory('.')
        >>> print(f"í˜„ì¬ ë””ë ‰í† ë¦¬ ë‚´ìš©: {contents}")
    """
    if not path:
        raise ValueError("ë””ë ‰í† ë¦¬ ê²½ë¡œëŠ” ë¹„ì–´ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    logger.info(f"Listing contents of directory: {path}")

    dir_path = Path(path)
    if not dir_path.exists():
        raise FileNotFoundError(f"ì§€ì •ëœ ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {path}")
    if not dir_path.is_dir():
        raise NotADirectoryError(f"ì§€ì •ëœ ê²½ë¡œëŠ” ë””ë ‰í† ë¦¬ê°€ ì•„ë‹™ë‹ˆë‹¤: {path}")

    try:
        items = [item.name for item in dir_path.iterdir()]
        logger.info(f"Found {len(items)} items in {path}")
        return items
    except PermissionError as e:
        logger.error(f"Permission denied to list directory {path}: {e}")
        raise
    except Exception as e:
        logger.critical(f"An unexpected error occurred while listing directory {path}: {e}")
        raise IOError(f"ë””ë ‰í† ë¦¬ ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")


def rename(source_path: Union[str, Path], new_name: str) -> str:
    """íŒŒì¼ ë˜ëŠ” ë””ë ‰í† ë¦¬ì˜ ì´ë¦„ì„ ë³€ê²½í•©ë‹ˆë‹¤.

    Args:
        source_path (Union[str, Path]): ì´ë¦„ì„ ë³€ê²½í•  ì›ë³¸ íŒŒì¼ ë˜ëŠ” ë””ë ‰í† ë¦¬ì˜ ê²½ë¡œ.
        new_name (str): ì ìš©í•  ìƒˆë¡œìš´ ì´ë¦„ (ê²½ë¡œ í¬í•¨ ë¶ˆê°€, ìˆœìˆ˜ ì´ë¦„ë§Œ).

    Returns:
        str: ì´ë¦„ì´ ë³€ê²½ëœ í›„ì˜ ìƒˆë¡œìš´ ì ˆëŒ€ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        ValueError: ê²½ë¡œ ë˜ëŠ” ìƒˆ ì´ë¦„ì´ ìœ íš¨í•˜ì§€ ì•Šì„ ê²½ìš°.
        FileNotFoundError: ì›ë³¸ ê²½ë¡œê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°.
        FileExistsError: ë™ì¼í•œ ìœ„ì¹˜ì— ìƒˆë¡œìš´ ì´ë¦„ì˜ íŒŒì¼/ë””ë ‰í† ë¦¬ê°€ ì´ë¯¸ ì¡´ì¬í•  ê²½ìš°.
        PermissionError: ì´ë¦„ ë³€ê²½ ê¶Œí•œì´ ì—†ì„ ê²½ìš°.

    Example:
        >>> updated_path = rename('old_name.txt', 'new_name.txt')
        >>> print(f"ì´ë¦„ ë³€ê²½ ì™„ë£Œ: {updated_path}")
    """
    if not source_path or not new_name:
        raise ValueError("ì›ë³¸ ê²½ë¡œì™€ ìƒˆë¡œìš´ ì´ë¦„ì€ ë¹„ì–´ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    if '/' in new_name or '\\' in new_name:
        raise ValueError("ìƒˆ ì´ë¦„ì—ëŠ” ê²½ë¡œ êµ¬ë¶„ì('\\', '/')ë¥¼ í¬í•¨í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    logger.info(f"Attempting to rename '{source_path}' to '{new_name}'")

    src = Path(source_path)
    if not src.exists():
        raise FileNotFoundError(f"ì›ë³¸ ê²½ë¡œê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {source_path}")

    # 1. íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ë¥¼ ë¨¼ì € í™•ì¸í•˜ì—¬ FileExistsErrorë¥¼ ì§ì ‘ ë°œìƒì‹œí‚µë‹ˆë‹¤.
    dest_path = src.with_name(new_name)
    if dest_path.exists():
        raise FileExistsError(f"ëŒ€ìƒ ì´ë¦„ '{new_name}'ì´(ê°€) ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.")

    # 2. try ë¸”ë¡ì€ ì‹¤ì œ íŒŒì¼ ì‹œìŠ¤í…œ ì‘ì—…(rename)ì—ì„œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì˜ˆì™¸ë§Œ ì²˜ë¦¬í•˜ë„ë¡ í•©ë‹ˆë‹¤.
    try:
        src.rename(dest_path)
        resolved_path = str(dest_path.resolve())
        logger.info(f"Successfully renamed to: {resolved_path}")
        return resolved_path
    except PermissionError as e:
        logger.error(f"Permission denied to rename {source_path}: {e}")
        raise
    except Exception as e:
        logger.critical(f"An unexpected error occurred during rename: {e}")
        raise IOError(f"ì´ë¦„ ë³€ê²½ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")


def delete_file(path: Union[str, Path]) -> bool:
    """ì§€ì •ëœ íŒŒì¼ì„ ì‚­ì œí•©ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ì‚­ì œí•  íŒŒì¼ì˜ ê²½ë¡œì…ë‹ˆë‹¤.

    Returns:
        bool: íŒŒì¼ ì‚­ì œ ì„±ê³µ ì‹œ Trueë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        ValueError: ê²½ë¡œê°€ ìœ íš¨í•˜ì§€ ì•Šì„ ê²½ìš°.
        FileNotFoundError: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°.
        IsADirectoryError: ê²½ë¡œê°€ íŒŒì¼ì´ ì•„ë‹Œ ë””ë ‰í† ë¦¬ì¼ ê²½ìš°.
        PermissionError: íŒŒì¼ ì‚­ì œ ê¶Œí•œì´ ì—†ì„ ê²½ìš°.

    Example:
        >>> delete_file('file_to_delete.txt')
    """
    if not path:
        raise ValueError("íŒŒì¼ ê²½ë¡œëŠ” ë¹„ì–´ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    logger.info(f"Attempting to delete file: {path}")

    file_path = Path(path)
    if not file_path.exists():
        raise FileNotFoundError(f"ì‚­ì œí•  íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {path}")
    if not file_path.is_file():
        raise IsADirectoryError(f"ì‚­ì œ ëŒ€ìƒì€ íŒŒì¼ì´ì–´ì•¼ í•©ë‹ˆë‹¤ (ë””ë ‰í† ë¦¬ ê°ì§€): {path}")

    try:
        file_path.unlink()
        logger.info(f"Successfully deleted file: {path}")
        return True
    except PermissionError as e:
        logger.error(f"Permission denied to delete file {path}: {e}")
        raise
    except Exception as e:
        logger.critical(f"An unexpected error occurred while deleting file {path}: {e}")
        raise IOError(f"íŒŒì¼ ì‚­ì œ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")


def delete_empty_directory(path: Union[str, Path]) -> bool:
    """ë¹„ì–´ ìˆëŠ” ë””ë ‰í† ë¦¬ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.

    ë””ë ‰í† ë¦¬ê°€ ë¹„ì–´ìˆì§€ ì•Šì€ ê²½ìš° ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ì‚­ì œí•  ë¹„ì–´ìˆëŠ” ë””ë ‰í† ë¦¬ì˜ ê²½ë¡œì…ë‹ˆë‹¤.

    Returns:
        bool: ë””ë ‰í† ë¦¬ ì‚­ì œ ì„±ê³µ ì‹œ Trueë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        ValueError: ê²½ë¡œê°€ ìœ íš¨í•˜ì§€ ì•Šì„ ê²½ìš°.
        FileNotFoundError: ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°.
        NotADirectoryError: ê²½ë¡œê°€ ë””ë ‰í† ë¦¬ê°€ ì•„ë‹ ê²½ìš°.
        PermissionError: ë””ë ‰í† ë¦¬ ì‚­ì œ ê¶Œí•œì´ ì—†ì„ ê²½ìš°.
        OSError: ë””ë ‰í† ë¦¬ê°€ ë¹„ì–´ìˆì§€ ì•Šì„ ê²½ìš°.

    Example:
        >>> delete_empty_directory('./empty_folder')
    """
    if not path:
        raise ValueError("ë””ë ‰í† ë¦¬ ê²½ë¡œëŠ” ë¹„ì–´ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    logger.info(f"Attempting to delete empty directory: {path}")

    dir_path = Path(path)
    if not dir_path.exists():
        raise FileNotFoundError(f"ì‚­ì œí•  ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {path}")
    if not dir_path.is_dir():
        raise NotADirectoryError(f"ì‚­ì œ ëŒ€ìƒì€ ë””ë ‰í† ë¦¬ì—¬ì•¼ í•©ë‹ˆë‹¤: {path}")

    try:
        dir_path.rmdir()
        logger.info(f"Successfully deleted empty directory: {path}")
        return True
    except OSError as e:
        # Directory not empty
        logger.error(f"Failed to delete directory {path} as it is not empty: {e}")
        raise
    except PermissionError as e:
        logger.error(f"Permission denied to delete directory {path}: {e}")
        raise
    except Exception as e:
        logger.critical(f"An unexpected error occurred while deleting directory {path}: {e}")
        raise IOError(f"ë””ë ‰í† ë¦¬ ì‚­ì œ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
íŒŒì¼ ì‹œìŠ¤í…œ ë³µí•© MCP(Composite Mission Control Primitives) ëª¨ìŒ.

ì´ ëª¨ë“ˆì€ íŒŒì¼ ë° ë””ë ‰í† ë¦¬ ê´€ë¦¬ë¥¼ ìœ„í•œ ê³ ìˆ˜ì¤€ ë³µí•© ê¸°ëŠ¥ë“¤ì„ ì œê³µí•©ë‹ˆë‹¤.
ê° í•¨ìˆ˜ëŠ” ìƒì„¸í•œ ìœ íš¨ì„± ê²€ì‚¬, ì˜ˆì™¸ ì²˜ë¦¬, ë¡œê¹…ì„ í¬í•¨í•˜ì—¬ ì•ˆì •ì ì´ê³ 
ì˜ˆì¸¡ ê°€ëŠ¥í•œ ë™ì‘ì„ ë³´ì¥í•˜ë„ë¡ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.
"""

import logging
import os
import shutil
from pathlib import Path
from typing import Dict, List, Union
from .file_content_operations import read_file

# --- ë¡œê±° ì„¤ì • ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


# ==============================================================================
# 1. ì´ë™ ë° ë³µì‚¬ (Move & Copy)
# ==============================================================================

def move(source: Union[str, Path], destination: Union[str, Path]) -> str:
    """íŒŒì¼ ë˜ëŠ” ë””ë ‰í† ë¦¬ë¥¼ ë‹¤ë¥¸ ìœ„ì¹˜ë¡œ ì´ë™í•˜ê±°ë‚˜ ì´ë¦„ì„ ë³€ê²½í•©ë‹ˆë‹¤.

    `shutil.move`ë¥¼ ì‚¬ìš©í•˜ì—¬ ìš´ì˜ì²´ì œ ìˆ˜ì¤€ì—ì„œ íš¨ìœ¨ì ìœ¼ë¡œ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
    ëŒ€ìƒ ê²½ë¡œê°€ ë””ë ‰í† ë¦¬ì´ë©´ í•´ë‹¹ ë””ë ‰í† ë¦¬ ì•ˆìœ¼ë¡œ ì†ŒìŠ¤ë¥¼ ì´ë™í•©ë‹ˆë‹¤.

    Args:
        source (Union[str, Path]): ì´ë™í•  ì›ë³¸ íŒŒì¼ ë˜ëŠ” ë””ë ‰í† ë¦¬ì˜ ê²½ë¡œì…ë‹ˆë‹¤.
        destination (Union[str, Path]): ì´ë™í•  ëŒ€ìƒ ê²½ë¡œì…ë‹ˆë‹¤.

    Returns:
        str: ìµœì¢…ì ìœ¼ë¡œ ì´ë™ëœ íŒŒì¼ ë˜ëŠ” ë””ë ‰í† ë¦¬ì˜ ì ˆëŒ€ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        FileNotFoundError: ì›ë³¸ ê²½ë¡œê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
        shutil.Error: ëŒ€ìƒì´ ì´ë¯¸ ì¡´ì¬í•˜ê±°ë‚˜ ê¶Œí•œ ë¬¸ì œ ë“± ì´ë™ ì¤‘ ì˜¤ë¥˜ ë°œìƒ ì‹œ.

    Example:
        >>> # íŒŒì¼ ì´ë¦„ ë³€ê²½
        >>> move('old_name.txt', 'new_name.txt')
        '/path/to/new_name.txt'
        >>> # íŒŒì¼ì„ ë””ë ‰í† ë¦¬ë¡œ ì´ë™
        >>> move('data.csv', 'archive/')
        '/path/to/archive/data.csv'
    """
    logger.info(f"Attempting to move '{source}' to '{destination}'")
    if not Path(source).exists():
        raise FileNotFoundError(f"ì›ë³¸ ê²½ë¡œê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {source}")
    
    try:
        final_path = shutil.move(str(source), str(destination))
        logger.info(f"Successfully moved to '{final_path}'")
        return str(Path(final_path).resolve())
    except shutil.Error as e:
        logger.error(f"Failed to move '{source}': {e}")
        raise

def copy_directory(source_dir: Union[str, Path], dest_dir: Union[str, Path]) -> str:
    """ë””ë ‰í† ë¦¬ì˜ ëª¨ë“  ë‚´ìš©ì„ ì¬ê·€ì ìœ¼ë¡œ ë³µì‚¬í•©ë‹ˆë‹¤.

    `shutil.copytree`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë””ë ‰í† ë¦¬ êµ¬ì¡°ì™€ íŒŒì¼ì„ ëª¨ë‘ ë³µì‚¬í•©ë‹ˆë‹¤.
    ëŒ€ìƒ ë””ë ‰í† ë¦¬ëŠ” ì¡´ì¬í•˜ì§€ ì•Šì•„ì•¼ í•©ë‹ˆë‹¤.

    Args:
        source_dir (Union[str, Path]): ë³µì‚¬í•  ì›ë³¸ ë””ë ‰í† ë¦¬ ê²½ë¡œì…ë‹ˆë‹¤.
        dest_dir (Union[str, Path]): ë³µì‚¬ë  ëŒ€ìƒ ë””ë ‰í† ë¦¬ ê²½ë¡œì…ë‹ˆë‹¤.

    Returns:
        str: ì„±ê³µ ì‹œ, ìƒì„±ëœ ëŒ€ìƒ ë””ë ‰í† ë¦¬ì˜ ì ˆëŒ€ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        NotADirectoryError: ì›ë³¸ ê²½ë¡œê°€ ë””ë ‰í† ë¦¬ê°€ ì•„ë‹ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
        FileExistsError: ëŒ€ìƒ ë””ë ‰í† ë¦¬ê°€ ì´ë¯¸ ì¡´ì¬í•  ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
        shutil.Error: ë³µì‚¬ ì¤‘ ê¶Œí•œ ë¬¸ì œ ë“± ì˜¤ë¥˜ ë°œìƒ ì‹œ.

    Example:
        >>> copy_directory('project/src', 'project/backup/src_v1')
        '/path/to/project/backup/src_v1'
    """
    logger.info(f"Attempting to copy directory '{source_dir}' to '{dest_dir}'")
    src = Path(source_dir)
    if not src.is_dir():
        raise NotADirectoryError(f"ì›ë³¸ ê²½ë¡œëŠ” ë””ë ‰í† ë¦¬ì—¬ì•¼ í•©ë‹ˆë‹¤: {source_dir}")

    try:
        shutil.copytree(str(source_dir), str(dest_dir))
        resolved_path = str(Path(dest_dir).resolve())
        logger.info(f"Directory successfully copied to '{resolved_path}'")
        return resolved_path
    except (FileExistsError, shutil.Error) as e:
        logger.error(f"Failed to copy directory '{source_dir}': {e}")
        raise

# ==============================================================================
# 2. ê²€ìƒ‰ ë° íƒìƒ‰ (Search & Find)
# ==============================================================================

def find_files(directory: Union[str, Path], pattern: str) -> List[str]:
    """íŠ¹ì • ë””ë ‰í† ë¦¬ í•˜ìœ„ì—ì„œ íŒŒì¼ëª… íŒ¨í„´ê³¼ ì¼ì¹˜í•˜ëŠ” ëª¨ë“  íŒŒì¼ì„ ì¬ê·€ì ìœ¼ë¡œ ì°¾ìŠµë‹ˆë‹¤.

    Args:
        directory (Union[str, Path]): ê²€ìƒ‰ì„ ì‹œì‘í•  ìµœìƒìœ„ ë””ë ‰í† ë¦¬ì…ë‹ˆë‹¤.
        pattern (str): ì°¾ì„ íŒŒì¼ì˜ íŒ¨í„´ (ì˜ˆ: '*.py', 'report_*.docx').

    Returns:
        List[str]: íŒ¨í„´ê³¼ ì¼ì¹˜í•˜ëŠ” íŒŒì¼ë“¤ì˜ ì ˆëŒ€ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        NotADirectoryError: ì§€ì •ëœ ê²½ë¡œê°€ ë””ë ‰í† ë¦¬ê°€ ì•„ë‹ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> find_files('project/src', '*.py')
        ['/path/to/project/src/main.py', '/path/to/project/src/utils/helpers.py']
    """
    logger.info(f"Searching for files with pattern '{pattern}' in '{directory}'")
    dir_path = Path(directory)
    if not dir_path.is_dir():
        raise NotADirectoryError(f"ì§€ì •ëœ ê²½ë¡œëŠ” ë””ë ‰í† ë¦¬ì—¬ì•¼ í•©ë‹ˆë‹¤: {directory}")

    found_files = [str(p.resolve()) for p in dir_path.rglob(pattern) if p.is_file()]
    logger.info(f"Found {len(found_files)} matching files.")
    return found_files

def find_text_in_files(directory: Union[str, Path], text: str) -> Dict[str, List[int]]:
    """íŠ¹ì • ë””ë ‰í† ë¦¬ì˜ ëª¨ë“  í…ìŠ¤íŠ¸ íŒŒì¼ì—ì„œ ì£¼ì–´ì§„ í…ìŠ¤íŠ¸ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤.

    Args:
        directory (Union[str, Path]): ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ íŒŒì¼ì´ ìˆëŠ” ë””ë ‰í† ë¦¬ì…ë‹ˆë‹¤.
        text (str): ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ ë¬¸ìì—´ì…ë‹ˆë‹¤.

    Returns:
        Dict[str, List[int]]: {íŒŒì¼ëª…: [ì¤„ ë²ˆí˜¸]} í˜•íƒœë¡œ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        NotADirectoryError: ì§€ì •ëœ ê²½ë¡œê°€ ë””ë ‰í† ë¦¬ê°€ ì•„ë‹ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> find_text_in_files('logs/', 'ERROR')
        {'/path/to/logs/app.log': [10, 25], '/path/to/logs/db.log': [101]}
    """
    logger.info(f"Searching for text '{text}' in directory '{directory}'")
    dir_path = Path(directory)
    if not dir_path.is_dir():
        raise NotADirectoryError(f"ì§€ì •ëœ ê²½ë¡œëŠ” ë””ë ‰í† ë¦¬ì—¬ì•¼ í•©ë‹ˆë‹¤: {directory}")

    results = {}
    for file_path in dir_path.rglob('*'):
        if file_path.is_file():
            try:
                with file_path.open('r', encoding='utf-8') as f:
                    for i, line in enumerate(f, 1):
                        if text in line:
                            abs_path = str(file_path.resolve())
                            if abs_path not in results:
                                results[abs_path] = []
                            results[abs_path].append(i)
            except (UnicodeDecodeError, PermissionError):
                # ë°”ì´ë„ˆë¦¬ íŒŒì¼ì´ë‚˜ ì½ì„ ìˆ˜ ì—†ëŠ” íŒŒì¼ì€ ê±´ë„ˆëœë‹ˆë‹¤.
                logger.warning(f"Skipping non-text or unreadable file: {file_path}")
                continue
    logger.info(f"Found text in {len(results)} files.")
    return results

def find_large_files(directory: Union[str, Path], min_size_mb: int) -> List[str]:
    """ì§€ì •ëœ í¬ê¸°(MB) ì´ìƒì˜ ëŒ€ìš©ëŸ‰ íŒŒì¼ì„ ì°¾ìŠµë‹ˆë‹¤.

    Args:
        directory (Union[str, Path]): ê²€ìƒ‰ì„ ì‹œì‘í•  ë””ë ‰í† ë¦¬ì…ë‹ˆë‹¤.
        min_size_mb (int): íŒŒì¼ í¬ê¸°ì˜ ìµœì†Œ ê¸°ì¤€ (MB ë‹¨ìœ„).

    Returns:
        List[str]: ê¸°ì¤€ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì€ íŒŒì¼ë“¤ì˜ ì ˆëŒ€ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        NotADirectoryError: ì§€ì •ëœ ê²½ë¡œê°€ ë””ë ‰í† ë¦¬ê°€ ì•„ë‹ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
        ValueError: `min_size_mb`ê°€ 0ë³´ë‹¤ ì‘ì€ ìŒìˆ˜ì¼ ê²½ìš°.

    Example:
        >>> find_large_files('/data', 1024) # 1GB ì´ìƒ íŒŒì¼ ê²€ìƒ‰
        ['/data/videos/movie.mkv', '/data/db_backup.zip']
    """
    if min_size_mb < 0:
        raise ValueError("min_size_mbëŠ” 0 ì´ìƒì˜ ì •ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.")
    logger.info(f"Searching for files larger than {min_size_mb}MB in '{directory}'")
    dir_path = Path(directory)
    if not dir_path.is_dir():
        raise NotADirectoryError(f"ì§€ì •ëœ ê²½ë¡œëŠ” ë””ë ‰í† ë¦¬ì—¬ì•¼ í•©ë‹ˆë‹¤: {directory}")

    min_size_bytes = min_size_mb * 1024 * 1024
    large_files = []
    for file_path in dir_path.rglob('*'):
        if file_path.is_file():
            try:
                if file_path.stat().st_size >= min_size_bytes:
                    large_files.append(str(file_path.resolve()))
            except FileNotFoundError:
                # ì‹¬ë³¼ë¦­ ë§í¬ ë“± ìˆœíšŒ ì¤‘ íŒŒì¼ì´ ì‚¬ë¼ì§„ ê²½ìš°
                continue
    logger.info(f"Found {len(large_files)} large files.")
    return large_files

# ==============================================================================
# 3. ë‚´ìš© ì¡°ì‘ (Content Manipulation)
# ==============================================================================

def read_specific_lines(path: Union[str, Path], start_line: int, end_line: int) -> str:
    """íŒŒì¼ì˜ íŠ¹ì • ì¤„ ë²”ìœ„ë§Œ ì½ì–´ì˜µë‹ˆë‹¤. ì¤„ ë²ˆí˜¸ëŠ” 1ë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ì½ì„ íŒŒì¼ì˜ ê²½ë¡œì…ë‹ˆë‹¤.
        start_line (int): ì½ê¸° ì‹œì‘í•  ì¤„ ë²ˆí˜¸ (í¬í•¨).
        end_line (int): ì½ê¸°ë¥¼ ë§ˆì¹  ì¤„ ë²ˆí˜¸ (í¬í•¨).

    Returns:
        str: ì§€ì •ëœ ë²”ìœ„ì˜ í…ìŠ¤íŠ¸ ë‚´ìš©ì„ í•©ì¹œ ë¬¸ìì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        FileNotFoundError: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°.
        ValueError: ì¤„ ë²ˆí˜¸ê°€ ìœ íš¨í•˜ì§€ ì•Šì„ ê²½ìš° (ì˜ˆ: start > end, < 1).

    Example:
        >>> # íŒŒì¼ì˜ 10ë²ˆì§¸ë¶€í„° 20ë²ˆì§¸ ì¤„ê¹Œì§€ ì½ê¸°
        >>> content = read_specific_lines('app.log', 10, 20)
    """
    if start_line < 1 or end_line < start_line:
        raise ValueError("ì¤„ ë²ˆí˜¸ ë²”ìœ„ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ (start >= 1, end >= start).")
    logger.info(f"Reading lines {start_line}-{end_line} from '{path}'")
    
    file_path = Path(path)
    if not file_path.is_file():
        raise FileNotFoundError(f"íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {path}")

    try:
        with file_path.open('r', encoding='utf-8') as f:
            lines = f.readlines()
        
        # ìŠ¬ë¼ì´ìŠ¤ëŠ” 0-based indexì´ë¯€ë¡œ ì¡°ì •
        selected_lines = lines[start_line-1:end_line]
        return "".join(selected_lines)
    except Exception as e:
        logger.error(f"Failed to read specific lines from '{path}': {e}")
        raise

def replace_text_in_file(path: Union[str, Path], old_text: str, new_text: str) -> bool:
    """íŒŒì¼ ë‚´ì˜ íŠ¹ì • ë¬¸ìì—´ì„ ì°¾ì•„ ë‹¤ë¥¸ ë¬¸ìì—´ë¡œ ëª¨ë‘ êµì²´í•©ë‹ˆë‹¤.

    íŒŒì¼ ì „ì²´ ë‚´ìš©ì„ ë©”ëª¨ë¦¬ì— ë¡œë“œí•˜ë¯€ë¡œ ë§¤ìš° í° íŒŒì¼ì—ëŠ” ì£¼ì˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ìˆ˜ì •í•  íŒŒì¼ì˜ ê²½ë¡œì…ë‹ˆë‹¤.
        old_text (str): ë°”ê¿€ ëŒ€ìƒì´ ë˜ëŠ” ê¸°ì¡´ ë¬¸ìì—´ì…ë‹ˆë‹¤.
        new_text (str): ìƒˆë¡œ ë°”ê¿€ ë¬¸ìì—´ì…ë‹ˆë‹¤.

    Returns:
        bool: í•˜ë‚˜ ì´ìƒì˜ ë³€ê²½ì´ ë°œìƒí–ˆë‹¤ë©´ True, ë³€ê²½ì´ ì—†ì—ˆë‹¤ë©´ Falseë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        FileNotFoundError: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°.

    Example:
        >>> # ì„¤ì • íŒŒì¼ì—ì„œ DB ì£¼ì†Œ ë³€ê²½
        >>> updated = replace_text_in_file('config.ini', 'localhost', 'db.prod.server')
    """
    logger.info(f"Replacing '{old_text}' with '{new_text}' in file '{path}'")
    file_path = Path(path)
    if not file_path.is_file():
        raise FileNotFoundError(f"íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {path}")

    try:
        original_content = file_path.read_text('utf-8')
        if old_text not in original_content:
            logger.info("No text to replace. File remains unchanged.")
            return False
            
        new_content = original_content.replace(old_text, new_text)
        file_path.write_text(new_content, 'utf-8')
        logger.info("File was successfully updated.")
        return True
    except Exception as e:
        logger.error(f"Failed to replace text in '{path}': {e}")
        raise

def get_directory_size(directory: Union[str, Path]) -> int:
    """ë””ë ‰í† ë¦¬ì™€ ê·¸ í•˜ìœ„ ëª¨ë“  íŒŒì¼ì˜ ì´ í¬ê¸°ë¥¼ ë°”ì´íŠ¸ ë‹¨ìœ„ë¡œ ê³„ì‚°í•©ë‹ˆë‹¤.

    Args:
        directory (Union[str, Path]): í¬ê¸°ë¥¼ ê³„ì‚°í•  ë””ë ‰í† ë¦¬ ê²½ë¡œ.

    Returns:
        int: ë””ë ‰í† ë¦¬ì˜ ì´ í¬ê¸° (bytes).

    Raises:
        NotADirectoryError: ì§€ì •ëœ ê²½ë¡œê°€ ë””ë ‰í† ë¦¬ê°€ ì•„ë‹ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> total_bytes = get_directory_size('my_project/')
        >>> print(f"Total size: {total_bytes / (1024*1024):.2f} MB")
    """
    logger.info(f"Calculating total size of directory '{directory}'")
    dir_path = Path(directory)
    if not dir_path.is_dir():
        raise NotADirectoryError(f"ì§€ì •ëœ ê²½ë¡œëŠ” ë””ë ‰í† ë¦¬ì—¬ì•¼ í•©ë‹ˆë‹¤: {directory}")

    total_size = 0
    for entry in dir_path.rglob('*'):
        if entry.is_file():
            try:
                total_size += entry.stat().st_size
            except FileNotFoundError:
                # ìˆœíšŒ ì¤‘ íŒŒì¼ì´ ì‚­ì œëœ ê²½ìš°
                continue
    logger.info(f"Total size of '{directory}' is {total_size} bytes.")
    return total_size

# ==============================================================================
# 4. ì¼ê´„ ì²˜ë¦¬ (Batch Processing)
# ==============================================================================

def batch_rename(directory: Union[str, Path], pattern: str, new_name_format: str) -> Dict[str, str]:
    """íŠ¹ì • íŒ¨í„´ì˜ íŒŒì¼ë“¤ì„ ì°¾ì•„ ì •í•´ì§„ í˜•ì‹ìœ¼ë¡œ ì¼ê´„ ì´ë¦„ì„ ë³€ê²½í•©ë‹ˆë‹¤.

    `new_name_format`ì—ì„œ `{}`ëŠ” íŒ¨í„´ì˜ `*` ë¶€ë¶„ê³¼ ì¹˜í™˜ë©ë‹ˆë‹¤.
    ì˜ˆ: pattern='img_*.jpg', new_name_format='paris_{}.jpg'
        'img_001.jpg' -> 'paris_001.jpg'

    Args:
        directory (Union[str, Path]): ëŒ€ìƒ íŒŒì¼ë“¤ì´ ìˆëŠ” ë””ë ‰í† ë¦¬.
        pattern (str): ë³€ê²½í•  íŒŒì¼ë“¤ì„ ì°¾ëŠ” íŒ¨í„´ (e.g., 'img_*.jpg'). `*`ëŠ” í•œ ë²ˆë§Œ ì‚¬ìš© ê°€ëŠ¥.
        new_name_format (str): ìƒˆ íŒŒì¼ ì´ë¦„ í˜•ì‹. `{}`ë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.

    Returns:
        Dict[str, str]: {ì›ë³¸ ê²½ë¡œ: ìƒˆ ê²½ë¡œ} í˜•íƒœì˜ ë³€ê²½ ë‚´ì—­ ë”•ì…”ë„ˆë¦¬.

    Raises:
        NotADirectoryError: ê²½ë¡œê°€ ë””ë ‰í† ë¦¬ê°€ ì•„ë‹ ê²½ìš°.
        ValueError: íŒ¨í„´ì´ë‚˜ ìƒˆ ì´ë¦„ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆì„ ê²½ìš°.

    Example:
        >>> batch_rename('photos/', 'IMG_*.JPG', 'Vacation_{}.jpg')
        {'/path/photos/IMG_01.JPG': '/path/photos/Vacation_01.jpg'}
    """
    if '*' not in pattern or '{}' not in new_name_format:
        raise ValueError("íŒ¨í„´ì—ëŠ” '*'ê°€, ìƒˆ ì´ë¦„ í˜•ì‹ì—ëŠ” '{}'ê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.")
    if pattern.count('*') > 1:
        raise ValueError("íŒ¨í„´ì—ì„œ ì™€ì¼ë“œì¹´ë“œ '*'ëŠ” í•œ ë²ˆë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")

    logger.info(f"Starting batch rename in '{directory}' with pattern '{pattern}'")
    dir_path = Path(directory)
    if not dir_path.is_dir():
        raise NotADirectoryError(f"ì§€ì •ëœ ê²½ë¡œëŠ” ë””ë ‰í† ë¦¬ì—¬ì•¼ í•©ë‹ˆë‹¤: {directory}")

    prefix, suffix = pattern.split('*')
    renamed_files = {}

    for old_path in dir_path.glob(pattern):
        if old_path.is_file():
            name = old_path.name
            # `*`ì— í•´ë‹¹í•˜ëŠ” ë¶€ë¶„ ì¶”ì¶œ
            wildcard_part = name.removeprefix(prefix).removesuffix(suffix)
            
            new_name = new_name_format.format(wildcard_part)
            new_path = old_path.with_name(new_name)

            if new_path.exists():
                logger.warning(f"Skipping rename for '{old_path}' because target '{new_path}' already exists.")
                continue

            old_path.rename(new_path)
            renamed_files[str(old_path)] = str(new_path)
            logger.info(f"Renamed '{old_path}' to '{new_path}'")
            
    return renamed_files

def delete_directory_recursively(path: Union[str, Path]) -> str:
    """ë¹„ì–´ìˆì§€ ì•Šì€ ë””ë ‰í† ë¦¬ì™€ ê·¸ ì•ˆì˜ ëª¨ë“  í•˜ìœ„ íŒŒì¼/ë””ë ‰í† ë¦¬ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.

    ë§¤ìš° íŒŒê´´ì ì¸ ì‘ì—…ì´ë¯€ë¡œ ì‚¬ìš©ì— ê·¹ë„ì˜ ì£¼ì˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.

    Args:
        path (Union[str, Path]): ì‚­ì œí•  ë””ë ‰í† ë¦¬ì˜ ê²½ë¡œ.

    Returns:
        str: ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆë‹¤ëŠ” ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        NotADirectoryError: ì§€ì •ëœ ê²½ë¡œê°€ ë””ë ‰í† ë¦¬ê°€ ì•„ë‹ ê²½ìš°.
        PermissionError: ê¶Œí•œì´ ì—†ì–´ ì‚­ì œì— ì‹¤íŒ¨í•  ê²½ìš°.

    Example:
        >>> # ì ˆëŒ€ ì‚¬ìš©ì— ì£¼ì˜!
        >>> delete_directory_recursively('/tmp/obsolete_data')
        'Directory /tmp/obsolete_data and all its contents have been deleted.'
    """
    logger.warning(f"Attempting to recursively delete directory: {path}. This is a destructive operation.")
    dir_path = Path(path)
    if not dir_path.is_dir():
        raise NotADirectoryError(f"ì§€ì •ëœ ê²½ë¡œëŠ” ë””ë ‰í† ë¦¬ì—¬ì•¼ í•©ë‹ˆë‹¤: {path}")

    try:
        shutil.rmtree(dir_path)
        message = f"Directory {dir_path} and all its contents have been deleted."
        logger.info(message)
        return message
    except PermissionError as e:
        logger.error(f"Permission denied while trying to delete {path}: {e}")
        raise
    except Exception as e:
        logger.critical(f"Unexpected error while deleting {path}: {e}")
        raise

def read_multiple_files(file_paths: List[str]) -> str:
    """
    ì—¬ëŸ¬ ê°œì˜ í…ìŠ¤íŠ¸ íŒŒì¼ ê²½ë¡œë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë°›ì•„,
    ê° íŒŒì¼ì˜ ë‚´ìš©ì„ ì½ì–´ í•˜ë‚˜ì˜ ë¬¸ìì—´ë¡œ ê²°í•©í•©ë‹ˆë‹¤.
    AIê°€ ì½”ë“œë² ì´ìŠ¤ ì „ì²´ë¥¼ ë¶„ì„í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.

    Args:
        file_paths (List[str]): ì½ì–´ì˜¬ íŒŒì¼ë“¤ì˜ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸.

    Returns:
        str: ê° íŒŒì¼ì˜ ë‚´ìš©ì´ íŒŒì¼ëª… í—¤ë”ì™€ í•¨ê»˜ ê²°í•©ëœ ë‹¨ì¼ ë¬¸ìì—´.

    Raises:
        FileNotFoundError: ë¦¬ìŠ¤íŠ¸ì˜ íŒŒì¼ ì¤‘ í•˜ë‚˜ë¼ë„ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ë°œìƒ.
        IOError: íŒŒì¼ ì½ê¸° ì¤‘ ì˜¤ë¥˜ ë°œìƒ ì‹œ.
    """
    logger.info(f"{len(file_paths)}ê°œì˜ íŒŒì¼ ë‚´ìš©ì„ ì½ê¸° ì‹œì‘í•©ë‹ˆë‹¤.")
    combined_content = ""

    # AIê°€ íŒŒì¼ ë§¥ë½ì„ êµ¬ë¶„í•  ìˆ˜ ìˆë„ë¡ íŒŒì¼ëª… í—¤ë”ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
    for file_path in file_paths:
        try:
            content = read_file(file_path) # ê¸°ì¡´ Atomic MCP ì¬ì‚¬ìš©
            combined_content += f"\n--- START OF {file_path} ---\n"
            combined_content += content
            combined_content += f"\n--- END OF {file_path} ---\n"
        except Exception as e:
            logger.warning(f"'{file_path}' íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: {e}. ê±´ë„ˆëœë‹ˆë‹¤.")
            combined_content += f"\n--- FAILED TO READ {file_path}: {e} ---\n"

    logger.info("ëª¨ë“  íŒŒì¼ ì½ê¸° ë° ê²°í•© ì™„ë£Œ.")
    return combined_content
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# mcp_modules/gemini_atomic.py

import os
import logging
import google.generativeai as genai
from dotenv import load_dotenv
from typing import Optional

# ë¡œê±° ì„¤ì •
logger = logging.getLogger(__name__)

# í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
load_dotenv()
genai.configure(api_key=os.getenv("GEMINI_API_KEY"))

# ëª¨ë¸ ì„¤ì •
DEFAULT_MODEL = "gemini-1.5-flash-latest"

def ask_gemini(
    prompt: str, 
    system_instruction: Optional[str] = None, 
    model_name: str = "auto",
    temperature: float = 0.7
) -> str:
    """
    Gemini AI ëª¨ë¸ì—ê²Œ ì§ˆë¬¸í•˜ê³  ì‘ë‹µì„ ë°›ìŠµë‹ˆë‹¤.
    CLI, Orchestrator, ë‹¤ë¥¸ MCPì—ì„œ ê³µí†µìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” Atomic functionì…ë‹ˆë‹¤.

    Args:
        prompt (str): AIì—ê²Œ ë³´ë‚¼ ì‚¬ìš©ì ì§ˆë¬¸ ë˜ëŠ” ì‘ì—… ë‚´ìš©.
        system_instruction (str, optional): ì‹œìŠ¤í…œ í˜ë¥´ì†Œë‚˜ ì„¤ì • (shared/prompt_manager ì‚¬ìš© ê¶Œì¥).
        model_name (str, optional): ì‚¬ìš©í•  ëª¨ë¸ ('auto', 'high', 'standard' ë˜ëŠ” êµ¬ì²´ì  ëª¨ë¸ëª…).
        temperature (float, optional): ì°½ì˜ì„± ì¡°ì ˆ (0.0 ~ 1.0).

    Returns:
        str: AIì˜ ì‘ë‹µ í…ìŠ¤íŠ¸.
    """
    logger.info(f"Gemini ìš”ì²­: {prompt[:50]}... (Model: {model_name})")
    
    # ëª¨ë¸ ì„ íƒ ë¡œì§
    target_model_name = DEFAULT_MODEL
    if model_name == "high":
        target_model_name = os.getenv("GEMINI_HIGH_PERF_MODEL", "gemini-1.5-pro-latest")
    elif model_name == "standard" or model_name == "auto":
        target_model_name = os.getenv("GEMINI_STANDARD_MODEL", "gemini-1.5-flash-latest")
    elif model_name:
        target_model_name = model_name

    try:
        # ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ì ìš©ì„ ìœ„í•œ ëª¨ë¸ ìƒì„±
        model = genai.GenerativeModel(
            model_name=target_model_name,
            system_instruction=system_instruction
        )
        
        response = model.generate_content(
            prompt,
            generation_config=genai.types.GenerationConfig(
                temperature=temperature
            )
        )
        
        if response.text:
            logger.info("Gemini ì‘ë‹µ ìˆ˜ì‹  ì„±ê³µ.")
            return response.text.strip()
        else:
            logger.warning("Gemini ì‘ë‹µì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.")
            return "ì‘ë‹µì„ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."

    except Exception as e:
        logger.error(f"Gemini API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return f"AI ìš”ì²­ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}"
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
git_version_control.py

Git ë²„ì „ ê´€ë¦¬ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” MCP(Mission Control Primitive) ëª¨ìŒì…ë‹ˆë‹¤.
ì´ ëª¨ë“ˆì€ ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œì—ì„œ Git ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•˜ì—¬ ì €ì¥ì†Œ ìƒì„±, ë³µì œ,
ìƒíƒœ í™•ì¸, ì»¤ë°‹, í‘¸ì‹œ, í’€ ë“±ì˜ í•µì‹¬ ê¸°ëŠ¥ì„ ì•ˆì „í•˜ê²Œ ë˜í•‘í•©ë‹ˆë‹¤.
"""

import logging
import os
import re
import subprocess
import shlex
from typing import List, Optional

# --- ë¡œê±° ì„¤ì • ---
# ì´ ëª¨ë“ˆì„ ì‚¬ìš©í•˜ëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ë¡œê¹… ì„¤ì •ì„ êµ¬ì„±í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.
# ê¸°ë³¸ ë¡œê±°ê°€ ì„¤ì •ë˜ì§€ ì•Šì€ ê²½ìš°ë¥¼ ëŒ€ë¹„í•œ ê¸°ë³¸ ì„¤ì •ì…ë‹ˆë‹¤.
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# --- ì‚¬ìš©ì ì •ì˜ ì˜ˆì™¸ ---
class GitCommandError(Exception):
    """Git ëª…ë ¹ì–´ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì„ ë•Œ ì‚¬ìš©ë˜ëŠ” ì‚¬ìš©ì ì •ì˜ ì˜ˆì™¸ì…ë‹ˆë‹¤."""
    def __init__(self, message, stderr=None):
        super().__init__(message)
        self.stderr = stderr

    def __str__(self):
        if self.stderr:
            return f"{super().__str__()}\n--- Git Error ---\n{self.stderr}"
        return super().__str__()

# --- í—¬í¼ í•¨ìˆ˜ ---
def _is_valid_git_ref_name(name: str) -> bool:
    """
    ë¸Œëœì¹˜ë‚˜ íƒœê·¸ ì´ë¦„ì´ Gitì˜ ê·œì¹™ì— ë§ëŠ”ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
    ê·œì¹™: ê³µë°±ì´ë‚˜ ASCII ì œì–´ ë¬¸ìë¥¼ í¬í•¨í•˜ì§€ ì•Šìœ¼ë©°, íŠ¹ì • íŠ¹ìˆ˜ë¬¸ìë¡œ ì‹œì‘í•˜ê±°ë‚˜ ëë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
    """
    # Git refname ê·œì¹™ì„ ë‹¨ìˆœí™”í•˜ì—¬ ì¼ë°˜ì ì¸ ì¼€ì´ìŠ¤ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.
    # ê³µë°±, ì´ì¤‘ ì (..), ì—­ìŠ¬ë˜ì‹œ(\) ë“±ì„ í¬í•¨í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
    if " " in name or ".." in name or "\\" in name:
        return False
    # ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ì•ˆì „í•œ ë¬¸ìì…‹(ì˜ìˆ«ì, '-', '_', '/', '.')ìœ¼ë¡œ ì œí•œí•©ë‹ˆë‹¤.
    if not re.match(r'^[a-zA-Z0-9/._-]+$', name):
        return False
    return True

def _is_valid_commit_hash(hash_str: str) -> bool:
    """ commit í•´ì‹œê°€ ìœ íš¨í•œ í˜•ì‹ì¸ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤. (40ìë¦¬ì˜ 16ì§„ìˆ˜ ë¬¸ìì—´) """
    return bool(re.match(r'^[0-9a-f]{7,40}$', hash_str))

# (ìˆ˜ì •) ì¤‘ë³µëœ _run_git_command í•¨ìˆ˜ 1ê°œ ì‚­ì œ
# def _run_git_command(command: List[str]) -> str: ... (ì‚­ì œë¨)

def _run_git_command(command: List[str], cwd: str) -> str:
    """
    ì§€ì •ëœ ì‘ì—… ë””ë ‰í† ë¦¬ì—ì„œ Git ëª…ë ¹ì–´ë¥¼ ì•ˆì „í•˜ê²Œ ì‹¤í–‰í•˜ê³  ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        command (List[str]): ì‹¤í–‰í•  Git ëª…ë ¹ì–´ì™€ ì¸ìë“¤ì˜ ë¦¬ìŠ¤íŠ¸.
        cwd (str): ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•  ë””ë ‰í† ë¦¬ ê²½ë¡œ.

    Returns:
        str: ëª…ë ¹ì–´ ì‹¤í–‰ ê²°ê³¼(stdout).

    Raises:
        GitCommandError: ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨ ì‹œ ë°œìƒ.
        FileNotFoundError: ì‘ì—… ë””ë ‰í† ë¦¬(cwd)ê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš° ë°œìƒ.
    """
    if not os.path.isdir(cwd):
        raise FileNotFoundError(f"ì‘ì—… ë””ë ‰í† ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {cwd}")

    try:
        logger.info(f"'{cwd}'ì—ì„œ Git ëª…ë ¹ì–´ ì‹¤í–‰: {' '.join(command)}")
        # shell=False (ê¸°ë³¸ê°’)ëŠ” ì…¸ ì¸ì ì…˜ ê³µê²©ì„ ë°©ì§€í•©ë‹ˆë‹¤.
        process = subprocess.run(
            command,
            cwd=cwd,
            check=True,  # ë°˜í™˜ ì½”ë“œê°€ 0ì´ ì•„ë‹ˆë©´ CalledProcessError ë°œìƒ
            capture_output=True,
            text=True,
            encoding='utf-8'
        )
        logger.info(f"ëª…ë ¹ì–´ ì„±ê³µ: {' '.join(command)}")
        return process.stdout.strip()
    except subprocess.CalledProcessError as e:
        error_message = f"Git ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨: {' '.join(command)}"
        logger.error(f"{error_message}\nstderr: {e.stderr.strip()}")
        raise GitCommandError(error_message, stderr=e.stderr.strip()) from e
    except Exception as e:
        error_message = f"Git ëª…ë ¹ì–´ ì‹¤í–‰ ì¤‘ ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜ ë°œìƒ: {' '.join(command)}"
        logger.error(error_message, exc_info=True)
        raise GitCommandError(error_message) from e


# --- MCP í•¨ìˆ˜ë“¤ ---

def git_init(path: str) -> str:
    """
    ì§€ì •ëœ ê²½ë¡œì— ìƒˆë¡œìš´ Git ì €ì¥ì†Œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.

    Args:
        path (str): Git ì €ì¥ì†Œë¥¼ ì´ˆê¸°í™”í•  ë””ë ‰í† ë¦¬ ê²½ë¡œ. ë””ë ‰í† ë¦¬ê°€ ì—†ë‹¤ë©´ ìƒì„±ë©ë‹ˆë‹¤.

    Returns:
        str: ì„±ê³µ ì‹œ, ì´ˆê¸°í™”ëœ ì €ì¥ì†Œì˜ ì ˆëŒ€ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        GitCommandError: 'git init' ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨ ì‹œ ë°œìƒí•©ë‹ˆë‹¤.
        OSError: ë””ë ‰í† ë¦¬ ìƒì„±ì— ì‹¤íŒ¨í–ˆì„ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> import tempfile
        >>> with tempfile.TemporaryDirectory() as tmpdir:
        ...     repo_path = git_init(tmpdir)
        ...     print(os.path.isdir(os.path.join(repo_path, '.git')))
        True
    """
    logger.info(f"'{path}' ê²½ë¡œì— Git ì €ì¥ì†Œ ì´ˆê¸°í™”ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.")
    try:
        # ëŒ€ìƒ ë””ë ‰í† ë¦¬ê°€ ì—†ìœ¼ë©´ ìƒì„± (exist_ok=Trueë¡œ ë©±ë“±ì„± ë³´ì¥)
        os.makedirs(path, exist_ok=True)
    except OSError as e:
        logger.error(f"ë””ë ‰í† ë¦¬ ìƒì„± ì‹¤íŒ¨: {path}", exc_info=True)
        raise

    command = ['git', 'init']
    _run_git_command(command, cwd=path)
    abs_path = os.path.abspath(path)
    logger.info(f"ì„±ê³µì ìœ¼ë¡œ Git ì €ì¥ì†Œë¥¼ ì´ˆê¸°í™”í–ˆìŠµë‹ˆë‹¤: {abs_path}")
    return abs_path

def git_clone(repo_url: str, local_path: str) -> str:
    """
    ì›ê²© ì €ì¥ì†Œë¥¼ ì§€ì •ëœ ë¡œì»¬ ê²½ë¡œë¡œ ë³µì œ(clone)í•©ë‹ˆë‹¤.

    Args:
        repo_url (str): ë³µì œí•  ì›ê²© Git ì €ì¥ì†Œì˜ URL.
        local_path (str): ì €ì¥ì†Œë¥¼ ë³µì œí•  ë¡œì»¬ ë””ë ‰í† ë¦¬ ê²½ë¡œ.

    Returns:
        str: ì„±ê³µ ì‹œ, ë³µì œëœ ë¡œì»¬ ì €ì¥ì†Œì˜ ì ˆëŒ€ ê²½ë¡œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        GitCommandError: 'git clone' ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨ ì‹œ ë°œìƒí•©ë‹ˆë‹¤.
        ValueError: local_pathê°€ ë¹„ì–´ìˆì§€ ì•Šì€ ë””ë ‰í† ë¦¬ì¼ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> import tempfile
        >>> with tempfile.TemporaryDirectory() as tmpdir:
        ...     # ì´ ì˜ˆì œëŠ” ì‹¤ì œ ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ ì‹œë„í•˜ë¯€ë¡œ í…ŒìŠ¤íŠ¸ ì‹œ ì£¼ì˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.
        ...     # repo_path = git_clone("https://github.com/git/git.git", tmpdir)
        ...     # print(os.path.isdir(os.path.join(repo_path, '.git')))
        ...     pass # ì‹¤ì œ ì‹¤í–‰ ë°©ì§€ë¥¼ ìœ„í•´ pass
    """
    logger.info(f"'{repo_url}'ì„(ë¥¼) '{local_path}'(ìœ¼)ë¡œ ë³µì œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.")
    # ë³´ì•ˆ: local_pathì— íŒŒì¼ì´ ìˆìœ¼ë©´ Gitì´ ì˜¤ë¥˜ë¥¼ ë‚´ì§€ë§Œ, ë¯¸ë¦¬ í™•ì¸í•˜ì—¬ ëª…í™•í•œ ì˜¤ë¥˜ ì œê³µ
    if os.path.exists(local_path) and os.listdir(local_path):
        raise ValueError(f"ëŒ€ìƒ ê²½ë¡œ '{local_path}'ê°€ ë¹„ì–´ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.")

    # cloneì€ íŠ¹ì • ë””ë ‰í† ë¦¬ 'ë‚´ë¶€'ê°€ ì•„ë‹ˆë¼ 'ìƒìœ„' ë””ë ‰í† ë¦¬ì—ì„œ ì‹¤í–‰í•´ì•¼ í•¨.
    parent_dir = os.path.dirname(local_path)
    repo_name = os.path.basename(local_path)

    if not parent_dir:
        parent_dir = "." # í˜„ì¬ ë””ë ‰í† ë¦¬

    os.makedirs(parent_dir, exist_ok=True)

    # ë³´ì•ˆ: repo_url ì¸ìëŠ” ëª…ë ¹ì–´ ë¦¬ìŠ¤íŠ¸ì— ë¶„ë¦¬í•˜ì—¬ ì „ë‹¬, ì…¸ ì¸ì ì…˜ ë°©ì§€
    command = ['git', 'clone', repo_url, repo_name]
    _run_git_command(command, cwd=parent_dir)
    abs_path = os.path.abspath(local_path)
    logger.info(f"ì„±ê³µì ìœ¼ë¡œ ì €ì¥ì†Œë¥¼ ë³µì œí–ˆìŠµë‹ˆë‹¤: {abs_path}")
    return abs_path

def git_status(repo_path: str) -> str:
    """
    í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬ì˜ Git ìƒíƒœë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): Git ìƒíƒœë¥¼ í™•ì¸í•  ì €ì¥ì†Œì˜ ê²½ë¡œ.

    Returns:
        str: 'git status' ëª…ë ¹ì–´ì˜ ì „ì²´ ì¶œë ¥ ë¬¸ìì—´.

    Raises:
        GitCommandError: 'git status' ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨ ì‹œ ë°œìƒí•©ë‹ˆë‹¤.
        FileNotFoundError: repo_pathê°€ ìœ íš¨í•œ ë””ë ‰í† ë¦¬ê°€ ì•„ë‹ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> # repo_path = git_init('./my-test-repo')
        >>> # status = git_status(repo_path)
        >>> # assert 'On branch' in status
        >>> pass
    """
    logger.info(f"'{repo_path}'ì˜ Git ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.")
    command = ['git', 'status']
    status_output = _run_git_command(command, cwd=repo_path)
    logger.debug(f"Git ìƒíƒœ:\n{status_output}")
    return status_output

def git_add(repo_path: str, files: List[str]) -> None:
    """
    íŠ¹ì • íŒŒì¼ ëª©ë¡ì„ ìŠ¤í…Œì´ì§•(staging) ì˜ì—­ì— ì¶”ê°€í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        files (List[str]): ìŠ¤í…Œì´ì§•í•  íŒŒì¼ë“¤ì˜ ë¦¬ìŠ¤íŠ¸. '.'ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ë³€ê²½ì‚¬í•­ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

    Returns:
        None: ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ë©´ ì•„ë¬´ê²ƒë„ ë°˜í™˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

    Raises:
        GitCommandError: 'git add' ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨ ì‹œ ë°œìƒí•©ë‹ˆë‹¤.
        ValueError: íŒŒì¼ ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì–´ìˆì„ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> # repo_path = git_init('./my-test-repo')
        >>> # with open(os.path.join(repo_path, 'test.txt'), 'w') as f:
        ... #     f.write('hello')
        >>> # git_add(repo_path, ['test.txt'])
        >>> pass
    """
    if not files:
        raise ValueError("ìŠ¤í…Œì´ì§•í•  íŒŒì¼ì´ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

    logger.info(f"'{repo_path}'ì—ì„œ íŒŒì¼ ìŠ¤í…Œì´ì§•: {files}")
    # ë³´ì•ˆ: íŒŒì¼ ì´ë¦„ì— ê³µë°±ì´ë‚˜ íŠ¹ìˆ˜ë¬¸ìê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ shlex.quote ëŒ€ì‹  ë¦¬ìŠ¤íŠ¸ë¡œ ì „ë‹¬
    command = ['git', 'add'] + files
    _run_git_command(command, cwd=repo_path)
    logger.info("íŒŒì¼ì„ ì„±ê³µì ìœ¼ë¡œ ìŠ¤í…Œì´ì§•í–ˆìŠµë‹ˆë‹¤.")


def git_commit(repo_path: str, message: str) -> str:
    """
    ìŠ¤í…Œì´ì§•ëœ ë³€ê²½ ì‚¬í•­ë“¤ì„ ë©”ì‹œì§€ì™€ í•¨ê»˜ ì»¤ë°‹í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        message (str): ì»¤ë°‹ì— ì‚¬ìš©í•  ë©”ì‹œì§€.

    Returns:
        str: 'git commit' ëª…ë ¹ì–´ì˜ ê²°ê³¼ ë©”ì‹œì§€ (ë³´í†µ ì»¤ë°‹ ìš”ì•½ ì •ë³´).

    Raises:
        GitCommandError: 'git commit' ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨ ì‹œ ë°œìƒí•©ë‹ˆë‹¤.
        ValueError: ì»¤ë°‹ ë©”ì‹œì§€ê°€ ë¹„ì–´ìˆì„ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> # ... git_add ì‹¤í–‰ í›„ ...
        >>> # commit_result = git_commit(repo_path, "ì²« ë²ˆì§¸ ì»¤ë°‹")
        >>> # assert '1 file changed' in commit_result
        >>> pass
    """
    if not message.strip():
        raise ValueError("ì»¤ë°‹ ë©”ì‹œì§€ëŠ” ë¹„ì–´ ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    logger.info(f"'{repo_path}'ì—ì„œ ì»¤ë°‹ ìƒì„±: {message}")
    # ë³´ì•ˆ: ë©”ì‹œì§€ ì¸ìëŠ” ëª…ë ¹ì–´ ë¦¬ìŠ¤íŠ¸ì— ë¶„ë¦¬í•˜ì—¬ ì „ë‹¬
    command = ['git', 'commit', '-m', message]
    result = _run_git_command(command, cwd=repo_path)
    logger.info("ì„±ê³µì ìœ¼ë¡œ ì»¤ë°‹í–ˆìŠµë‹ˆë‹¤.")
    return result

def git_push(repo_path: str, remote: str = "origin", branch: str = "main") -> str:
    """
    ë¡œì»¬ ì»¤ë°‹ì„ ì›ê²© ì €ì¥ì†Œë¡œ í‘¸ì‹œí•©ë‹ˆë‹¤.

    ê²½ê³ : ì´ ê¸°ëŠ¥ì€ ì›ê²© ì €ì¥ì†Œì˜ ìƒíƒœë¥¼ ë³€ê²½í•˜ë©° ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì´ í•„ìš”í•©ë‹ˆë‹¤.
          ì¸ì¦ ì •ë³´(SSH í‚¤, ì‚¬ìš©ì ì´ë¦„/ë¹„ë°€ë²ˆí˜¸)ê°€ ì‹œìŠ¤í…œì— ì‚¬ì „ ì„¤ì •ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        remote (str, optional): í‘¸ì‹œí•  ì›ê²© ì €ì¥ì†Œì˜ ì´ë¦„. ê¸°ë³¸ê°’ì€ 'origin'.
        branch (str, optional): í‘¸ì‹œí•  ë¸Œëœì¹˜ì˜ ì´ë¦„. ê¸°ë³¸ê°’ì€ 'main'.

    Returns:
        str: 'git push' ëª…ë ¹ì–´ì˜ ê²°ê³¼ ë©”ì‹œì§€.

    Raises:
        GitCommandError: 'git push' ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨ ì‹œ ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> # ... ì›ê²© ì €ì¥ì†Œ ì„¤ì • í›„ ...
        >>> # push_result = git_push(repo_path, 'origin', 'main')
        >>> pass
    """
    logger.warning(f"'{repo_path}'ì—ì„œ ì›ê²© ì €ì¥ì†Œ '{remote}/{branch}'(ìœ¼)ë¡œ í‘¸ì‹œë¥¼ ì‹œë„í•©ë‹ˆë‹¤. ì›ê²© ìƒíƒœê°€ ë³€ê²½ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
    command = ["git", "push", remote, branch]
    try:
        # check=Trueë¥¼ ì‚¬ìš©í•˜ë©´ ì‹¤íŒ¨ ì‹œ CalledProcessErrorê°€ ìë™ìœ¼ë¡œ ë°œìƒí•©ë‹ˆë‹¤.
        result = subprocess.run(
            command, 
            capture_output=True, 
            text=True, 
            cwd=repo_path, 
            check=True # ì´ ì˜µì…˜ì´ ì¤‘ìš”í•©ë‹ˆë‹¤!
        )
        # ì„±ê³µ ë©”ì‹œì§€ëŠ” stderrì— ìˆì„ ê°€ëŠ¥ì„±ì´ ë†’ìŒ
        return result.stderr.strip()
    except subprocess.CalledProcessError as e:
        # Git ëª…ë ¹ì–´ ì‹¤íŒ¨ ì‹œ, ì¡ì€ ì˜ˆì™¸ë¥¼ ìš°ë¦¬ì˜ ì»¤ìŠ¤í…€ ì˜ˆì™¸ë¡œ ë³€í™˜í•˜ì—¬ ë‹¤ì‹œ ë°œìƒì‹œí‚µë‹ˆë‹¤.
        # e.stderrì— Gitì˜ ì‹¤ì œ ì—ëŸ¬ ë©”ì‹œì§€ê°€ ë‹´ê²¨ ìˆìŠµë‹ˆë‹¤.
        raise GitCommandError(f"Git push ì‹¤íŒ¨: {e.stderr.strip()}") from e

def git_pull(repo_path: str, remote: str = "origin", branch: str = "main") -> str:
    """
    ì›ê²© ì €ì¥ì†Œì˜ ìµœì‹  ë³€ê²½ ì‚¬í•­ì„ ê°€ì ¸ì™€ í˜„ì¬ ë¸Œëœì¹˜ì— ë³‘í•©(pull)í•©ë‹ˆë‹¤.

    ê²½ê³ : ì´ ê¸°ëŠ¥ì€ ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œì˜ ë‚´ìš©ì„ ë³€ê²½í•˜ë©° ì¶©ëŒ(conflict)ì„ ìœ ë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
          ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì´ í•„ìš”í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        remote (str, optional): í’€(pull)í•  ì›ê²© ì €ì¥ì†Œì˜ ì´ë¦„. ê¸°ë³¸ê°’ì€ 'origin'.
        branch (str, optional): í’€(pull)í•  ë¸Œëœì¹˜ì˜ ì´ë¦„. ê¸°ë³¸ê°’ì€ 'main'.

    Returns:
        str: 'git pull' ëª…ë ¹ì–´ì˜ ê²°ê³¼ ë©”ì‹œì§€.

    Raises:
        GitCommandError: 'git pull' ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨ ì‹œ ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> # ... ì›ê²© ì €ì¥ì†Œì— ë³€ê²½ì‚¬í•­ì´ ìˆì„ ê²½ìš° ...
        >>> # pull_result = git_pull(repo_path, 'origin', 'main')
        >>> pass
    """
    logger.warning(f"'{repo_path}'ì—ì„œ ì›ê²© ì €ì¥ì†Œ '{remote}/{branch}'ì˜ ë³€ê²½ì‚¬í•­ì„ í’€(pull)í•©ë‹ˆë‹¤. ë¡œì»¬ íŒŒì¼ì´ ë³€ê²½ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
    command = ['git', 'pull', remote, branch]
    result = _run_git_command(command, cwd=repo_path)
    logger.info(f"ì„±ê³µì ìœ¼ë¡œ '{remote}/{branch}'ì—ì„œ í’€(pull)í–ˆìŠµë‹ˆë‹¤.")
    return result

def git_fetch(repo_path: str, remote: str = "origin") -> str:
    """
    ì›ê²© ì €ì¥ì†Œì˜ ìµœì‹  ë‚´ì—­ì„ ê°€ì ¸ì˜¤ì§€ë§Œ, ë¡œì»¬ ë¸Œëœì¹˜ì— ë³‘í•©ì€ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤(fetch).

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        remote (str, optional): í˜ì¹˜(fetch)í•  ì›ê²© ì €ì¥ì†Œì˜ ì´ë¦„. ê¸°ë³¸ê°’ì€ 'origin'.

    Returns:
        str: 'git fetch' ëª…ë ¹ì–´ì˜ ê²°ê³¼ ë©”ì‹œì§€ (ë³´í†µ ë¹ˆ ë¬¸ìì—´).

    Raises:
        GitCommandError: 'git fetch' ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨ ì‹œ ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> # ... ì›ê²© ì €ì¥ì†Œì— ë³€ê²½ì‚¬í•­ì´ ìˆì„ ê²½ìš° ...
        >>> # fetch_result = git_fetch(repo_path, 'origin')
        >>> pass
    """
    logger.info(f"'{repo_path}'ì—ì„œ ì›ê²© ì €ì¥ì†Œ '{remote}'ì˜ ë‚´ì—­ì„ í˜ì¹˜(fetch)í•©ë‹ˆë‹¤.")
    command = ['git', 'fetch', remote]
    result = _run_git_command(command, cwd=repo_path)
    logger.info(f"ì„±ê³µì ìœ¼ë¡œ '{remote}'ì—ì„œ í˜ì¹˜(fetch)í–ˆìŠµë‹ˆë‹¤.")
    return result

# (ìˆ˜ì •) ì¼ê´€ì„±ì„ ìœ„í•´ cwd: str = "." ëŒ€ì‹  repo_path: str ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
def git_create_branch(repo_path: str, branch_name: str):
    """
    ì§€ì •ëœ ì €ì¥ì†Œì— ìƒˆë¡œìš´ ë¡œì»¬ ë¸Œëœì¹˜ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        branch_name (str): ìƒì„±í•  ë¸Œëœì¹˜ì˜ ì´ë¦„.

    Raises:
        ValueError: ë¸Œëœì¹˜ ì´ë¦„ì´ ìœ íš¨í•˜ì§€ ì•Šì€ í˜•ì‹ì¼ ë•Œ ë°œìƒí•©ë‹ˆë‹¤.
        subprocess.CalledProcessError: Git ëª…ë ¹ì–´ ì‹¤í–‰ì— ì‹¤íŒ¨í–ˆì„ ë•Œ ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> git_create_branch("./my-repo", "feature/new-login-page")
    """
    if not _is_valid_git_ref_name(branch_name):
        raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ ë¸Œëœì¹˜ ì´ë¦„ì…ë‹ˆë‹¤: '{branch_name}'")
    _run_git_command(["git", "branch", branch_name], cwd=repo_path)
    logger.info(f"ì„±ê³µì ìœ¼ë¡œ ë¸Œëœì¹˜ë¥¼ ìƒì„±í–ˆìŠµë‹ˆë‹¤: {branch_name}")


# (ìˆ˜ì •) ì¼ê´€ì„±ì„ ìœ„í•´ cwd: str = "." ëŒ€ì‹  repo_path: str ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
def git_switch_branch(repo_path: str, branch_name: str):
    """
    ì§€ì •ëœ ì €ì¥ì†Œì˜ ë¸Œëœì¹˜ë¡œ ì „í™˜í•©ë‹ˆë‹¤. (git switch ì‚¬ìš©)

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        branch_name (str): ì „í™˜í•  ë¸Œëœì¹˜ì˜ ì´ë¦„.

    Raises:
        ValueError: ë¸Œëœì¹˜ ì´ë¦„ì´ ìœ íš¨í•˜ì§€ ì•Šì€ í˜•ì‹ì¼ ë•Œ ë°œìƒí•©ë‹ˆë‹¤.
        subprocess.CalledProcessError: ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë¸Œëœì¹˜ ë“±ìœ¼ë¡œ ì „í™˜ì— ì‹¤íŒ¨í–ˆì„ ë•Œ ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> git_switch_branch("./my-repo", "main")
    """
    if not _is_valid_git_ref_name(branch_name):
        raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ ë¸Œëœì¹˜ ì´ë¦„ì…ë‹ˆë‹¤: '{branch_name}'")
    _run_git_command(["git", "switch", branch_name], cwd=repo_path)
    logger.info(f"ì„±ê³µì ìœ¼ë¡œ ë¸Œëœì¹˜ë¥¼ ì „í™˜í–ˆìŠµë‹ˆë‹¤: {branch_name}")


# (ìˆ˜ì •) ì¼ê´€ì„±ì„ ìœ„í•´ cwd: str = "." ëŒ€ì‹  repo_path: str ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
def git_list_branches(repo_path: str) -> List[str]:
    """
    ì§€ì •ëœ ì €ì¥ì†Œì˜ ë¡œì»¬ ë° ì›ê²© ë¸Œëœì¹˜ ëª©ë¡ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.

    Returns:
        List[str]: ëª¨ë“  ë¸Œëœì¹˜ ì´ë¦„ì˜ ë¦¬ìŠ¤íŠ¸. í˜„ì¬ í™œì„±í™”ëœ ë¸Œëœì¹˜ëŠ” ì´ë¦„ ì•ì— '*'ê°€ ë¶™ìŠµë‹ˆë‹¤.

    Example:
        >>> branches = git_list_branches("./my-repo")
        >>> print(branches)
        ['* main', 'develop', 'remotes/origin/main']
    """
    output = _run_git_command(["git", "branch", "-a"], cwd=repo_path)
    return [line.strip() for line in output.split('\n') if line]


# (ìˆ˜ì •) ì¼ê´€ì„±ì„ ìœ„í•´ cwd: str = "." ëŒ€ì‹  repo_path: str ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
def git_merge(repo_path: str, branch_to_merge: str):
    """
    ë‹¤ë¥¸ ë¸Œëœì¹˜ì˜ ë³€ê²½ ì‚¬í•­ì„ í˜„ì¬ ë¸Œëœì¹˜ë¡œ ë³‘í•©(merge)í•©ë‹ˆë‹¤.

    ê²½ê³ : ì´ ê¸°ëŠ¥ì€ í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬ì˜ ìƒíƒœë¥¼ ë³€ê²½í•˜ëŠ” ìœ„í—˜í•œ ì‘ì—…ì…ë‹ˆë‹¤.
    ì‹¤í–‰ ì „ ë°˜ë“œì‹œ ì‘ì—… ë‚´ìš©ì„ ì»¤ë°‹í•˜ê±°ë‚˜ ìŠ¤íƒœì‹œ(stash)í•´ì•¼ í•©ë‹ˆë‹¤.
    ì¶©ëŒ(conflict) ë°œìƒ ì‹œ, ëª…ë ¹ì–´ëŠ” ì‹¤íŒ¨í•˜ë©° ì‚¬ìš©ìê°€ ì§ì ‘ í•´ê²°í•´ì•¼ í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        branch_to_merge (str): í˜„ì¬ ë¸Œëœì¹˜ë¡œ ë³‘í•©í•  ëŒ€ìƒ ë¸Œëœì¹˜ì˜ ì´ë¦„.

    Raises:
        ValueError: ë¸Œëœì¹˜ ì´ë¦„ì´ ìœ íš¨í•˜ì§€ ì•Šì€ í˜•ì‹ì¼ ë•Œ ë°œìƒí•©ë‹ˆë‹¤.
        subprocess.CalledProcessError: ë³‘í•© ì¤‘ ì¶©ëŒì´ ë°œìƒí•˜ê±°ë‚˜ ë‹¤ë¥¸ ë¬¸ì œê°€ ìƒê²¼ì„ ë•Œ ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> git_merge("./my-repo", "develop")
    """
    if not _is_valid_git_ref_name(branch_to_merge):
        raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ ë¸Œëœì¹˜ ì´ë¦„ì…ë‹ˆë‹¤: '{branch_to_merge}'")
    logger.warning(f"'{branch_to_merge}' ë¸Œëœì¹˜ë¥¼ í˜„ì¬ ë¸Œëœì¹˜ë¡œ ë³‘í•©í•©ë‹ˆë‹¤. ì‘ì—… ë””ë ‰í† ë¦¬ê°€ ë³€ê²½ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
    _run_git_command(["git", "merge", branch_to_merge], cwd=repo_path)
    logger.info(f"ì„±ê³µì ìœ¼ë¡œ ë¸Œëœì¹˜ë¥¼ ë³‘í•©í–ˆìŠµë‹ˆë‹¤: {branch_to_merge}")


# (ìˆ˜ì •) ì¼ê´€ì„±ì„ ìœ„í•´ cwd: str = "." ëŒ€ì‹  repo_path: str ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
def git_log(repo_path: str, limit: int = 10) -> str:
    """
    ìµœê·¼ ì»¤ë°‹ ê¸°ë¡ì„ ì§€ì •ëœ ìˆ˜ë§Œí¼ ë³´ì—¬ì¤ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        limit (int, optional): ê°€ì ¸ì˜¬ ì»¤ë°‹ì˜ ìµœëŒ€ ê°œìˆ˜. ê¸°ë³¸ê°’ì€ 10ì…ë‹ˆë‹¤.

    Returns:
        str: í¬ë§·íŒ…ëœ git ë¡œê·¸ ë¬¸ìì—´.

    Raises:
        ValueError: limitì´ 0 ì´í•˜ì˜ ì •ìˆ˜ê°€ ì•„ë‹ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> print(git_log("./my-repo", 5))
    """
    if not isinstance(limit, int) or limit <= 0:
        raise ValueError("limitì€ 0ë³´ë‹¤ í° ì •ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.")
    return _run_git_command(["git", "log", f"-n{limit}", "--oneline"], cwd=repo_path)


# (ìˆ˜ì •) ì¼ê´€ì„±ì„ ìœ„í•´ cwd: str = "." ëŒ€ì‹  repo_path: str ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
def git_diff(repo_path: str, file: Optional[str] = None) -> str:
    """
    ë³€ê²½ë˜ì—ˆì§€ë§Œ ì•„ì§ ìŠ¤í…Œì´ì§•ë˜ì§€ ì•Šì€ ë‚´ìš©ì˜ ì°¨ì´ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        file (Optional[str], optional): íŠ¹ì • íŒŒì¼ì˜ ë³€ê²½ ë‚´ìš©ë§Œ ë³´ë ¤ë©´ íŒŒì¼ ê²½ë¡œë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
                                      Noneì´ë©´ ëª¨ë“  ë³€ê²½ ë‚´ìš©ì„ ë³´ì—¬ì¤ë‹ˆë‹¤. ê¸°ë³¸ê°’ì€ Noneì…ë‹ˆë‹¤.

    Returns:
        str: 'git diff' ê²°ê³¼ ë¬¸ìì—´. ë³€ê²½ ë‚´ìš©ì´ ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    """
    command = ["git", "diff"]
    if file:
        command.append(file)
    return _run_git_command(command, cwd=repo_path)


# (ìˆ˜ì •) ì¼ê´€ì„±ì„ ìœ„í•´ cwd: str = "." ëŒ€ì‹  repo_path: str ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
def git_add_remote(repo_path: str, name: str, url: str):
    """
    ìƒˆë¡œìš´ ì›ê²© ì €ì¥ì†Œ ì£¼ì†Œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        name (str): ì›ê²© ì €ì¥ì†Œì˜ ë³„ì¹­ (ì˜ˆ: 'origin', 'upstream').
        url (str): ì›ê²© ì €ì¥ì†Œì˜ URL.

    Raises:
        ValueError: ì›ê²© ì €ì¥ì†Œ ì´ë¦„ì´ë‚˜ URLì´ ìœ íš¨í•˜ì§€ ì•Šì„ ë•Œ ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> git_add_remote("./my-repo", "upstream", "https://github.com/some/repo.git")
    """
    if not _is_valid_git_ref_name(name):
        raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ ì›ê²© ì €ì¥ì†Œ ì´ë¦„ì…ë‹ˆë‹¤: '{name}'")
    # URLì— ëŒ€í•œ ê°„ë‹¨í•œ ê²€ì¦ (httpë¡œ ì‹œì‘í•˜ëŠ”ì§€)
    if not url.startswith(('http://', 'https://', 'git@')):
        raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ URL í˜•ì‹ì…ë‹ˆë‹¤: '{url}'")
    _run_git_command(["git", "remote", "add", name, url], cwd=repo_path)
    logger.info(f"ì„±ê³µì ìœ¼ë¡œ ì›ê²© ì €ì¥ì†Œë¥¼ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤: {name} -> {url}")


# (ìˆ˜ì •) ì¼ê´€ì„±ì„ ìœ„í•´ cwd: str = "." ëŒ€ì‹  repo_path: str ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
def git_create_tag(repo_path: str, tag_name: str, message: str):
    """
    í˜„ì¬ ì»¤ë°‹ì— ì£¼ì„(annotated) íƒœê·¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        tag_name (str): ìƒì„±í•  íƒœê·¸ì˜ ì´ë¦„ (ì˜ˆ: 'v1.0.0').
        message (str): íƒœê·¸ì— ëŒ€í•œ ì„¤ëª… ë©”ì‹œì§€.

    Raises:
        ValueError: íƒœê·¸ ì´ë¦„ì´ ìœ íš¨í•˜ì§€ ì•Šì€ í˜•ì‹ì¼ ë•Œ ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> git_create_tag("./my-repo", "v1.0.1", "Release version 1.0.1")
    """
    if not _is_valid_git_ref_name(tag_name):
        raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ íƒœê·¸ ì´ë¦„ì…ë‹ˆë‹¤: '{tag_name}'")
    _run_git_command(["git", "tag", "-a", tag_name, "-m", message], cwd=repo_path)
    logger.info(f"ì„±ê³µì ìœ¼ë¡œ íƒœê·¸ë¥¼ ìƒì„±í–ˆìŠµë‹ˆë‹¤: {tag_name}")


# (ìˆ˜ì •) ì¼ê´€ì„±ì„ ìœ„í•´ cwd: str = "." ëŒ€ì‹  repo_path: str ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
def git_list_tags(repo_path: str) -> List[str]:
    """
    ì €ì¥ì†Œì— ì¡´ì¬í•˜ëŠ” ëª¨ë“  íƒœê·¸ì˜ ëª©ë¡ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.

    Returns:
        List[str]: íƒœê·¸ ì´ë¦„ì˜ ë¦¬ìŠ¤íŠ¸.
    """
    output = _run_git_command(["git", "tag"], cwd=repo_path)
    return [line.strip() for line in output.split('\n') if line]


# (ìˆ˜ì •) ì¼ê´€ì„±ì„ ìœ„í•´ cwd: str = "." ëŒ€ì‹  repo_path: str ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
def git_revert_commit(repo_path: str, commit_hash: str):
    """
    íŠ¹ì • ì»¤ë°‹ì—ì„œ ë°œìƒí•œ ë³€ê²½ ì‚¬í•­ì„ ë˜ëŒë¦¬ëŠ” ìƒˆë¡œìš´ ì»¤ë°‹ì„ ìƒì„±í•©ë‹ˆë‹¤.

    ê²½ê³ : ì´ ê¸°ëŠ¥ì€ ìƒˆë¡œìš´ ì»¤ë°‹ì„ ìƒì„±í•˜ì—¬ ê³¼ê±°ì˜ ë³€ê²½ì„ ë˜ëŒë¦½ë‹ˆë‹¤.
    íˆìŠ¤í† ë¦¬ë¥¼ ì§ì ‘ ìˆ˜ì •í•˜ì§€ëŠ” ì•Šì§€ë§Œ, í˜„ì¬ ë¸Œëœì¹˜ì— ìƒˆë¡œìš´ ì»¤ë°‹ì´ ì¶”ê°€ë©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        commit_hash (str): ë˜ëŒë¦´ ëŒ€ìƒ ì»¤ë°‹ì˜ í•´ì‹œ.

    Raises:
        ValueError: ì»¤ë°‹ í•´ì‹œê°€ ìœ íš¨í•˜ì§€ ì•Šì€ í˜•ì‹ì¼ ë•Œ ë°œìƒí•©ë‹ˆë‹¤.
        subprocess.CalledProcessError: ë˜ëŒë¦¬ê¸° ì¤‘ ì¶©ëŒì´ ë°œìƒí•˜ê±°ë‚˜ ë‹¤ë¥¸ ë¬¸ì œê°€ ìƒê²¼ì„ ë•Œ ë°œìƒí•©ë‹ˆë‹¤.
    """
    if not _is_valid_commit_hash(commit_hash):
        raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ ì»¤ë°‹ í•´ì‹œ í˜•ì‹ì…ë‹ˆë‹¤: '{commit_hash}'")
    logger.warning(f"ì»¤ë°‹ '{commit_hash}'ì˜ ë³€ê²½ ì‚¬í•­ì„ ë˜ëŒë¦¬ëŠ” ìƒˆë¡œìš´ ì»¤ë°‹ì„ ìƒì„±í•©ë‹ˆë‹¤.")
    # --no-edit ì˜µì…˜ìœ¼ë¡œ revert ì»¤ë°‹ ë©”ì‹œì§€ë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•˜ë„ë¡ í•©ë‹ˆë‹¤.
    _run_git_command(["git", "revert", "--no-edit", commit_hash], cwd=repo_path)
    logger.info(f"ì„±ê³µì ìœ¼ë¡œ ì»¤ë°‹ì„ ë˜ëŒë ¸ìŠµë‹ˆë‹¤: {commit_hash}")


# (ìˆ˜ì •) ì¼ê´€ì„±ì„ ìœ„í•´ cwd: str = "." ëŒ€ì‹  repo_path: str ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
def git_show_commit_details(repo_path: str, commit_hash: str) -> str:
    """
    íŠ¹ì • ì»¤ë°‹ì˜ ìƒì„¸ ì •ë³´ì™€ ë³€ê²½ëœ ë‚´ìš©(diff)ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        commit_hash (str): ì¡°íšŒí•  ì»¤ë°‹ì˜ í•´ì‹œ.

    Returns:
        str: í•´ë‹¹ ì»¤ë°‹ì˜ ìƒì„¸ ì •ë³´ ë¬¸ìì—´.

    Raises:
        ValueError: ì»¤ë°‹ í•´ì‹œê°€ ìœ íš¨í•˜ì§€ ì•Šì€ í˜•ì‹ì¼ ë•Œ ë°œìƒí•©ë‹ˆë‹¤.
    """
    if not _is_valid_commit_hash(commit_hash):
        raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ ì»¤ë°‹ í•´ì‹œ í˜•ì‹ì…ë‹ˆë‹¤: '{commit_hash}'")
    return _run_git_command(["git", "show", commit_hash], cwd=repo_path)


# (ìˆ˜ì •) ì¼ê´€ì„±ì„ ìœ„í•´ cwd: str = "." ëŒ€ì‹  repo_path: str ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
def git_get_current_branch(repo_path: str) -> str:
    """
    í˜„ì¬ ì‘ì—… ì¤‘ì¸ ë¸Œëœì¹˜ì˜ ì´ë¦„ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.

    Returns:
        str: í˜„ì¬ ë¸Œëœì¹˜ì˜ ì´ë¦„. detached HEAD ìƒíƒœì¸ ê²½ìš°, í•´ë‹¹ ìƒíƒœì„ì„ ì•Œë¦¬ëŠ” ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    """
    # 'git branch --show-current'ëŠ” detached HEAD ìƒíƒœì—ì„œ ë¹ˆ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    return _run_git_command(["git", "branch", "--show-current"], cwd=repo_path)

def git_list_all_files(repo_path: str) -> List[str]:
    """
    '.gitignore'ì™€ 'exclude' ê·œì¹™ì„ ëª¨ë‘ ë°˜ì˜í•˜ì—¬,
    tracked, untracked íŒŒì¼ì„ í¬í•¨í•œ ëª¨ë“  ì‘ì—… ë””ë ‰í† ë¦¬ì˜ íŒŒì¼ ëª©ë¡ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    'git ls-files --cached --others --exclude-standard' ëª…ë ¹ì„ ì•ˆì „í•˜ê²Œ ì‹¤í–‰í•©ë‹ˆë‹¤.
    AIê°€ ì½”ë“œë² ì´ìŠ¤ ì „ì²´ë¥¼ ë¡œë“œí•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.

    Returns:
        List[str]: .gitignoreì— ì˜í•´ ë¬´ì‹œë˜ì§€ ì•ŠëŠ” ëª¨ë“  íŒŒì¼ì˜ ìƒëŒ€ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸.

    Raises:
        GitCommandError: 'git ls-files' ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨ ì‹œ ë°œìƒí•©ë‹ˆë‹¤.
    """
    logger.info(f"'{repo_path}'ì—ì„œ .gitignoreë¥¼ ë°˜ì˜í•œ ëª¨ë“  íŒŒì¼ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.")
    # --cached: tracked files
    # --others: untracked files
    # --exclude-standard: .gitignore, .git/info/exclude ë“±ì„ ëª¨ë‘ ì ìš©
    command = ['git', 'ls-files', '--cached', '--others', '--exclude-standard']
    try:
        output = _run_git_command(command, cwd=repo_path)
        files = output.split('\n')
        # ë¹ˆ ì¤„ì´ë‚˜ ì˜ˆì™¸ ê²½ë¡œ(ì˜ˆ: .git)ê°€ í¬í•¨ë  ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ í•„í„°ë§
        return [f for f in files if f.strip() and not f.startswith('.git/')]
    except GitCommandError as e:
        logger.error(f"git ls-files ì‹¤í–‰ ì‹¤íŒ¨: {e.stderr}")
        raise
    except Exception as e:
        logger.error(f"íŒŒì¼ ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜: {e}")
        raise GitCommandError(f"íŒŒì¼ ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜: {e}")
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ì½”ë“œ ë²ˆë“¤ë§ ë° ì§‘ê³„(Aggregation)ë¥¼ ìœ„í•œ MCP ëª¨ìŒ.

ì´ ëª¨ë“ˆì€ ì—¬ëŸ¬ ì†ŒìŠ¤ ì½”ë“œ íŒŒì¼ì„ íŠ¹ì • ê·œì¹™ì— ë”°ë¼ í•˜ë‚˜ì˜ íŒŒì¼ë¡œ ë³‘í•©í•˜ëŠ”
ê³ ìˆ˜ì¤€ì˜ ë³µí•©(Compound) MCP í•¨ìˆ˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤. .gitignoreì™€ ê°™ì€
ì œì™¸ ê·œì¹™ì„ ì§€ì›í•˜ì—¬ í”„ë¡œì íŠ¸ ì½”ë“œë² ì´ìŠ¤ë¥¼ ì‰½ê²Œ ì•„ì¹´ì´ë¹™í•˜ê±°ë‚˜
LLM ì»¨í…ìŠ¤íŠ¸ì— ì£¼ì…í•  ìˆ˜ ìˆë„ë¡ ë•ìŠµë‹ˆë‹¤.
"""

import logging
import fnmatch
from pathlib import Path
from typing import Union, List, Optional

# --- ëª¨ë“ˆ ë ˆë²¨ ë¡œê±° ì„¤ì • ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# ì¼ë°˜ì ì¸ í”„ë¡œì íŠ¸ì—ì„œ ì œì™¸í•  ê¸°ë³¸ íŒ¨í„´ ëª©ë¡
DEFAULT_IGNORE_PATTERNS = [
    ".git/*",
    "venv/*",
    ".venv/*",
    "__pycache__/*",
    "*.pyc",
    "*.log",
    "*.tmp",
    ".DS_Store",
    "node_modules/*",
    "build/*",
    "dist/*",
    "*.egg-info/*",
]


def aggregate_python_files(
    root_dir: Union[str, Path],
    output_file: Union[str, Path],
    additional_ignore_patterns: Optional[List[str]] = None
) -> str:
    """
    ì§€ì •ëœ ë””ë ‰í† ë¦¬ì˜ ëª¨ë“  Python íŒŒì¼ì„ ì°¾ì•„ .gitignore ê·œì¹™ì— ë”°ë¼ í•„í„°ë§í•œ í›„ í•˜ë‚˜ì˜ íŒŒì¼ë¡œ ë³‘í•©í•©ë‹ˆë‹¤.

    ì´ í•¨ìˆ˜ëŠ” ë‹¤ìŒ ë‹¨ê³„ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤:
    1. `root_dir`ì—ì„œ `.gitignore` íŒŒì¼ì„ ì½ì–´ ì œì™¸ íŒ¨í„´ì„ ë¡œë“œí•©ë‹ˆë‹¤.
    2. ê¸°ë³¸ ì œì™¸ íŒ¨í„´ ë° `additional_ignore_patterns`ì™€ ê²°í•©í•©ë‹ˆë‹¤.
    3. `root_dir`ì„ ì¬ê·€ì ìœ¼ë¡œ íƒìƒ‰í•˜ì—¬ ëª¨ë“  `.py` íŒŒì¼ì„ ì°¾ìŠµë‹ˆë‹¤.
    4. ê° íŒŒì¼ì˜ ìƒëŒ€ ê²½ë¡œê°€ ì œì™¸ íŒ¨í„´ê³¼ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
    5. ì œì™¸ë˜ì§€ ì•Šì€ íŒŒì¼ë“¤ì˜ ë‚´ìš©ì„ ì½ì–´ `output_file`ì— ìˆœì°¨ì ìœ¼ë¡œ ì”ë‹ˆë‹¤.
       ê° íŒŒì¼ ë‚´ìš© ì•ì—ëŠ” íŒŒì¼ ê²½ë¡œë¥¼ ë‚˜íƒ€ë‚´ëŠ” í—¤ë”ê°€ ì¶”ê°€ë©ë‹ˆë‹¤.

    Args:
        root_dir (Union[str, Path]): ê²€ìƒ‰ì„ ì‹œì‘í•  ìµœìƒìœ„ ë””ë ‰í† ë¦¬ ê²½ë¡œ.
        output_file (Union[str, Path]): ëª¨ë“  ì½”ë“œë¥¼ ë³‘í•©í•˜ì—¬ ì €ì¥í•  íŒŒì¼ ê²½ë¡œ.
        additional_ignore_patterns (Optional[List[str]], optional):
            .gitignore ì™¸ì— ì¶”ê°€ë¡œ ì ìš©í•  ë¬´ì‹œ íŒ¨í„´ ë¦¬ìŠ¤íŠ¸. ê¸°ë³¸ê°’ì€ None.

    Returns:
        str: ì„±ê³µì ìœ¼ë¡œ ìƒì„±ëœ ì¶œë ¥ íŒŒì¼ì˜ ì ˆëŒ€ ê²½ë¡œ.

    Raises:
        FileNotFoundError: `root_dir`ê°€ ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜ ë””ë ‰í† ë¦¬ê°€ ì•„ë‹Œ ê²½ìš°.
        PermissionError: íŒŒì¼/ë””ë ‰í† ë¦¬ ì½ê¸° ë˜ëŠ” ì“°ê¸° ê¶Œí•œì´ ì—†ëŠ” ê²½ìš°.
        IOError: íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜ˆê¸°ì¹˜ ì•Šì€ I/O ì˜¤ë¥˜ê°€ ë°œìƒí•œ ê²½ìš°.
        ValueError: ì…ë ¥ ì¸ìê°€ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°.
    """
    logger.info(f"'{root_dir}'ì˜ íŒŒì´ì¬ íŒŒì¼ ì§‘ê³„ ì‹œì‘ -> '{output_file}'")

    # 1. ê²½ë¡œ ê°ì²´ë¡œ ë³€í™˜ ë° ìœ íš¨ì„± ê²€ì‚¬
    try:
        root_path = Path(root_dir).resolve()
        output_path = Path(output_file).resolve()

        if not root_path.is_dir():
            raise FileNotFoundError(f"ë£¨íŠ¸ ë””ë ‰í† ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {root_path}")

        # ì¶œë ¥ íŒŒì¼ì˜ ìƒìœ„ ë””ë ‰í† ë¦¬ ìƒì„±
        output_path.parent.mkdir(parents=True, exist_ok=True)

    except (PermissionError, FileNotFoundError) as e:
        logger.error(f"ê²½ë¡œ ì„¤ì • ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        raise
    except Exception as e:
        logger.critical(f"ê²½ë¡œ ì²˜ë¦¬ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {e}")
        raise IOError(f"ê²½ë¡œ ì²˜ë¦¬ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")

    # 2. .gitignore ë° ì¶”ê°€ íŒ¨í„´ ë¡œë“œ
    all_ignore_patterns = set(DEFAULT_IGNORE_PATTERNS)
    if additional_ignore_patterns:
        all_ignore_patterns.update(additional_ignore_patterns)

    gitignore_path = root_path / ".gitignore"
    if gitignore_path.is_file():
        logger.info(f"'{gitignore_path}'ì—ì„œ ì œì™¸ íŒ¨í„´ ë¡œë“œ ì¤‘.")
        try:
            with gitignore_path.open("r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith("#"):
                        # ë””ë ‰í† ë¦¬ íŒ¨í„´ (ì˜ˆ: 'logs/')ì„ ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ìœ¼ë¡œ ë³€í™˜
                        if line.endswith('/'):
                            all_ignore_patterns.add(line + '*')
                            all_ignore_patterns.add(line.rstrip('/'))
                        else:
                            all_ignore_patterns.add(line)
                            all_ignore_patterns.add(f'*/{line}') # ëª¨ë“  í•˜ìœ„ ë””ë ‰í† ë¦¬ì—ì„œë„ ë§¤ì¹­
        except Exception as e:
            logger.warning(f"'{gitignore_path}' íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: {e}")
            # .gitignoreë¥¼ ì½ì§€ ëª»í•´ë„ ê³„ì† ì§„í–‰

    # ìµœì¢… ì¶œë ¥ íŒŒì¼ ìì²´ë„ ì œì™¸ ëª©ë¡ì— ì¶”ê°€
    try:
        relative_output_path = output_path.relative_to(root_path)
        all_ignore_patterns.add(str(relative_output_path))
    except ValueError:
        # ì¶œë ¥ íŒŒì¼ì´ ë£¨íŠ¸ ë””ë ‰í† ë¦¬ ì™¸ë¶€ì— ìˆìœ¼ë©´ relative_toê°€ ì‹¤íŒ¨í•¨. ì´ ê²½ìš° ë¬´ì‹œ.
        pass
    
    logger.info(f"ì´ {len(all_ignore_patterns)}ê°œì˜ ì œì™¸ íŒ¨í„´ ì‚¬ìš©.")

    # 3. íŒŒì¼ íƒìƒ‰ ë° í•„í„°ë§
    aggregated_content = []
    files_to_process = list(root_path.rglob("*.py"))
    logger.info(f"ì´ {len(files_to_process)}ê°œì˜ .py íŒŒì¼ ë°œê²¬.")
    
    processed_count = 0
    for file_path in files_to_process:
        try:
            # Path ê°ì²´ëŠ” OSì— ë§ëŠ” êµ¬ë¶„ìë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ, fnmatchë¥¼ ìœ„í•´ í‘œì¤€ '/'ë¡œ ë³€í™˜
            relative_path_str = str(file_path.relative_to(root_path).as_posix())
            
            # fnmatchë¥¼ ì‚¬ìš©í•˜ì—¬ íŒ¨í„´ê³¼ ëŒ€ì¡°
            is_ignored = any(
                fnmatch.fnmatch(relative_path_str, pattern) or
                fnmatch.fnmatch(file_path.name, pattern)
                for pattern in all_ignore_patterns
            )

            if not is_ignored:
                logger.debug(f"ì²˜ë¦¬ ì¤‘: {relative_path_str}")
                header = f"# --- {relative_path_str} ---\n\n"
                try:
                    content = file_path.read_text(encoding="utf-8")
                    aggregated_content.append(header + content + "\n\n")
                    processed_count += 1
                except Exception as e:
                    logger.error(f"íŒŒì¼ ì½ê¸° ì˜¤ë¥˜ '{file_path}': {e}")
                    error_message = f"# Error reading {relative_path_str}: {e}\n\n"
                    aggregated_content.append(header + error_message)
            else:
                logger.debug(f"ë¬´ì‹œë¨: {relative_path_str}")

        except Exception as e:
            logger.error(f"íŒŒì¼ ê²½ë¡œ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ '{file_path}': {e}")


    # 4. ê²°ê³¼ íŒŒì¼ ì‘ì„±
    try:
        final_content = "".join(aggregated_content)
        output_path.write_text(final_content, encoding="utf-8")
        logger.info(f"ì„±ê³µ: ì´ {processed_count}ê°œì˜ íŒŒì¼ì„ '{output_path}'ì— ë³‘í•©í–ˆìŠµë‹ˆë‹¤.")
        return str(output_path)
    except PermissionError as e:
        logger.error(f"ì¶œë ¥ íŒŒì¼ ì“°ê¸° ê¶Œí•œ ì˜¤ë¥˜: {output_path}, {e}")
        raise
    except Exception as e:
        logger.critical(f"ì¶œë ¥ íŒŒì¼ ì“°ê¸° ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")
        raise IOError(f"íŒŒì¼ '{output_path}' ì“°ê¸° ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
project_workflows.py

AI ê¸°ë°˜ ê°œë°œ í”„ë¡œì íŠ¸ì˜ ê³µí†µ ì›Œí¬í”Œë¡œìš°ë¥¼ ìë™í™”í•˜ëŠ”
ê³ ìˆ˜ì¤€ ë³µí•© MCP(Composite Mission Control Primitives) ëª¨ìŒì…ë‹ˆë‹¤.

(ìˆ˜ì •) ê°œë°œ ë° ë””ë²„ê¹…, ì˜ì¡´ì„± ê´€ë¦¬ ì›Œí¬í”Œë¡œìš° 9ê°œ ì¶”ê°€.
"""

import logging
import os
import re
import ast
from typing import Dict, List, Optional
from pathlib import Path

# --- ë¡œê±° ì„¤ì • ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# --- ê¸°ì¡´ MCP ëª¨ë“ˆ ì„í¬íŠ¸ ---
try:
    # íŒŒì¼ ì‹œìŠ¤í…œ
    from .file_system_composite import (
        read_multiple_files, read_specific_lines
    )
    from .file_content_operations import (
        write_file, read_file, append_to_file
    )
    
    # Git (ì´ì „ ëŒ€í™”ì—ì„œ ìƒì„±í•œ git_list_all_files í¬í•¨)
    from .git_version_control import (
        git_init, git_add_remote, git_add, git_commit, git_get_current_branch,
        git_create_branch, git_switch_branch, git_push, git_status, git_diff,
        git_log, git_revert_commit, git_pull, git_create_tag, git_fetch,
        git_list_all_files, _run_git_command, GitCommandError
    )
    
    # ì‚¬ìš©ì ìƒí˜¸ì‘ìš©
    from .user_interaction_composite import (
        ask_user_for_input, ask_user_for_confirmation, ask_for_multiline_input,
        present_options_and_get_choice, present_checkbox_and_get_choices
    )
    from .user_interaction_atomic import show_message
    
    # ì½”ë“œ ì‹¤í–‰
    from .code_execution_composite import (
        lint_code_file, _run_command, setup_python_venv
    )
    
    # ì›¹
    from .web_network_atomic import fetch_url_content

except ImportError:
    # ì´ ëª¨ë“ˆì´ ë‹¨ë…ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ë  ê²½ìš°ë¥¼ ëŒ€ë¹„
    logger.error("ì›Œí¬í”Œë¡œìš° MCPëŠ” ë‹¤ë¥¸ MCP ëª¨ë“ˆê³¼ í•¨ê»˜ ì‹¤í–‰ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.")
    # í•„ìš”í•œ í•¨ìˆ˜ë“¤ì„ ì„ì‹œë¡œ ì •ì˜ (í…ŒìŠ¤íŠ¸ìš©)
    def _mock_mcp(*args, **kwargs):
        logger.warning(f"Mock MCP called with: {args}, {kwargs}")
        return "Mock Result"
    
    git_init = git_add_remote = git_add = git_commit = git_get_current_branch = \
    git_create_branch = git_switch_branch = git_push = git_status = git_diff = \
    git_log = git_revert_commit = git_pull = git_create_tag = git_fetch = \
    git_list_all_files = read_multiple_files = write_file = read_file = \
    append_to_file = read_specific_lines = setup_python_venv = \
    ask_user_for_input = ask_user_for_confirmation = ask_for_multiline_input = \
    present_options_and_get_choice = present_checkbox_and_get_choices = \
    show_message = lint_code_file = fetch_url_content = _run_command = _mock_mcp
    
    def _run_git_command(*args, **kwargs):
        return _mock_mcp(*args, **kwargs)
    
    class GitCommandError(Exception):
        pass


# ==============================================================================
# 1. ê¸°ì¡´ ì›Œí¬í”Œë¡œìš° MCP (11ê°œ)
# ==============================================================================

def initialize_project_repository(
    repo_path: str, 
    gitignore_template: str = "Python"
) -> str:
    """
    ìƒˆ í”„ë¡œì íŠ¸ í´ë”ë¥¼ Git ì €ì¥ì†Œë¡œ ë§Œë“¤ê³ , .gitignore íŒŒì¼ê¹Œì§€ ìƒì„±í•˜ì—¬ ì²« ì»¤ë°‹ì„ ì™„ë£Œí•©ë‹ˆë‹¤.
    ì‚¬ìš©ìì—ê²Œ ì›ê²© ì €ì¥ì†Œ ì£¼ì†Œë¥¼ ë¬¼ì–´ 'origin'ìœ¼ë¡œ ë“±ë¡í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): Git ì €ì¥ì†Œë¥¼ ì´ˆê¸°í™”í•  ë””ë ‰í† ë¦¬ ê²½ë¡œ.
        gitignore_template (str): .gitignore.ioì—ì„œ ê°€ì ¸ì˜¬ í…œí”Œë¦¿ ì´ë¦„. (ì˜ˆ: "Python,Node")

    Returns:
        str: ì„±ê³µ ë©”ì‹œì§€.
    """
    try:
        logger.info(f"'{repo_path}'ì—ì„œ Git ì €ì¥ì†Œ ì´ˆê¸°í™”ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...")
        git_init(repo_path)
        
        # .gitignore.io APIë¥¼ ì‚¬ìš©í•´ .gitignore íŒŒì¼ ìƒì„±
        logger.info(f"'{gitignore_template}' í…œí”Œë¦¿ìœ¼ë¡œ .gitignore íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤.")
        gi_url = f"https://www.toptal.com/developers/gitignore/api/{gitignore_template.lower()}"
        gi_content = fetch_url_content(gi_url)
        write_file(str(Path(repo_path) / ".gitignore"), gi_content)
        
        git_add(repo_path, files=[".gitignore"])
        git_commit(repo_path, message="Initial commit: Add .gitignore")
        
        logger.info("ì²« ì»¤ë°‹ì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤.")
        
        if ask_user_for_confirmation("ì§€ê¸ˆ ì›ê²© ì €ì¥ì†Œ(remote) ì£¼ì†Œë¥¼ ë“±ë¡í•˜ì‹œê² ìŠµë‹ˆê¹Œ?"):
            remote_url = ask_user_for_input("ì›ê²© ì €ì¥ì†Œ URLì„ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: https://...):")
            if remote_url:
                git_add_remote(repo_path, "origin", remote_url)
                return f"ì €ì¥ì†Œ ì´ˆê¸°í™” ë° ì›ê²© ì €ì¥ì†Œ 'origin' ë“±ë¡ ì™„ë£Œ: {repo_path}"

        return f"ì €ì¥ì†Œ ì´ˆê¸°í™” ì™„ë£Œ (ì›ê²© ì €ì¥ì†Œ ë¯¸ë“±ë¡): {repo_path}"
        
    except Exception as e:
        logger.error(f"í”„ë¡œì íŠ¸ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        raise

def start_new_feature_branch(repo_path: str) -> str:
    """
    ì‚¬ìš©ìì—ê²Œ ìƒˆ ë¸Œëœì¹˜ ì´ë¦„ì„ ë¬¼ì–´ë³¸ ë’¤, í•´ë‹¹ ë¸Œëœì¹˜ë¥¼ ìƒì„±í•˜ê³  ì¦‰ì‹œ ê·¸ ë¸Œëœì¹˜ë¡œ ì „í™˜í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.

    Returns:
        str: ì„±ê³µ ë©”ì‹œì§€ (ì˜ˆ: "ìƒˆ ë¸Œëœì¹˜ 'feature/login'ì„(ë¥¼) ìƒì„±í•˜ê³  ì „í™˜í–ˆìŠµë‹ˆë‹¤.")
    """
    branch_name = ask_user_for_input("ìƒì„±í•  ìƒˆ ë¸Œëœì¹˜ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: feature/login):")
    if not branch_name:
        return "ë¸Œëœì¹˜ ìƒì„±ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."
        
    try:
        logger.info(f"ìƒˆ ë¸Œëœì¹˜ '{branch_name}' ìƒì„± ë° ì „í™˜ ì‹œë„...")
        git_create_branch(repo_path, branch_name)
        git_switch_branch(repo_path, branch_name)
        
        msg = f"ìƒˆ ë¸Œëœì¹˜ '{branch_name}'ì„(ë¥¼) ìƒì„±í•˜ê³  ì „í™˜í–ˆìŠµë‹ˆë‹¤."
        logger.info(msg)
        return msg
    except Exception as e:
        logger.error(f"ìƒˆ ë¸Œëœì¹˜ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        raise

def commit_and_push_changes(repo_path: str, default_message: str = "") -> str:
    """
    ëª¨ë“  ë³€ê²½ ì‚¬í•­ì„ ìŠ¤í…Œì´ì§•í•˜ê³ , ì‚¬ìš©ìì—ê²Œ ì»¤ë°‹ ë©”ì‹œì§€ë¥¼ í™•ì¸(ì…ë ¥)ë°›ì€ ë’¤,
    í˜„ì¬ ë¸Œëœì¹˜ë¡œ 'origin'ì— í‘¸ì‹œí•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        default_message (str): AIê°€ ì œì•ˆí•˜ê±°ë‚˜ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©í•  ì»¤ë°‹ ë©”ì‹œì§€.

    Returns:
        str: ì„±ê³µ ë©”ì‹œì§€.
    """
    try:
        status = git_status(repo_path)
        logger.info(f"í˜„ì¬ Git ìƒíƒœ:\n{status}")
        
        commit_msg = ask_user_for_input(
            "ì»¤ë°‹ ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš” (Enter ì‹œ ê¸°ë³¸ê°’ ì‚¬ìš©):",
            default=default_message or "AI ì—ì´ì „íŠ¸ì— ì˜í•œ ì½”ë“œ ë³€ê²½"
        )
        if not commit_msg:
            return "ì»¤ë°‹ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."
            
        logger.info("ëª¨ë“  ë³€ê²½ ì‚¬í•­ì„ ìŠ¤í…Œì´ì§•í•©ë‹ˆë‹¤...")
        git_add(repo_path, files=['.'])
        
        logger.info(f"'{commit_msg}' ë©”ì‹œì§€ë¡œ ì»¤ë°‹í•©ë‹ˆë‹¤...")
        git_commit(repo_path, commit_msg)
        
        current_branch = git_get_current_branch(repo_path)
        if not current_branch:
            raise GitCommandError("í˜„ì¬ ë¸Œëœì¹˜ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (Detached HEAD ìƒíƒœì¼ ìˆ˜ ìˆìŒ).")
            
        logger.info(f"'origin/{current_branch}'(ìœ¼)ë¡œ í‘¸ì‹œí•©ë‹ˆë‹¤...")
        push_result = git_push(repo_path, "origin", current_branch)
        
        return f"ì»¤ë°‹ ë° í‘¸ì‹œ ì™„ë£Œ.\n{push_result}"
        
    except Exception as e:
        logger.error(f"ì»¤ë°‹ ë° í‘¸ì‹œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        raise

def analyze_and_lint_project(repo_path: str) -> str:
    """
    .gitignoreë¥¼ ì¤€ìˆ˜í•˜ëŠ” í”„ë¡œì íŠ¸ ë‚´ì˜ ëª¨ë“  Python íŒŒì¼(.py)ì— ëŒ€í•´ LINT(flake8) ê²€ì‚¬ë¥¼
    ìˆ˜í–‰í•˜ê³ , ë¬¸ì œê°€ ë°œê²¬ëœ íŒŒì¼ì˜ ê²°ê³¼ë§Œ ìš”ì•½í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ê²€ì‚¬í•  Git ì €ì¥ì†Œì˜ ê²½ë¡œ.

    Returns:
        str: LINT ê²€ì‚¬ ê²°ê³¼ ìš”ì•½.
    """
    logger.info(f"'{repo_path}'ì˜ ëª¨ë“  Python íŒŒì¼ì— ëŒ€í•´ LINT ê²€ì‚¬ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.")
    try:
        all_files = git_list_all_files(repo_path)
        py_files = [f for f in all_files if f.endswith(".py")]
        
        if not py_files:
            return "ê²€ì‚¬í•  Python íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤."
            
        logger.info(f"ì´ {len(py_files)}ê°œì˜ Python íŒŒì¼ ê²€ì‚¬ ì¤‘...")
        
        lint_issues = []
        for file_path in py_files:
            try:
                # lint_code_fileì€ ë¬¸ì œê°€ ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´ì„, ìˆìœ¼ë©´ ì˜¤ë¥˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
                # (mcp_modules/code_execution_composite.pyì˜ ë¡œì§ì— ë”°ë¼ ë‹¤ë¦„)
                # ì—¬ê¸°ì„œëŠ” 'lint_code_file'ì´ ì˜¤ë¥˜ ë°œê²¬ ì‹œ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¨ë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤.
                lint_result = lint_code_file(str(Path(repo_path) / file_path))
                if lint_result: # ë¬¸ì œê°€ ìˆëŠ”ë° ì˜ˆì™¸ê°€ ì•„ë‹Œ ë¬¸ìì—´ì„ ë°˜í™˜í•œ ê²½ìš°
                     lint_issues.append(f"--- {file_path} ---\n{lint_result}")
            except Exception as e:
                # CalledProcessError ë“± LINTê°€ ë¬¸ì œë¥¼ ë°œê²¬í–ˆì„ ë•Œ
                error_output = getattr(e, 'stdout', '') + getattr(e, 'stderr', '')
                if error_output:
                    lint_issues.append(f"--- {file_path} ---\n{error_output}")
                else:
                    lint_issues.append(f"--- {file_path} ---\n{str(e)}")

        if not lint_issues:
            return f"LINT ê²€ì‚¬ ì™„ë£Œ: {len(py_files)}ê°œì˜ ëª¨ë“  íŒŒì¼ì´ ê¹¨ë—í•©ë‹ˆë‹¤."
        else:
            return f"LINT ê²€ì‚¬ ì™„ë£Œ. {len(lint_issues)}ê°œ íŒŒì¼ì—ì„œ ë¬¸ì œê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤:\n\n" + "\n\n".join(lint_issues)

    except Exception as e:
        logger.error(f"LINT ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        raise

def revert_last_ai_commit(repo_path: str) -> str:
    """
    ê°€ì¥ ìµœê·¼ì˜ ì»¤ë°‹(ì•„ë§ˆë„ AIê°€ ìƒì„±í•œ)ì„ ë˜ëŒë¦´ì§€(revert) ì‚¬ìš©ìì—ê²Œ í™•ì¸í•˜ê³  ì‹¤í–‰í•©ë‹ˆë‹¤.
    (revertëŠ” ë˜ëŒë¦¬ëŠ” ìƒˆ ì»¤ë°‹ì„ ìƒì„±í•©ë‹ˆë‹¤)

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.

    Returns:
        str: ì‘ì—… ì„±ê³µ ë˜ëŠ” ì·¨ì†Œ ë©”ì‹œì§€.
    """
    try:
        log_output = git_log(repo_path, limit=1)
        if not log_output:
            return "ë˜ëŒë¦´ ì»¤ë°‹ì´ ì—†ìŠµë‹ˆë‹¤."
            
        last_commit_hash = log_output.split()[0]
        
        if ask_user_for_confirmation(f"ê°€ì¥ ìµœê·¼ ì»¤ë°‹ì„ ë˜ëŒë¦¬ì‹œê² ìŠµë‹ˆê¹Œ?\n\n{log_output}"):
            logger.info(f"ì»¤ë°‹ {last_commit_hash} ë˜ëŒë¦¬ê¸°ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤...")
            git_revert_commit(repo_path, last_commit_hash)
            return f"ì»¤ë°‹ {last_commit_hash}ì„(ë¥¼) ë˜ëŒë¦¬ëŠ” ìƒˆ ì»¤ë°‹ì„ ìƒì„±í–ˆìŠµë‹ˆë‹¤."
        else:
            return "ì‘ì—…ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."
    except Exception as e:
        logger.error(f"ì»¤ë°‹ ë˜ëŒë¦¬ê¸° ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        raise

def load_and_analyze_project_code(repo_path: str) -> str:
    """
    .gitignoreë¥¼ ì¤€ìˆ˜í•˜ëŠ” í”„ë¡œì íŠ¸ ë‚´ì˜ ëª¨ë“  íŒŒì¼ì„ ì½ì–´ í•˜ë‚˜ì˜ ë¬¸ìì—´ë¡œ ê²°í•©í•©ë‹ˆë‹¤.
    AIê°€ ì „ì²´ ì½”ë“œë² ì´ìŠ¤ì˜ ë§¥ë½ì„ íŒŒì•…í•˜ê³  ë¶„ì„/ìˆ˜ì • ì‘ì—…ì„ ì¤€ë¹„í•  ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.

    Returns:
        str: "--- START OF [filepath] ---" í˜•ì‹ìœ¼ë¡œ êµ¬ë¶„ëœ ì „ì²´ ì½”ë“œ ë¬¸ìì—´.
    """
    try:
        logger.info(f"'{repo_path}'ì˜ ì „ì²´ ì½”ë“œ ë¡œë“œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...")
        all_files = git_list_all_files(repo_path)
        
        if not all_files:
            return "í”„ë¡œì íŠ¸ì— íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤."
            
        logger.info(f"ì´ {len(all_files)}ê°œ íŒŒì¼ì˜ ë‚´ìš©ì„ ê²°í•©í•©ë‹ˆë‹¤.")
        # read_multiple_filesê°€ íŒŒì¼ ê²½ë¡œë¥¼ repo_path ê¸°ì¤€ìœ¼ë¡œ ì²˜ë¦¬í•˜ë„ë¡ ìˆ˜ì •
        full_paths = [str(Path(repo_path) / f) for f in all_files]
        combined_code = read_multiple_files(full_paths)
        
        return combined_code
        
    except Exception as e:
        logger.error(f"í”„ë¡œì íŠ¸ ì½”ë“œ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        raise

def switch_to_main_and_pull(repo_path: str, branch_name: str = "main") -> str:
    """
    í”„ë¡œì íŠ¸ì˜ ë©”ì¸ ë¸Œëœì¹˜(ê¸°ë³¸ 'main')ë¡œ ì „í™˜í•˜ê³ ,
    ì›ê²© ì €ì¥ì†Œ(origin)ì˜ ìµœì‹  ë³€ê²½ ì‚¬í•­ì„ pull ë°›ìŠµë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        branch_name (str): ë™ê¸°í™”í•  ê¸°ë³¸ ë¸Œëœì¹˜ ì´ë¦„.

    Returns:
        str: ì„±ê³µ ë©”ì‹œì§€.
    """
    try:
        logger.info(f"'{branch_name}' ë¸Œëœì¹˜ë¡œ ì „í™˜í•©ë‹ˆë‹¤...")
        git_switch_branch(repo_path, branch_name)
        
        logger.info(f"'origin/{branch_name}'ì—ì„œ ìµœì‹  ë³€ê²½ ì‚¬í•­ì„ PULLí•©ë‹ˆë‹¤...")
        pull_result = git_pull(repo_path, "origin", branch_name)
        
        return f"'{branch_name}' ë¸Œëœì¹˜ë¡œ ì „í™˜ ë° ìµœì‹ í™” ì™„ë£Œ.\n{pull_result}"
    except Exception as e:
        logger.error(f"ë©”ì¸ ë¸Œëœì¹˜ ë™ê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        raise

def publish_new_version_tag(repo_path: str, remote: str = "origin") -> str:
    """
    ìƒˆ ë²„ì „ ë¦´ë¦¬ìŠ¤ë¥¼ ìœ„í•´ ì‚¬ìš©ìì—ê²Œ íƒœê·¸ ì´ë¦„ê³¼ ë¦´ë¦¬ìŠ¤ ë…¸íŠ¸ë¥¼ ì…ë ¥ë°›ì•„
    Git íƒœê·¸ë¥¼ ìƒì„±í•˜ê³  ì›ê²© ì €ì¥ì†Œ(origin)ì— í‘¸ì‹œí•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        remote (str): íƒœê·¸ë¥¼ í‘¸ì‹œí•  ì›ê²© ì €ì¥ì†Œ ì´ë¦„.

    Returns:
        str: ì„±ê³µ ë˜ëŠ” ì·¨ì†Œ ë©”ì‹œì§€.
    """
    tag_name = ask_user_for_input("ìƒˆ ë²„ì „ íƒœê·¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: v1.0.1):")
    if not tag_name:
        return "íƒœê·¸ ìƒì„±ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."
        
    release_notes = ask_for_multiline_input(
        "ë¦´ë¦¬ìŠ¤ ë…¸íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš” (Markdown ì§€ì›, ì¢…ë£Œí•˜ë ¤ë©´ EOF ì…ë ¥):"
    )
    if not release_notes:
        release_notes = f"Release {tag_name}" # ê¸°ë³¸ ë©”ì‹œì§€
        
    try:
        logger.info(f"'{tag_name}' íƒœê·¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤...")
        git_create_tag(repo_path, tag_name, release_notes)
        
        # git_push MCPëŠ” ë¸Œëœì¹˜ ì „ìš©ì´ë¯€ë¡œ, íƒœê·¸ í‘¸ì‹œë¥¼ ìœ„í•´ _run_git_command ì‚¬ìš©
        logger.info(f"'{remote}'(ìœ¼)ë¡œ íƒœê·¸ë¥¼ í‘¸ì‹œí•©ë‹ˆë‹¤...")
        push_command = ["git", "push", remote, tag_name]
        push_result = _run_git_command(push_command, cwd=repo_path)
        
        return f"íƒœê·¸ '{tag_name}' ìƒì„± ë° ì›ê²© ì €ì¥ì†Œ í‘¸ì‹œ ì™„ë£Œ.\n{push_result}"
        
    except Exception as e:
        logger.error(f"íƒœê·¸ ê²Œì‹œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        raise

def run_project_tests(repo_path: str, test_framework: str = "auto") -> str:
    """
    í”„ë¡œì íŠ¸ì˜ ìë™í™”ëœ í…ŒìŠ¤íŠ¸(pytest ë˜ëŠ” unittest)ë¥¼ ì•ˆì „í•˜ê²Œ ì‹¤í–‰í•˜ê³  ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    ì´ëŠ” AIê°€ ìˆ˜ì •í•œ ì½”ë“œë¥¼ ê²€ì¦í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

    Args:
        repo_path (str): í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•  ì €ì¥ì†Œ ê²½ë¡œ.
        test_framework (str): 'pytest', 'unittest', 'auto' ì¤‘ ì„ íƒ.
            'auto'ëŠ” pytest.inië¥¼ ë¨¼ì € ì°¾ê³ , ì—†ìœ¼ë©´ unittestë¥¼ ì‹œë„í•©ë‹ˆë‹¤.

    Returns:
        str: í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ê²°ê³¼ (stdout + stderr).
    """
    command: List[str]
    
    if test_framework == "auto":
        if (Path(repo_path) / "pytest.ini").exists():
            framework_to_run = "pytest"
        else:
            framework_to_run = "unittest"
    else:
        framework_to_run = test_framework

    if framework_to_run == "pytest":
        command = ["pytest"]
        logger.info("pytestë¥¼ ì‚¬ìš©í•˜ì—¬ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤...")
    elif framework_to_run == "unittest":
        command = ["python", "-m", "unittest", "discover"]
        logger.info("unittestë¥¼ ì‚¬ìš©í•˜ì—¬ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤...")
    else:
        raise ValueError(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬ì…ë‹ˆë‹¤: {test_framework}")

    try:
        # code_execution_compositeì˜ _run_command ì‚¬ìš© (ì…¸ ì¸ì ì…˜ ë°©ì§€)
        result = _run_command(command, cwd=repo_path)
        logger.info("í…ŒìŠ¤íŠ¸ ì„±ê³µ.")
        return f"í…ŒìŠ¤íŠ¸ ì„±ê³µ:\n{result}"
    except Exception as e:
        # í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨ ì‹œ CalledProcessError ë°œìƒ
        error_output = getattr(e, 'stdout', '') + getattr(e, 'stderr', '')
        if not error_output:
            error_output = str(e)
        logger.warning(f"í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨:\n{error_output}")
        # ì‹¤íŒ¨ë„ ìœ íš¨í•œ 'ê²°ê³¼'ì´ë¯€ë¡œ ì˜ˆì™¸ë¥¼ ë‹¤ì‹œ ë°œìƒì‹œí‚¤ì§€ ì•Šê³  ë°˜í™˜í•©ë‹ˆë‹¤.
        return f"í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨:\n{error_output}"


def request_ai_code_review(repo_path: str) -> str:
    """
    í˜„ì¬ ìŠ¤í…Œì´ì§•ëœ(staged) ë³€ê²½ ì‚¬í•­ì— ëŒ€í•œ 'git diff'ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
    AIì—ê²Œ ì´ diffë¥¼ ì „ë‹¬í•˜ì—¬ ì½”ë“œ ë¦¬ë·°ë¥¼ ìš”ì²­í•˜ëŠ” í”„ë¡¬í”„íŠ¸ë¥¼ ì¤€ë¹„í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.

    Returns:
        str: AIì—ê²Œ ì½”ë“œ ë¦¬ë·°ë¥¼ ìš”ì²­í•˜ëŠ” í”„ë¡¬í”„íŠ¸ ë¬¸ìì—´.
    """
    logger.info("ìŠ¤í…Œì´ì§•ëœ ë³€ê²½ ì‚¬í•­ì— ëŒ€í•œ ì½”ë“œ ë¦¬ë·°ë¥¼ ì¤€ë¹„í•©ë‹ˆë‹¤.")
    try:
        # --staged ì˜µì…˜ìœ¼ë¡œ ìŠ¤í…Œì´ì§•ëœ ë‚´ìš©ì˜ diffë§Œ ê°€ì ¸ì˜µë‹ˆë‹¤.
        diff_command = ["git", "diff", "--staged"]
        staged_diff = _run_git_command(diff_command, cwd=repo_path)
        
        if not staged_diff:
            return "ì½”ë“œ ë¦¬ë·° ìš”ì²­ ì‹¤íŒ¨: ìŠ¤í…Œì´ì§•ëœ ë³€ê²½ ì‚¬í•­ì´ ì—†ìŠµë‹ˆë‹¤."
            
        prompt = (
            "ë‹¤ìŒì€ ì œê°€ ìˆ˜ì •í•œ ì½”ë“œì˜ diffì…ë‹ˆë‹¤. "
            "ì½”ë“œ ë¦¬ë·°ë¥¼ ìˆ˜í–‰í•´ ì£¼ì„¸ìš”. (ë²„ê·¸, ìŠ¤íƒ€ì¼, ì„±ëŠ¥, ë³´ì•ˆ ê´€ì )\n\n"
            "```diff\n"
            f"{staged_diff}\n"
            "```"
        )
        return prompt
        
    except Exception as e:
        logger.error(f"ì½”ë“œ ë¦¬ë·° ì¤€ë¹„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        raise

def clean_up_merged_branches(repo_path: str, remote: str = "origin") -> str:
    """
    ì›ê²© ì €ì¥ì†Œ(remote)ì— ì´ë¯¸ ë³‘í•©(merge)ëœ ë¡œì»¬ ë¸Œëœì¹˜ ëª©ë¡ì„ ë³´ì—¬ì£¼ê³ ,
    ì‚¬ìš©ìê°€ ì„ íƒí•œ ë¸Œëœì¹˜ë“¤ì„ ì•ˆì „í•˜ê²Œ ì‚­ì œí•©ë‹ˆë‹¤.

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œì˜ ê²½ë¡œ.
        remote (str): ê¸°ì¤€ì´ ë˜ëŠ” ì›ê²© ì €ì¥ì†Œ ì´ë¦„.

    Returns:
        str: ì‘ì—… ê²°ê³¼ ìš”ì•½.
    """
    try:
        logger.info(f"'{remote}'ì˜ ìµœì‹  ì •ë³´ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤...")
        git_fetch(repo_path, remote=remote)
        
        current_branch = git_get_current_branch(repo_path)
        
        # ì›ê²©ì— ë³‘í•©ëœ ë¡œì»¬ ë¸Œëœì¹˜ ëª©ë¡ ì¡°íšŒ
        merged_command = ["git", "branch", "--merged", f"{remote}/main"] # main ê¸°ì¤€
        merged_output = _run_git_command(merged_command, cwd=repo_path)
        
        branches_to_clean = []
        for line in merged_output.split('\n'):
            branch_name = line.strip()
            # í˜„ì¬ ë¸Œëœì¹˜, main, develop ë¸Œëœì¹˜ëŠ” ì œì™¸
            if branch_name.startswith("*"):
                continue
            if branch_name in ["main", "master", "develop"]:
                continue
            if branch_name:
                branches_to_clean.append(branch_name)
                
        if not branches_to_clean:
            return "ì •ë¦¬í•  ë¸Œëœì¹˜ê°€ ì—†ìŠµë‹ˆë‹¤. (ì´ë¯¸ ë³‘í•©ëœ ë¡œì»¬ ë¸Œëœì¹˜ ì—†ìŒ)"
            
        selected_branches = present_checkbox_and_get_choices(
            "ë‹¤ìŒ ë¸Œëœì¹˜ë“¤ì€ ì›ê²© 'main'ì— ë³‘í•©ë˜ì—ˆìŠµë‹ˆë‹¤. ì‚­ì œí•  ë¸Œëœì¹˜ë¥¼ ì„ íƒí•˜ì„¸ìš”:",
            choices=branches_to_clean
        )
        
        if not selected_branches:
            return "ë¸Œëœì¹˜ ì •ë¦¬ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."
            
        deleted_log = []
        for branch in selected_branches:
            try:
                # -d ì˜µì…˜ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ì‚­ì œ
                delete_command = ["git", "branch", "-d", branch]
                result = _run_git_command(delete_command, cwd=repo_path)
                deleted_log.append(result)
            except Exception as e:
                deleted_log.append(f"'{branch}' ì‚­ì œ ì‹¤íŒ¨: {e}")
                
        return f"ë¸Œëœì¹˜ ì •ë¦¬ ì™„ë£Œ:\n" + "\n".join(deleted_log)

    except Exception as e:
        logger.error(f"ë¸Œëœì¹˜ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        raise


# ==============================================================================
# 2. ì‹ ê·œ ì›Œí¬í”Œë¡œìš° MCP (ìš”ì²­ 6 + ì¶”ì²œ 3 = 9ê°œ)
# ==============================================================================

def setup_project_environment(repo_path: str, venv_dir: str = ".venv") -> str:
    """
    í”„ë¡œì íŠ¸ì˜ Python ê°€ìƒ í™˜ê²½ì„ ì„¤ì •í•˜ê³  'requirements.txt'ì˜ ì˜ì¡´ì„±ì„ ì„¤ì¹˜í•©ë‹ˆë‹¤.
    (ì›Œí¬í”Œë¡œìš°: ê°€ìƒ í™˜ê²½ ìƒì„± -> requirements.txt ì„¤ì¹˜)

    Args:
        repo_path (str): í”„ë¡œì íŠ¸ ë£¨íŠ¸ ë””ë ‰í† ë¦¬ ê²½ë¡œ.
        venv_dir (str): ìƒì„±í•  ê°€ìƒ í™˜ê²½ ë””ë ‰í† ë¦¬ ì´ë¦„.

    Returns:
        str: ì„±ê³µ ë©”ì‹œì§€.
    """
    logger.info(f"'{repo_path}'ì— ê°€ìƒ í™˜ê²½ ì„¤ì •ì„ ì‹œì‘í•©ë‹ˆë‹¤...")
    
    venv_path = str(Path(repo_path) / venv_dir)
    req_path = Path(repo_path) / "requirements.txt"
    
    # 1. ê°€ìƒ í™˜ê²½ ìƒì„± (ë©±ë“±ì„± ë³´ì¥)
    try:
        venv_result = setup_python_venv(venv_path)
        logger.info(venv_result)
    except FileExistsError:
        logger.warning(f"ê°€ìƒ í™˜ê²½ì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤: {venv_path}")
    
    # 2. requirements.txt ì„¤ì¹˜
    if not req_path.exists():
        msg = f"ê°€ìƒ í™˜ê²½ ìƒì„± ì™„ë£Œ. 'requirements.txt' íŒŒì¼ì´ ì—†ì–´ ì˜ì¡´ì„±ì„ ì„¤ì¹˜í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
        logger.warning(msg)
        return msg
        
    logger.info(f"'requirements.txt' íŒŒì¼ì˜ ì˜ì¡´ì„±ì„ ì„¤ì¹˜í•©ë‹ˆë‹¤...")
    
    # OS í˜¸í™˜ ê°€ëŠ¥í•œ pip ì‹¤í–‰ ê²½ë¡œ
    pip_exe = "pip.exe" if os.name == "nt" else "pip"
    pip_path = str(Path(venv_path) / ("Scripts" if os.name == "nt" else "bin") / pip_exe)
    
    try:
        install_command = [pip_path, "install", "-r", str(req_path)]
        install_result = _run_command(install_command, cwd=repo_path)
        
        return f"ê°€ìƒ í™˜ê²½ ì„¤ì • ë° ì˜ì¡´ì„± ì„¤ì¹˜ ì™„ë£Œ.\n{install_result}"
    except Exception as e:
        error_output = getattr(e, 'stdout', '') + getattr(e, 'stderr', '')
        raise IOError(f"'requirements.txt' ì„¤ì¹˜ ì‹¤íŒ¨: {error_output}")


def install_and_save_package(
    repo_path: str, 
    package_name: str, 
    requirements_file: str = "requirements.txt"
) -> str:
    """
    Python íŒ¨í‚¤ì§€ë¥¼ 'pip install'ë¡œ ì„¤ì¹˜í•˜ê³ ,
    ì„¤ì¹˜ëœ ì •í™•í•œ ë²„ì „ì„ 'requirements.txt' íŒŒì¼ì— ì¶”ê°€(append)í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): 'requirements.txt'ê°€ ìœ„ì¹˜í•œ í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê²½ë¡œ.
        package_name (str): ì„¤ì¹˜í•  íŒ¨í‚¤ì§€ ì´ë¦„ (ì˜ˆ: "requests", "numpy")
        requirements_file (str): ë²„ì „ì„ ê¸°ë¡í•  íŒŒì¼ ì´ë¦„.

    Returns:
        str: ì„±ê³µ ë©”ì‹œì§€ (ì˜ˆ: "requests==2.31.0ì„ ì„¤ì¹˜í•˜ê³  requirements.txtì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.")
    """
    logger.info(f"'{package_name}' íŒ¨í‚¤ì§€ ì„¤ì¹˜ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...")
    try:
        # 1. íŒ¨í‚¤ì§€ ì„¤ì¹˜
        install_command = ["python", "-m", "pip", "install", package_name]
        install_result = _run_command(install_command, cwd=repo_path)
        logger.info(f"ì„¤ì¹˜ ì™„ë£Œ: {install_result}")

        # 2. ì„¤ì¹˜ëœ ë²„ì „ í™•ì¸
        show_command = ["python", "-m", "pip", "show", package_name]
        show_result = _run_command(show_command, cwd=repo_path)
        
        version_match = re.search(r"Version: (.+)", show_result)
        if not version_match:
            raise ValueError(f"'{package_name}'ì˜ ì„¤ì¹˜ëœ ë²„ì „ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            
        version = version_match.group(1).strip()
        package_spec = f"{package_name}=={version}"

        # 3. requirements.txtì— ì¶”ê°€
        req_path = Path(repo_path) / requirements_file
        logger.info(f"'{package_spec}'ì„(ë¥¼) '{req_path}' íŒŒì¼ì— ì¶”ê°€í•©ë‹ˆë‹¤.")
        
        # íŒŒì¼ ëì— ê°œí–‰ ë¬¸ìê°€ ì—†ìœ¼ë©´ ì¶”ê°€
        current_content = read_file(str(req_path)) if req_path.exists() else ""
        prefix = "\n" if current_content and not current_content.endswith("\n") else ""
        
        append_to_file(str(req_path), f"{prefix}{package_spec}\n")
        
        return f"'{package_spec}'ì„(ë¥¼) ì„¤ì¹˜í•˜ê³  '{requirements_file}'ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤."
        
    except Exception as e:
        error_output = getattr(e, 'stdout', '') + getattr(e, 'stderr', '')
        raise RuntimeError(f"íŒ¨í‚¤ì§€ ì„¤ì¹˜ ë° ì €ì¥ ì¤‘ ì˜¤ë¥˜: {e} - {error_output}")


def check_for_outdated_packages(repo_path: str) -> str:
    """
    'pip list --outdated'ë¥¼ ì‹¤í–‰í•˜ì—¬ ì˜¤ë˜ëœ Python íŒ¨í‚¤ì§€ ëª©ë¡ì„ ë³´ê³ í•©ë‹ˆë‹¤.
    AIê°€ í”„ë¡œì íŠ¸ ìœ ì§€ë³´ìˆ˜ ì‘ì—…ì„ ì‹œì‘í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): í”„ë¡œì íŠ¸ ê²½ë¡œ (pip ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸).

    Returns:
        str: 'pip list --outdated'ì˜ ì‹¤í–‰ ê²°ê³¼.
    """
    logger.info("ì˜¤ë˜ëœ íŒ¨í‚¤ì§€ê°€ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤...")
    command = ["python", "-m", "pip", "list", "--outdated"]
    try:
        result = _run_command(command, cwd=repo_path)
        if not result:
            return "ëª¨ë“  íŒ¨í‚¤ì§€ê°€ ìµœì‹  ë²„ì „ì…ë‹ˆë‹¤."
        return f"ì˜¤ë˜ëœ íŒ¨í‚¤ì§€ ëª©ë¡:\n{result}"
    except Exception as e:
        # 'pip' ìì²´ê°€ ì˜¤ë¥˜ë¥¼ ë‚¼ ê²½ìš° (ì˜ˆ: venv ì„¤ì • ì˜¤ë¥˜)
        error_output = getattr(e, 'stdout', '') + getattr(e, 'stderr', '')
        raise RuntimeError(f"íŒ¨í‚¤ì§€ í™•ì¸ ì¤‘ ì˜¤ë¥˜: {e} - {error_output}")


def scaffold_test_file_prompt(
    source_file_path: str, 
    test_style_guide_path: str
) -> str:
    """
    AIê°€ ìƒˆ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ìƒì„±í•  ìˆ˜ ìˆë„ë¡, ì†ŒìŠ¤ ì½”ë“œì™€ í…ŒìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ ê°€ì´ë“œ(ì˜ˆì‹œ)ë¥¼
    í¬í•¨í•œ í”„ë¡¬í”„íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. (AI í”Œë˜ë„ˆì˜ RAG ì¤€ë¹„ ë‹¨ê³„)

    Args:
        source_file_path (str): í…ŒìŠ¤íŠ¸ë¥¼ ìƒì„±í•  ëŒ€ìƒ ì†ŒìŠ¤ ì½”ë“œ íŒŒì¼ ê²½ë¡œ.
        test_style_guide_path (str): ì°¸ê³ í•  í…ŒìŠ¤íŠ¸ ì½”ë“œ ì˜ˆì‹œ íŒŒì¼ ê²½ë¡œ.

    Returns:
        str: AIì—ê²Œ í…ŒìŠ¤íŠ¸ ìƒì„±ì„ ìš”ì²­í•˜ëŠ” ì™„ì„±ëœ í”„ë¡¬í”„íŠ¸.
    """
    logger.info(f"'{source_file_path}'ì— ëŒ€í•œ í…ŒìŠ¤íŠ¸ ì½”ë“œ ìƒì„± í”„ë¡¬í”„íŠ¸ë¥¼ ì¤€ë¹„í•©ë‹ˆë‹¤.")
    try:
        source_code = read_file(source_file_path)
        style_guide_code = read_file(test_style_guide_path)
        
        prompt = f"""
        ë‹¹ì‹ ì€ Python í…ŒìŠ¤íŠ¸ ì½”ë“œ ì‘ì„± ì „ë¬¸ê°€ì…ë‹ˆë‹¤.
        ë‹¤ìŒ ì†ŒìŠ¤ ì½”ë“œì— ëŒ€í•´ 'pytest'ì™€ 'pytest-mock'ì„ ì‚¬ìš©í•œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.

        [í…ŒìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ ê°€ì´ë“œ (ì´ ì½”ë“œì˜ í˜•ì‹ì„ ë”°ë¥´ì„¸ìš”)]
        ```python
        {style_guide_code}
        ```

        [í…ŒìŠ¤íŠ¸ ëŒ€ìƒ ì†ŒìŠ¤ ì½”ë“œ: {source_file_path}]
        ```python
        {source_code}
        ```

        [ì§€ì‹œì‚¬í•­]
        - ìœ„ ìŠ¤íƒ€ì¼ ê°€ì´ë“œë¥¼ ì² ì €íˆ ì¤€ìˆ˜í•˜ì„¸ìš” (ì˜ˆ: fixture ì‚¬ìš©, mocker í™œìš©).
        - ëª¨ë“  ê³µê°œ í•¨ìˆ˜ì™€ ì£¼ìš” ì—£ì§€ ì¼€ì´ìŠ¤ë¥¼ ì»¤ë²„í•˜ëŠ” í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
        - ë§ˆí¬ë‹¤ìš´ ë˜í¼ë¥¼ í¬í•¨í•œ ì™„ì „í•œ í…ŒìŠ¤íŠ¸ íŒŒì¼ ì½”ë“œë¥¼ ë°˜í™˜í•´ ì£¼ì„¸ìš”.

        [í…ŒìŠ¤íŠ¸ ì½”ë“œ]
        """
        return prompt.strip()
        
    except Exception as e:
        logger.error(f"í…ŒìŠ¤íŠ¸ í”„ë¡¬í”„íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜: {e}")
        raise


def run_specific_test_and_get_context(
    repo_path: str, 
    test_path: str
) -> str:
    """
    'pytest'ë¥¼ ì‚¬ìš©í•´ ì§€ì •ëœ ê°œë³„ í…ŒìŠ¤íŠ¸(íŒŒì¼ ë˜ëŠ” í•¨ìˆ˜)ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.
    í…ŒìŠ¤íŠ¸ í†µê³¼ ì‹œ ì„±ê³µ ë©”ì‹œì§€ë¥¼, ì‹¤íŒ¨ ì‹œ ìƒì„¸í•œ ì˜¤ë¥˜ ë¡œê·¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    (AIê°€ ì˜¤ë¥˜ë¥¼ ë³´ê³  ìˆ˜ì • ê³„íšì„ ì„¸ìš¸ ìˆ˜ ìˆë„ë¡)

    Args:
        repo_path (str): pytestë¥¼ ì‹¤í–‰í•  í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê²½ë¡œ.
        test_path (str): ì‹¤í–‰í•  í…ŒìŠ¤íŠ¸ íŒŒì¼ ë˜ëŠ” í•¨ìˆ˜ ê²½ë¡œ (ì˜ˆ: "tests/test_main.py::test_func")

    Returns:
        str: í…ŒìŠ¤íŠ¸ ì„±ê³µ ë©”ì‹œì§€ ë˜ëŠ” ì‹¤íŒ¨ ë¡œê·¸.
    """
    logger.info(f"ì§€ì •ëœ í…ŒìŠ¤íŠ¸ ì‹¤í–‰: pytest {test_path}")
    command = ["pytest", test_path]
    
    try:
        result = _run_command(command, cwd=repo_path)
        logger.info(f"í…ŒìŠ¤íŠ¸ í†µê³¼: {test_path}")
        return f"í…ŒìŠ¤íŠ¸ í†µê³¼:\n{result}"
    except Exception as e:
        # pytestëŠ” ì‹¤íŒ¨ ì‹œ 0ì´ ì•„ë‹Œ ì½”ë“œë¥¼ ë°˜í™˜í•˜ë©° ì˜ˆì™¸ ë°œìƒ
        error_output = getattr(e, 'stdout', '') + getattr(e, 'stderr', '')
        if not error_output:
            error_output = str(e)
            
        logger.warning(f"í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {test_path}\n{error_output}")
        # AIê°€ ì˜¤ë¥˜ë¥¼ ë¶„ì„í•  ìˆ˜ ìˆë„ë¡ ì „ì²´ ë¡œê·¸ë¥¼ ë°˜í™˜
        return f"í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {test_path}\n{error_output}"


def view_and_discard_changes(repo_path: str) -> str:
    """
    í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬ì˜ ë³€ê²½ ì‚¬í•­(Untracked/Modified)ì„ 'git diff'ë¡œ ë³´ì—¬ì£¼ê³ ,
    ì‚¬ìš©ìê°€ ìŠ¹ì¸í•˜ë©´ ëª¨ë“  ë³€ê²½ ì‚¬í•­ì„ íê¸°(discard)í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): Git ì €ì¥ì†Œ ê²½ë¡œ.

    Returns:
        str: ì‘ì—… ì„±ê³µ ë˜ëŠ” ì·¨ì†Œ ë©”ì‹œì§€.
    """
    logger.info("í˜„ì¬ Git ë³€ê²½ ì‚¬í•­ì„ í™•ì¸í•©ë‹ˆë‹¤...")
    try:
        status = git_status(repo_path)
        diff = git_diff(repo_path)
        
        if "nothing to commit" in status and not diff:
            return "íê¸°í•  ë³€ê²½ ì‚¬í•­ì´ ì—†ìŠµë‹ˆë‹¤."
            
        prompt = (
            "ë‹¤ìŒ ë³€ê²½ ì‚¬í•­ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. ëª¨ë‘ íê¸°í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n"
            f"[ìƒíƒœ ìš”ì•½]\n{status}\n\n"
            f"[ìƒì„¸ ë³€ê²½ ë‚´ì—­]\n{diff}\n"
        )
        
        if ask_user_for_confirmation(prompt):
            logger.warning("ëª¨ë“  ë¡œì»¬ ë³€ê²½ ì‚¬í•­ì„ íê¸°í•©ë‹ˆë‹¤...")
            # 1. Modified ë³€ê²½ ì‚¬í•­ ë˜ëŒë¦¬ê¸°
            _run_git_command(["git", "restore", "."], cwd=repo_path)
            # 2. Untracked íŒŒì¼ ë° ë””ë ‰í† ë¦¬ ì œê±°
            _run_git_command(["git", "clean", "-fd"], cwd=repo_path)
            
            return "ëª¨ë“  ë¡œì»¬ ë³€ê²½ ì‚¬í•­ì„ íê¸°í–ˆìŠµë‹ˆë‹¤."
        else:
            return "ì‘ì—…ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."
            
    except Exception as e:
        logger.error(f"ë³€ê²½ ì‚¬í•­ íê¸° ì¤‘ ì˜¤ë¥˜: {e}")
        raise

# ==============================================================================
# 3. ì¶”ê°€ ì¶”ì²œ ì›Œí¬í”Œë¡œìš° MCP (3ê°œ)
# ==============================================================================

def autofix_lint_errors(repo_path: str) -> str:
    """
    [ì¶”ì²œ] 'black'ê³¼ 'isort'ë¥¼ ì‹¤í–‰í•˜ì—¬ í”„ë¡œì íŠ¸ ì „ì²´ì˜ ì½”ë“œ ìŠ¤íƒ€ì¼ì„ ìë™ìœ¼ë¡œ ìˆ˜ì •í•©ë‹ˆë‹¤.
    AIê°€ ìƒì„±í•œ ì½”ë“œì˜ ìŠ¤íƒ€ì¼ì„ ì¼ê´€ë˜ê²Œ ë§ì¶œ ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): í¬ë§·íŒ…ì„ ì ìš©í•  í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê²½ë¡œ.

    Returns:
        str: 'black'ê³¼ 'isort'ì˜ ì‹¤í–‰ ê²°ê³¼ ìš”ì•½.
    """
    logger.info(f"'{repo_path}'ì˜ ì½”ë“œ ìŠ¤íƒ€ì¼ ìë™ ìˆ˜ì •ì„ ì‹œì‘í•©ë‹ˆë‹¤ (isort, black)...")
    results = []
    
    try:
        # 1. isort ì‹¤í–‰
        isort_command = ["isort", "."]
        isort_result = _run_command(isort_command, cwd=repo_path)
        results.append(f"[isort ê²°ê³¼]\n{isort_result}")
    except Exception as e:
        results.append(f"[isort ì‹¤í–‰ ì‹¤íŒ¨]\n{e}")
        
    try:
        # 2. black ì‹¤í–‰
        black_command = ["black", "."]
        black_result = _run_command(black_command, cwd=repo_path)
        results.append(f"[black ê²°ê³¼]\n{black_result}")
    except Exception as e:
        results.append(f"[black ì‹¤í–‰ ì‹¤íŒ¨]\n{e}")
        
    return "ì½”ë“œ ìë™ ìˆ˜ì • ì™„ë£Œ:\n\n" + "\n\n".join(results)


def apply_git_patch(repo_path: str, patch_content: str) -> str:
    """
    [ì¶”ì²œ] AIê°€ ìƒì„±í•œ diff/patch ë¬¸ìì—´ì„ ì„ì‹œ íŒŒì¼ë¡œ ì €ì¥í•œ ë’¤,
    'git apply'ë¥¼ í†µí•´ í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬ì— ì ìš©í•©ë‹ˆë‹¤.

    Args:
        repo_path (str): íŒ¨ì¹˜ë¥¼ ì ìš©í•  Git ì €ì¥ì†Œ ê²½ë¡œ.
        patch_content (str): AIê°€ ì œê³µí•œ '.patch' ë˜ëŠ” 'diff' í˜•ì‹ì˜ ë¬¸ìì—´.

    Returns:
        str: 'git apply' ì„±ê³µ ë˜ëŠ” ì‹¤íŒ¨ ë©”ì‹œì§€.
    """
    patch_file = Path(repo_path) / ".temp_ai_patch.patch"
    try:
        logger.info("AIê°€ ì œì•ˆí•œ íŒ¨ì¹˜ë¥¼ ì„ì‹œ íŒŒì¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤...")
        write_file(str(patch_file), patch_content)
        
        logger.info(f"'{patch_file.name}' íŒ¨ì¹˜ë¥¼ ì ìš©í•©ë‹ˆë‹¤...")
        # 3-way merge ì˜µì…˜ìœ¼ë¡œ ì¶©ëŒì„ ë” ì˜ ì²˜ë¦¬
        apply_command = ["git", "apply", "--3way", str(patch_file.name)]
        result = _run_git_command(apply_command, cwd=repo_path)
        
        return f"íŒ¨ì¹˜ ì ìš© ì„±ê³µ:\n{result}"
        
    except Exception as e:
        error_output = getattr(e, 'stdout', '') + getattr(e, 'stderr', '')
        raise RuntimeError(f"íŒ¨ì¹˜ ì ìš© ì‹¤íŒ¨: {e} - {error_output}")
    finally:
        # ì‘ì—… ì™„ë£Œ í›„ ì„ì‹œ íŒ¨ì¹˜ íŒŒì¼ ì‚­ì œ
        if patch_file.exists():
            patch_file.unlink()
            logger.info("ì„ì‹œ íŒ¨ì¹˜ íŒŒì¼ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.")


def complete_feature_branch(repo_path: str, main_branch: str = "main") -> str:
    """
    [ì¶”ì²œ] í˜„ì¬ ê¸°ëŠ¥ ë¸Œëœì¹˜ ì‘ì—…ì„ ì™„ë£Œí•˜ê³ , 'main' ë¸Œëœì¹˜ë¡œ ë³‘í•© ë° ì •ë¦¬í•©ë‹ˆë‹¤.
    (ì›Œí¬í”Œë¡œìš°: main ì „í™˜ -> main ìµœì‹ í™” -> ê¸°ëŠ¥ ë¸Œëœì¹˜ ë³‘í•© -> main í‘¸ì‹œ -> ê¸°ëŠ¥ ë¸Œëœì¹˜ ì‚­ì œ)

    Args:
        repo_path (str): ëŒ€ìƒ Git ì €ì¥ì†Œ ê²½ë¡œ.
        main_branch (str): ë³‘í•©ì˜ ê¸°ì¤€ì´ ë  ë©”ì¸ ë¸Œëœì¹˜ ì´ë¦„.

    Returns:
        str: ì‘ì—… ì„±ê³µ ìš”ì•½.
    """
    logger.info("ê¸°ëŠ¥ ë¸Œëœì¹˜ ë³‘í•© ë° ì •ë¦¬ ì›Œí¬í”Œë¡œìš°ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.")
    try:
        feature_branch = git_get_current_branch(repo_path)
        if not feature_branch:
            raise GitCommandError("í˜„ì¬ ë¸Œëœì¹˜ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (Detached HEAD?).")
        if feature_branch == main_branch:
            raise GitCommandError(f"ì´ë¯¸ '{main_branch}' ë¸Œëœì¹˜ì— ìˆìŠµë‹ˆë‹¤. ê¸°ëŠ¥ ë¸Œëœì¹˜ì—ì„œ ì‹¤í–‰í•´ì•¼ í•©ë‹ˆë‹¤.")

        logger.info(f"í˜„ì¬ ê¸°ëŠ¥ ë¸Œëœì¹˜: {feature_branch}")
        
        # 1. ë©”ì¸ ë¸Œëœì¹˜ë¡œ ì „í™˜ ë° ìµœì‹ í™”
        switch_result = switch_to_main_and_pull(repo_path, branch_name=main_branch)
        logger.info(switch_result)
        
        # 2. ê¸°ëŠ¥ ë¸Œëœì¹˜ ë³‘í•©
        logger.info(f"'{feature_branch}'ì„(ë¥¼) '{main_branch}'(ìœ¼)ë¡œ ë³‘í•©í•©ë‹ˆë‹¤...")
        merge_command = ["git", "merge", "--no-ff", feature_branch] # No-Fast-Forward
        merge_result = _run_git_command(merge_command, cwd=repo_path)
        logger.info(f"ë³‘í•© ì™„ë£Œ:\n{merge_result}")
        
        # 3. ë©”ì¸ ë¸Œëœì¹˜ í‘¸ì‹œ
        push_result = git_push(repo_path, "origin", main_branch)
        logger.info(f"í‘¸ì‹œ ì™„ë£Œ:\n{push_result}")
        
        # 4. ë¡œì»¬ ê¸°ëŠ¥ ë¸Œëœì¹˜ ì‚­ì œ
        logger.info(f"ë¡œì»¬ ë¸Œëœì¹˜ '{feature_branch}'ì„(ë¥¼) ì‚­ì œí•©ë‹ˆë‹¤...")
        delete_command = ["git", "branch", "-d", feature_branch]
        delete_result = _run_git_command(delete_command, cwd=repo_path)
        
        return (
            f"ì›Œí¬í”Œë¡œìš° ì™„ë£Œ:\n"
            f"1. '{feature_branch}'ê°€ '{main_branch}'ì— ë³‘í•©ë˜ì—ˆìŠµë‹ˆë‹¤.\n"
            f"2. '{main_branch}'ê°€ 'origin'ì— í‘¸ì‹œë˜ì—ˆìŠµë‹ˆë‹¤.\n"
            f"3. ë¡œì»¬ ë¸Œëœì¹˜ '{feature_branch}'ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤."
        )

    except Exception as e:
        logger.error(f"ê¸°ëŠ¥ ë¸Œëœì¹˜ ì™„ë£Œ ì¤‘ ì˜¤ë¥˜: {e}")
        # ì¶©ëŒ ë˜ëŠ” ì˜¤ë¥˜ ë°œìƒ ì‹œ ì‚¬ìš©ì ê°œì…ì„ ìœ„í•´ í˜„ì¬ ìƒíƒœë¥¼ ì•Œë¦¼
        try:
            current_status = git_status(repo_path)
            raise RuntimeError(f"ì›Œí¬í”Œë¡œìš° ì‹¤íŒ¨: {e}\n\ní˜„ì¬ ìƒíƒœ:\n{current_status}")
        except Exception as status_e:
            raise RuntimeError(f"ì›Œí¬í”Œë¡œìš° ì‹¤íŒ¨: {e}\n(í˜„ì¬ ìƒíƒœ í™•ì¸ë„ ì‹¤íŒ¨: {status_e})")
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
user_interaction_atomic.py

ì‚¬ìš©ì ìƒí˜¸ì‘ìš©ì„ ìœ„í•œ ì›ìì (Atomic) MCP(Mission Control Primitives) ëª¨ìŒ.
ì´ ëª¨ë“ˆì€ í„°ë¯¸ë„ í™˜ê²½ì—ì„œ ì‚¬ìš©ìë¡œë¶€í„° ì…ë ¥ì„ ë°›ê±°ë‚˜ ì •ë³´ë¥¼ í‘œì‹œí•˜ëŠ”
ë‹¤ì–‘í•œ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
"""

import getpass
import logging
import os
import sys
import time
from typing import Any, Dict, List, Optional

from rich.console import Console
from rich.live import Live
from rich.markdown import Markdown
from rich.progress import Progress
from rich.prompt import Confirm, Prompt
from rich.spinner import Spinner
from rich.table import Table

# --- ì´ˆê¸° ì„¤ì • ---
# ë¡œê±° ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Rich ì½˜ì†” ê°ì²´ ì´ˆê¸°í™”
console = Console()


# --- MCP í•¨ìˆ˜ ì •ì˜ ---

def ask_user_for_input(question: str) -> str:
    """ì‚¬ìš©ìì—ê²Œ ë‹¨ì¼ í…ìŠ¤íŠ¸ ë¼ì¸ ì§ˆë¬¸ì„ ë˜ì§€ê³ , ë¬¸ìì—´ ì…ë ¥ì„ ë°›ì•„ ë°˜í™˜í•©ë‹ˆë‹¤.

    'rich' ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ Promptë¥¼ ì‚¬ìš©í•˜ì—¬ ì‚¬ìš©ìì—ê²Œ ëª…í™•í•œ ì§ˆë¬¸ì„ ì œì‹œí•©ë‹ˆë‹¤.

    Args:
        question (str): ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ì§ˆë¬¸ ë¬¸ìì—´.

    Returns:
        str: ì‚¬ìš©ìê°€ ì…ë ¥í•œ í…ìŠ¤íŠ¸.

    Example:
        >>> project_name = ask_user_for_input("í”„ë¡œì íŠ¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:")
        >>> print(f"í”„ë¡œì íŠ¸ ì´ë¦„: {project_name}")
    """
    logger.info(f"ì‚¬ìš©ìì—ê²Œ ì§ˆë¬¸ ìš”ì²­: '{question}'")
    # ë³´ì•ˆ: Rich ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ê¸°ë³¸ì ì¸ ì…ë ¥ ì²˜ë¦¬ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.
    # ì¶”ê°€ì ì¸ ì •ì œ(sanitization)ê°€ í•„ìš”í•˜ë‹¤ë©´ ì´ ë‹¨ê³„ ì´í›„ì— ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤.
    response = Prompt.ask(question)
    logger.info(f"ì‚¬ìš©ìë¡œë¶€í„° ì…ë ¥ ë°›ìŒ: '{response}'")
    return response

def ask_for_multiline_input(prompt: str) -> str:
    """ì‚¬ìš©ìì—ê²Œ ì—¬ëŸ¬ ì¤„ì˜ í…ìŠ¤íŠ¸ ì…ë ¥ì„ ìš”ì²­í•˜ê³  ë°˜í™˜í•©ë‹ˆë‹¤.

    ì‚¬ìš©ìëŠ” ì…ë ¥ì„ ë§ˆì¹œ í›„, ìƒˆ ì¤„ì— 'EOF'ë¥¼ ì…ë ¥í•˜ì—¬ ì¢…ë£Œ ì‹ í˜¸ë¥¼ ë³´ëƒ…ë‹ˆë‹¤.

    Args:
        prompt (str): ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ì•ˆë‚´ ë©”ì‹œì§€.

    Returns:
        str: ì‚¬ìš©ìê°€ ì…ë ¥í•œ ì—¬ëŸ¬ ì¤„ì˜ í…ìŠ¤íŠ¸.

    Example:
        >>> commit_message = ask_for_multiline_input("ì»¤ë°‹ ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì¢…ë£Œí•˜ë ¤ë©´ EOF ì…ë ¥):")
        >>> print(commit_message)
    """
    logger.info(f"ì‚¬ìš©ìì—ê²Œ ì—¬ëŸ¬ ì¤„ ì…ë ¥ ìš”ì²­: '{prompt}'")
    console.print(f"{prompt} (ì¢…ë£Œí•˜ë ¤ë©´ ìƒˆ ì¤„ì— 'EOF'ë¥¼ ì…ë ¥í•˜ì„¸ìš”)")
    lines = []
    while True:
        try:
            line = input()
            if line.strip().upper() == 'EOF':
                break
            lines.append(line)
        except EOFError:  # Ctrl+D / Ctrl+Z
            break
    result = "\n".join(lines)
    logger.info("ì‚¬ìš©ìë¡œë¶€í„° ì—¬ëŸ¬ ì¤„ ì…ë ¥ ì™„ë£Œ.")
    return result

def ask_user_for_confirmation(question: str) -> bool:
    """ì‚¬ìš©ìì—ê²Œ ì˜ˆ(Yes)/ì•„ë‹ˆì˜¤(No) ì§ˆë¬¸ì„ í•˜ê³ , True/False ë¶ˆë¦¬ì–¸ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        question (str): ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  í™•ì¸ ì§ˆë¬¸.

    Returns:
        bool: ì‚¬ìš©ìê°€ 'ì˜ˆ'ë¥¼ ì„ íƒí•˜ë©´ True, 'ì•„ë‹ˆì˜¤'ë¥¼ ì„ íƒí•˜ë©´ False.

    Example:
        >>> if ask_user_for_confirmation("ì •ë§ë¡œ íŒŒì¼ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?"):
        ...     print("íŒŒì¼ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.")
        ... else:
        ...     print("ì‚­ì œë¥¼ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.")
    """
    logger.info(f"ì‚¬ìš©ìì—ê²Œ í™•ì¸ ìš”ì²­: '{question}'")
    response = Confirm.ask(question, default=False)
    logger.info(f"ì‚¬ìš©ì í™•ì¸ ì‘ë‹µ: {response}")
    return response

def ask_for_password(prompt: str) -> str:
    """ì‚¬ìš©ìì—ê²Œ ë¯¼ê°í•œ ì •ë³´(ë¹„ë°€ë²ˆí˜¸ ë“±)ë¥¼ ì…ë ¥ë°›ìŠµë‹ˆë‹¤. ì…ë ¥ ë‚´ìš©ì€ í™”ë©´ì— í‘œì‹œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

    Args:
        prompt (str): ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ì•ˆë‚´ ë©”ì‹œì§€.

    Returns:
        str: ì‚¬ìš©ìê°€ ì…ë ¥í•œ ë¹„ë°€ë²ˆí˜¸ ë¬¸ìì—´.

    Raises:
        IOError: í„°ë¯¸ë„ì´ ì—†ì–´ getpassë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” í™˜ê²½ì¼ ê²½ìš° ë°œìƒ.

    Example:
        >>> api_key = ask_for_password("API í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”:")
    """
    logger.info(f"ì‚¬ìš©ìì—ê²Œ ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ ìš”ì²­: '{prompt}'")
    try:
        # ë³´ì•ˆ: getpassëŠ” í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì œê³µí•˜ëŠ” ì•ˆì „í•œ ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ ë°©ì‹ì…ë‹ˆë‹¤.
        password = getpass.getpass(prompt + " ")
        logger.info("ì‚¬ìš©ìë¡œë¶€í„° ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ ì™„ë£Œ.")
        return password
    except Exception as e:
        logger.error(f"ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}", exc_info=True)
        raise IOError("ì•ˆì „í•œ ì…ë ¥ í™˜ê²½(í„°ë¯¸ë„)ì´ ì•„ë‹ˆë¯€ë¡œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.") from e

def show_message(message: str):
    """ì‚¬ìš©ìì—ê²Œ ë‹¨ìˆœ ì •ë³´ì„± ë©”ì‹œì§€ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.

    Args:
        message (str): ì¶œë ¥í•  ë©”ì‹œì§€.

    Example:
        >>> show_message("ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤.")
    """
    logger.info(f"ë©”ì‹œì§€ í‘œì‹œ: '{message}'")
    console.print(message)

def display_table(data: List[Dict[str, Any]], headers: List[str]):
    """êµ¬ì¡°í™”ëœ ë°ì´í„°ë¥¼ í‘œ(Table) í˜•ì‹ìœ¼ë¡œ ê¹”ë”í•˜ê²Œ ì¶œë ¥í•©ë‹ˆë‹¤.

    Args:
        data (List[Dict[str, Any]]): í‘œë¡œ ë§Œë“¤ ë°ì´í„°. ê° ë”•ì…”ë„ˆë¦¬ê°€ í–‰(row)ì´ ë©ë‹ˆë‹¤.
        headers (List[str]): í‘œì˜ í—¤ë”(ì—´ ì œëª©) ë¦¬ìŠ¤íŠ¸. ë”•ì…”ë„ˆë¦¬ì˜ í‚¤ì™€ ì¼ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤.

    Raises:
        ValueError: ë°ì´í„°ë‚˜ í—¤ë”ê°€ ë¹„ì–´ìˆê±°ë‚˜ í˜•ì‹ì´ ë§ì§€ ì•Šì„ ê²½ìš° ë°œìƒ.

    Example:
        >>> users = [{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}]
        >>> display_table(users, headers=["id", "name"])
    """
    if not headers or not data:
        logger.warning("í…Œì´ë¸” ë°ì´í„°ë‚˜ í—¤ë”ê°€ ë¹„ì–´ ìˆì–´ í‘œì‹œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        raise ValueError("ë°ì´í„°ì™€ í—¤ë”ëŠ” ë¹„ì–´ ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    logger.info(f"{len(data)}ê°œ í–‰ì˜ í…Œì´ë¸” í‘œì‹œ.")
    table = Table(show_header=True, header_style="bold magenta")
    for header in headers:
        table.add_column(header)

    try:
        for item in data:
            # ëª¨ë“  í—¤ë” í‚¤ê°€ ë°ì´í„°ì— ìˆëŠ”ì§€ í™•ì¸í•˜ê³ , ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´ë¡œ ì²˜ë¦¬
            row_values = [str(item.get(h, "")) for h in headers]
            table.add_row(*row_values)
        console.print(table)
    except Exception as e:
        logger.error(f"í…Œì´ë¸” ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}", exc_info=True)
        raise ValueError("í…Œì´ë¸” ë°ì´í„° í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤.") from e

def show_progress_bar(total: int, description: str = "Processing..."):
    """ì „ì²´ ì‘ì—…ëŸ‰ì— ëŒ€í•œ ì§„í–‰ë¥  í‘œì‹œì¤„(Progress Bar)ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

    ì´ í•¨ìˆ˜ëŠ” ì§„í–‰ ìƒí™©ì„ ì‹œë®¬ë ˆì´ì…˜í•˜ë©° ë³´ì—¬ì£¼ëŠ” ì˜ˆì œì…ë‹ˆë‹¤.
    ì‹¤ì œ ì‚¬ìš© ì‹œì—ëŠ” 'with' êµ¬ë¬¸ê³¼ í•¨ê»˜ progress ê°ì²´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‘ì—…ì„ ê°ì‹¸ì•¼ í•©ë‹ˆë‹¤.

    Args:
        total (int): ì „ì²´ ì‘ì—…ëŸ‰ (ì˜ˆ: 100).
        description (str, optional): ì§„í–‰ë¥  í‘œì‹œì¤„ì— í‘œì‹œë  ì„¤ëª…. ê¸°ë³¸ê°’ì€ "Processing...".

    Example:
        >>> show_progress_bar(100, "íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘")
    """
    logger.info(f"'{description}' ì‘ì—…ì— ëŒ€í•œ ì§„í–‰ë¥  í‘œì‹œì¤„ ì‹œì‘ (ì´ {total}).")
    with Progress(console=console) as progress:
        task = progress.add_task(f"[cyan]{description}", total=total)
        while not progress.finished:
            progress.update(task, advance=1)
            time.sleep(0.02)
    logger.info("ì§„í–‰ë¥  í‘œì‹œì¤„ ì™„ë£Œ.")

def clear_screen():
    """í„°ë¯¸ë„ì´ë‚˜ ì½˜ì†” í™”ë©´ì„ ê¹¨ë—í•˜ê²Œ ì§€ì›ë‹ˆë‹¤.

    ìš´ì˜ì²´ì œì— ë”°ë¼ ì ì ˆí•œ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

    Example:
        >>> show_message("ì´ ë©”ì‹œì§€ëŠ” ê³§ ì‚¬ë¼ì§‘ë‹ˆë‹¤.")
        >>> time.sleep(2)
        >>> clear_screen()
    """
    logger.info("í™”ë©´ ì§€ìš°ê¸° ì‹¤í–‰.")
    # ë©±ë“±ì„±: ì—¬ëŸ¬ ë²ˆ ì‹¤í–‰í•´ë„ í™”ë©´ì´ ê¹¨ë—í•œ ìƒíƒœëŠ” ë™ì¼í•©ë‹ˆë‹¤.
    command = 'cls' if os.name == 'nt' else 'clear'
    os.system(command)

def show_alert(message: str, level: str = "info"):
    """ì‹¬ê°ë„ ìˆ˜ì¤€ì— ë”°ë¼ ë‹¤ë¥¸ ìŠ¤íƒ€ì¼ì˜ ê²½ê³  ë©”ì‹œì§€ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.

    Args:
        message (str): í‘œì‹œí•  ê²½ê³  ë©”ì‹œì§€.
        level (str, optional): ê²½ê³  ìˆ˜ì¤€. 'info', 'success', 'warning', 'error' ì¤‘ í•˜ë‚˜.
                               ê¸°ë³¸ê°’ì€ 'info'.

    Example:
        >>> show_alert("ì„¤ì •ì´ ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.", level="success")
        >>> show_alert("API í‚¤ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.", level="error")
    """
    level = level.lower()
    styles = {
        "info": "cyan",
        "success": "green",
        "warning": "yellow",
        "error": "bold red"
    }
    style = styles.get(level, "default")
    prefix = f"[{level.upper()}]"
    logger.info(f"'{level}' ìˆ˜ì¤€ì˜ ê²½ê³  í‘œì‹œ: '{message}'")
    console.print(f"[{style}]{prefix} {message}[/]")

def render_markdown(markdown_text: str):
    """ë§ˆí¬ë‹¤ìš´ í˜•ì‹ì˜ í…ìŠ¤íŠ¸ë¥¼ ì„œì‹ì´ ì ìš©ëœ í˜•íƒœë¡œ í„°ë¯¸ë„ì— ì¶œë ¥í•©ë‹ˆë‹¤.

    Args:
        markdown_text (str): ë Œë”ë§í•  ë§ˆí¬ë‹¤ìš´ í…ìŠ¤íŠ¸.

    Example:
        >>> doc = "# ì œëª©\\n* í•­ëª© 1\\n* í•­ëª© 2"
        >>> render_markdown(doc)
    """
    logger.info("ë§ˆí¬ë‹¤ìš´ í…ìŠ¤íŠ¸ ë Œë”ë§.")
    md = Markdown(markdown_text)
    console.print(md)

def show_spinner(message: str, duration_sec: float = 2.0):
    """ì‘ì—…ì´ ì§„í–‰ ì¤‘ì„ì„ ì•Œë¦¬ëŠ” ì• ë‹ˆë©”ì´ì…˜ ìŠ¤í”¼ë„ˆë¥¼ ì¼ì • ì‹œê°„ ë™ì•ˆ ë³´ì—¬ì¤ë‹ˆë‹¤.

    ì´ í•¨ìˆ˜ëŠ” ìŠ¤í”¼ë„ˆë¥¼ ë³´ì—¬ì£¼ëŠ” ì˜ˆì œì…ë‹ˆë‹¤. ì‹¤ì œë¡œëŠ” ì˜¤ë˜ ê±¸ë¦¬ëŠ” ì‘ì—…ê³¼ í•¨ê»˜
    'with console.status(...) as status:' êµ¬ë¬¸ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

    Args:
        message (str): ìŠ¤í”¼ë„ˆì™€ í•¨ê»˜ í‘œì‹œë  ë©”ì‹œì§€.
        duration_sec (float, optional): ìŠ¤í”¼ë„ˆë¥¼ ë³´ì—¬ì¤„ ì‹œê°„(ì´ˆ). ê¸°ë³¸ê°’ì€ 2.0.

    Example:
        >>> show_spinner("ë°ì´í„°ë¥¼ ë¶„ì„í•˜ëŠ” ì¤‘...", duration_sec=3)
    """
    logger.info(f"ìŠ¤í”¼ë„ˆ ì‹œì‘: '{message}'")
    with console.status(f"[bold green]{message}"):
        time.sleep(duration_sec)
    logger.info("ìŠ¤í”¼ë„ˆ ì¢…ë£Œ.")

def update_last_line(message: str):
    """ì½˜ì†”ì˜ ë§ˆì§€ë§‰ ë¼ì¸ì— ì¶œë ¥ëœ ë©”ì‹œì§€ë¥¼ ìƒˆë¡œìš´ ë©”ì‹œì§€ë¡œ ë®ì–´ì”ë‹ˆë‹¤.

    ì¤„ë°”ê¿ˆ ë¬¸ì ì—†ì´ ìºë¦¬ì§€ ë¦¬í„´('\\r')ì„ ì‚¬ìš©í•˜ì—¬ ì»¤ì„œë¥¼ ì¤„ì˜ ì‹œì‘ìœ¼ë¡œ
    ì´ë™ì‹œí‚¨ í›„ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.

    Args:
        message (str): ë®ì–´ì“¸ ìƒˆë¡œìš´ ë©”ì‹œì§€.

    Example:
        >>> update_last_line("íŒŒì¼ ì²˜ë¦¬ ì¤‘... 10%")
        >>> time.sleep(1)
        >>> update_last_line("íŒŒì¼ ì²˜ë¦¬ ì¤‘... 50%")
    """
    # ë¡œê¹…ì€ íŒŒì¼ì— ê¸°ë¡ë˜ë¯€ë¡œ ì´ í•¨ìˆ˜ì˜ ì‹œê°ì  íš¨ê³¼ì™€ëŠ” ë¬´ê´€í•©ë‹ˆë‹¤.
    # ë”°ë¼ì„œ ì´ í•¨ìˆ˜ì—ì„œëŠ” ë¡œê¹…ì„ ìƒëµí•˜ì—¬ ì¤‘ë³µì„ í”¼í•©ë‹ˆë‹¤.
    sys.stdout.write(f"\r{message}")
    sys.stdout.flush()
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ì‚¬ìš©ì ìƒí˜¸ì‘ìš©(User Interaction)ì„ ìœ„í•œ ë³µí•© MCP(Mission Control Primitives) ëª¨ìŒ.

ì´ ëª¨ë“ˆì€ AI ì—ì´ì „íŠ¸ê°€ í„°ë¯¸ë„ í™˜ê²½ì—ì„œ ì‚¬ìš©ìì™€ íš¨ê³¼ì ìœ¼ë¡œ ìƒí˜¸ì‘ìš©í•  ìˆ˜ ìˆë„ë¡
ë•ëŠ” ê³ ìˆ˜ì¤€ í•¨ìˆ˜ë“¤ì„ ì œê³µí•©ë‹ˆë‹¤. ì„ íƒì§€ ì œê³µ, ê²½ë¡œ ì…ë ¥, ì¤‘ìš” ì‘ì—… í™•ì¸ ë“±
ë‹¤ì–‘í•œ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.
"""

import logging
import os
import re
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional

import difflib
import questionary
from questionary import ValidationError, Validator

# ë¡œê¹… ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# --- Validator Classes for questionary ---

class PathValidator(Validator):
    """íŒŒì¼ ë˜ëŠ” ë””ë ‰í† ë¦¬ ê²½ë¡œì˜ ìœ íš¨ì„±ì„ ê²€ì¦í•˜ëŠ” Validator í´ë˜ìŠ¤."""
    def __init__(self, is_file: bool, must_exist: bool):
        self._is_file = is_file
        self._must_exist = must_exist
        self._type = "íŒŒì¼" if is_file else "ë””ë ‰í† ë¦¬"

    def validate(self, document):
        path_str = document.text.strip()
        if not path_str and not self._must_exist:
            return # ê²½ë¡œê°€ ë¹„ì–´ìˆì–´ë„ ë˜ê³ , ì¡´ì¬í•˜ì§€ ì•Šì•„ë„ ë˜ë©´ í†µê³¼
        
        path = Path(path_str).expanduser()
        
        if self._must_exist and not path.exists():
            raise ValidationError(
                message=f"ê²½ë¡œê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {path}",
                cursor_position=len(document.text))
        
        if self._is_file and path.exists() and not path.is_file():
            raise ValidationError(
                message=f"ê²½ë¡œëŠ” {self._type}ì´ì–´ì•¼ í•©ë‹ˆë‹¤.",
                cursor_position=len(document.text))
            
        if not self._is_file and path.exists() and not path.is_dir():
             raise ValidationError(
                message=f"ê²½ë¡œëŠ” {self._type}ì´ì–´ì•¼ í•©ë‹ˆë‹¤.",
                cursor_position=len(document.text))

# --- MCP Functions ---

def present_options_and_get_choice(prompt: str, options: List[str]) -> Optional[str]:
    """
    ì‚¬ìš©ìì—ê²Œ ë²ˆí˜¸ê°€ ë§¤ê²¨ì§„ ì„ íƒì§€ ëª©ë¡ì„ ë³´ì—¬ì£¼ê³ , í•˜ë‚˜ë¥¼ ì„ íƒí•˜ê²Œ í•©ë‹ˆë‹¤.

    Args:
        prompt (str): ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì¤„ ì§ˆë¬¸ ë©”ì‹œì§€.
        options (List[str]): ì‚¬ìš©ìì—ê²Œ ì œê³µí•  ì„ íƒì§€ ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸.

    Returns:
        Optional[str]: ì‚¬ìš©ìê°€ ì„ íƒí•œ í•­ëª©ì˜ ë¬¸ìì—´. ì‚¬ìš©ìê°€ ì„ íƒì„ ì·¨ì†Œ(Ctrl+C)í•˜ë©´ Noneì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    
    Raises:
        ValueError: ì„ íƒì§€(options) ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì–´ ìˆì„ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> selected_framework = present_options_and_get_choice(
        ...     "ì–´ë–¤ ì›¹ í”„ë ˆì„ì›Œí¬ë¥¼ ì‚¬ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
        ...     ["Django", "FastAPI", "Flask"]
        ... )
        >>> print(f"ì„ íƒ: {selected_framework}")
    """
    if not options:
        logger.error("ì„ íƒì§€ ëª©ë¡(options)ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.")
        raise ValueError("ì„ íƒì§€ ëª©ë¡ì€ ë¹„ì–´ ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    
    logger.info(f"ì‚¬ìš©ìì—ê²Œ ì„ íƒì§€ ì œì‹œ: {prompt}")
    try:
        choice = questionary.select(prompt, choices=options).ask()
        logger.info(f"ì‚¬ìš©ì ì„ íƒ: {choice}")
        return choice
    except KeyboardInterrupt:
        logger.warning("ì‚¬ìš©ìê°€ ì„ íƒì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.")
        return None

def present_checkbox_and_get_choices(prompt: str, options: List[str]) -> List[str]:
    """
    ì—¬ëŸ¬ ì„ íƒì§€ë¥¼ ì²´í¬ë°•ìŠ¤ í˜•íƒœë¡œ ë³´ì—¬ì£¼ê³ , ì‚¬ìš©ìê°€ ë‹¤ì¤‘ ì„ íƒí•œ í•­ëª©ë“¤ì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        prompt (str): ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì¤„ ì§ˆë¬¸ ë©”ì‹œì§€.
        options (List[str]): ì‚¬ìš©ìì—ê²Œ ì œê³µí•  ì„ íƒì§€ ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸.

    Returns:
        List[str]: ì‚¬ìš©ìê°€ ì„ íƒí•œ ëª¨ë“  í•­ëª©ì˜ ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸. ì•„ë¬´ê²ƒë„ ì„ íƒí•˜ì§€ ì•Šê±°ë‚˜ ì·¨ì†Œí•˜ë©´ ë¹ˆ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Example:
        >>> selected_libs = present_checkbox_and_get_choices(
        ...     "ì„¤ì¹˜í•  ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ëª¨ë‘ ì„ íƒí•˜ì„¸ìš”:",
        ...     ["pandas", "numpy", "matplotlib"]
        ... )
        >>> print(f"ì„ íƒëœ ë¼ì´ë¸ŒëŸ¬ë¦¬: {selected_libs}")
    """
    if not options:
        logger.warning("ì„ íƒì§€ ëª©ë¡(options)ì´ ë¹„ì–´ ìˆì–´ ë¹ˆ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.")
        return []

    logger.info(f"ì‚¬ìš©ìì—ê²Œ ì²´í¬ë°•ìŠ¤ ì„ íƒì§€ ì œì‹œ: {prompt}")
    try:
        choices = questionary.checkbox(prompt, choices=options).ask()
        # ì‚¬ìš©ìê°€ Ctrl+Cë¡œ ì·¨ì†Œí•˜ë©´ ask()ëŠ” Noneì„ ë°˜í™˜í•˜ë¯€ë¡œ ë¹ˆ ë¦¬ìŠ¤íŠ¸ë¡œ í†µì¼
        result = choices or []
        logger.info(f"ì‚¬ìš©ì ì„ íƒ: {result}")
        return result
    except KeyboardInterrupt:
        logger.warning("ì‚¬ìš©ìê°€ ì„ íƒì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.")
        return []

def ask_for_file_path(prompt: str, default_path: str = "", must_exist: bool = True) -> Optional[str]:
    """
    ì‚¬ìš©ìì—ê²Œ íŒŒì¼ ê²½ë¡œë¥¼ ì…ë ¥í•˜ë„ë¡ ìš”ì²­í•˜ê³ , ê²½ë¡œì˜ ìœ íš¨ì„±ì„ ê²€ì¦í•©ë‹ˆë‹¤.

    Args:
        prompt (str): ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì¤„ ì§ˆë¬¸ ë©”ì‹œì§€.
        default_path (str, optional): ê¸°ë³¸ìœ¼ë¡œ ë³´ì—¬ì¤„ ê²½ë¡œ. Defaults to "".
        must_exist (bool, optional): íŒŒì¼ì´ ë°˜ë“œì‹œ ì¡´ì¬í•´ì•¼ í•˜ëŠ”ì§€ ì—¬ë¶€. Defaults to True.

    Returns:
        Optional[str]: ì‚¬ìš©ìê°€ ì…ë ¥í•œ ìœ íš¨í•œ íŒŒì¼ì˜ ì „ì²´ ê²½ë¡œ ë¬¸ìì—´. ì·¨ì†Œ ì‹œ None.
    
    Example:
        >>> config_path = ask_for_file_path("ì„¤ì • íŒŒì¼ì˜ ê²½ë¡œë¥¼ ì…ë ¥í•˜ì„¸ìš”:", default_path="./config.json")
    """
    logger.info(f"ì‚¬ìš©ìì—ê²Œ íŒŒì¼ ê²½ë¡œ ì…ë ¥ ìš”ì²­: {prompt}")
    try:
        path = questionary.path(
            prompt,
            default=default_path,
            validate=PathValidator(is_file=True, must_exist=must_exist)
        ).ask()
        
        if path:
            full_path = str(Path(path).expanduser().resolve())
            logger.info(f"ì‚¬ìš©ì ì…ë ¥ ê²½ë¡œ: {full_path}")
            return full_path
        else:
            logger.warning("ì‚¬ìš©ìê°€ ê²½ë¡œ ì…ë ¥ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.")
            return None
            
    except KeyboardInterrupt:
        logger.warning("ì‚¬ìš©ìê°€ ê²½ë¡œ ì…ë ¥ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.")
        return None

def ask_for_directory_path(prompt: str, default_path: str = "", must_exist: bool = True) -> Optional[str]:
    """
    ì‚¬ìš©ìì—ê²Œ ë””ë ‰í† ë¦¬ ê²½ë¡œë¥¼ ì…ë ¥í•˜ë„ë¡ ìš”ì²­í•˜ê³ , ê²½ë¡œì˜ ìœ íš¨ì„±ì„ ê²€ì¦í•©ë‹ˆë‹¤.

    Args:
        prompt (str): ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì¤„ ì§ˆë¬¸ ë©”ì‹œì§€.
        default_path (str, optional): ê¸°ë³¸ìœ¼ë¡œ ë³´ì—¬ì¤„ ê²½ë¡œ. Defaults to "".
        must_exist (bool, optional): ë””ë ‰í† ë¦¬ê°€ ë°˜ë“œì‹œ ì¡´ì¬í•´ì•¼ í•˜ëŠ”ì§€ ì—¬ë¶€. Defaults to True.

    Returns:
        Optional[str]: ì‚¬ìš©ìê°€ ì…ë ¥í•œ ìœ íš¨í•œ ë””ë ‰í† ë¦¬ì˜ ì „ì²´ ê²½ë¡œ ë¬¸ìì—´. ì·¨ì†Œ ì‹œ None.
        
    Example:
        >>> project_dir = ask_for_directory_path("í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ ê²½ë¡œë¥¼ ì…ë ¥í•˜ì„¸ìš”:", default_path="~/projects/")
    """
    logger.info(f"ì‚¬ìš©ìì—ê²Œ ë””ë ‰í† ë¦¬ ê²½ë¡œ ì…ë ¥ ìš”ì²­: {prompt}")
    try:
        path = questionary.path(
            prompt,
            default=default_path,
            validate=PathValidator(is_file=False, must_exist=must_exist),
            only_directories=True
        ).ask()

        if path:
            full_path = str(Path(path).expanduser().resolve())
            logger.info(f"ì‚¬ìš©ì ì…ë ¥ ê²½ë¡œ: {full_path}")
            return full_path
        else:
            logger.warning("ì‚¬ìš©ìê°€ ê²½ë¡œ ì…ë ¥ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.")
            return None

    except KeyboardInterrupt:
        logger.warning("ì‚¬ìš©ìê°€ ê²½ë¡œ ì…ë ¥ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.")
        return None

def confirm_critical_action(action_description: str, details_to_show: Optional[str] = None) -> bool:
    """
    ì¤‘ìš”í•œ ì‘ì—…ì„ ì‹¤í–‰í•˜ê¸° ì „, ìƒì„¸ ë‚´ìš©ì„ ë³´ì—¬ì£¼ê³  ì‚¬ìš©ìì—ê²Œ ì¬í™•ì¸ë°›ìŠµë‹ˆë‹¤.

    Args:
        action_description (str): ìˆ˜í–‰í•  ì‘ì—…ì— ëŒ€í•œ ê°„ê²°í•œ ì„¤ëª…. (ì˜ˆ: "ì´ 5ê°œì˜ íŒŒì¼ì„ ì˜êµ¬ì ìœ¼ë¡œ ì‚­ì œí•©ë‹ˆë‹¤.")
        details_to_show (Optional[str], optional): ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì¤„ ì¶”ê°€ì ì¸ ìƒì„¸ ì •ë³´. (ì˜ˆ: ì‚­ì œë  íŒŒì¼ ëª©ë¡). Defaults to None.

    Returns:
        bool: ì‚¬ìš©ìê°€ 'Yes'ë¥¼ ì„ íƒí•˜ë©´ True, 'No'ë¥¼ ì„ íƒí•˜ê±°ë‚˜ ì·¨ì†Œí•˜ë©´ False.

    Example:
        >>> files_to_delete = ["a.txt", "b.txt"]
        >>> if confirm_critical_action(
        ...     f"ì´ {len(files_to_delete)}ê°œì˜ íŒŒì¼ì„ ì‚­ì œí•©ë‹ˆë‹¤.",
        ...     details_to_show="\\n".join(files_to_delete)
        ... ):
        ...     print("ì‚­ì œ ì‘ì—… ì‹¤í–‰")
        ... else:
        ...     print("ì‚­ì œ ì‘ì—… ì·¨ì†Œ")
    """
    logger.warning(f"ì¤‘ìš” ì‘ì—… í™•ì¸ ìš”ì²­: {action_description}")
    
    if details_to_show:
        print("\n--- ì‘ì—… ìƒì„¸ ë‚´ìš© ---")
        print(details_to_show)
        print("---------------------\n")
    
    try:
        # questionaryëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ì•ˆì „ì„ ìœ„í•´ 'No'ë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ í•˜ë„ë¡ 'default=False'ë¥¼ ê¶Œì¥
        confirmed = questionary.confirm(f"{action_description} ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?", default=False).ask()
        result = confirmed or False
        if result:
            logger.info("ì‚¬ìš©ìê°€ ì¤‘ìš” ì‘ì—…ì„ ìŠ¹ì¸í–ˆìŠµë‹ˆë‹¤.")
        else:
            logger.warning("ì‚¬ìš©ìê°€ ì¤‘ìš” ì‘ì—…ì„ ê±°ë¶€í–ˆìŠµë‹ˆë‹¤.")
        return result
    except KeyboardInterrupt:
        logger.warning("ì‚¬ìš©ìê°€ ì¤‘ìš” ì‘ì—… í™•ì¸ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.")
        return False

def get_form_input(form_fields: Dict[str, str]) -> Dict[str, Any]:
    """
    ì •ì˜ëœ ì—¬ëŸ¬ í•„ë“œì— ëŒ€í•´ ìˆœì°¨ì ìœ¼ë¡œ ì§ˆë¬¸í•˜ì—¬, í¼(Form)ì²˜ëŸ¼ ì‚¬ìš©ì ì…ë ¥ì„ ë°›ìŠµë‹ˆë‹¤.

    Args:
        form_fields (Dict[str, str]): ë”•ì…”ë„ˆë¦¬. keyëŠ” ê²°ê³¼ ë”•ì…”ë„ˆë¦¬ì˜ í‚¤ê°€ ë˜ê³ , valueëŠ” ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì¤„ ì§ˆë¬¸ì´ ë©ë‹ˆë‹¤.

    Returns:
        Dict[str, Any]: ì‚¬ìš©ìê°€ ê° í•„ë“œì— ëŒ€í•´ ì…ë ¥í•œ ê°’ì„ ë‹´ì€ ë”•ì…”ë„ˆë¦¬.

    Example:
        >>> user_info = get_form_input({
        ...     "name": "ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:",
        ...     "email": "ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”:",
        ...     "age": "ë‚˜ì´ë¥¼ ì…ë ¥í•˜ì„¸ìš”:"
        ... })
        >>> print(user_info)
    """
    logger.info("í¼ ì…ë ¥ ì‹œì‘.")
    results = {}
    try:
        for key, question in form_fields.items():
            answer = questionary.text(question).ask()
            if answer is None: # ì‚¬ìš©ìê°€ Ctrl+C ë¡œ ì¤‘ë‹¨í•œ ê²½ìš°
                raise KeyboardInterrupt
            results[key] = answer
            logger.debug(f"í¼ í•„ë“œ '{key}' ì…ë ¥ ì™„ë£Œ: {answer}")
        
        logger.info("í¼ ì…ë ¥ ì™„ë£Œ.")
        return results
    except KeyboardInterrupt:
        logger.warning("ì‚¬ìš©ìê°€ í¼ ì…ë ¥ì„ ì¤‘ë‹¨í–ˆìŠµë‹ˆë‹¤.")
        return {} # ì¤‘ë‹¨ ì‹œ ë¹ˆ ë”•ì…”ë„ˆë¦¬ ë°˜í™˜

def ask_for_validated_input(question: str, validation_rule: Dict[str, str]) -> Optional[str]:
    """
    ì •ê·œì‹ì„ ê¸°ë°˜ìœ¼ë¡œ ì…ë ¥ê°’ì˜ ìœ íš¨ì„±ì„ ê²€ì¦í•˜ë©° ì‚¬ìš©ì ì…ë ¥ì„ ë°›ìŠµë‹ˆë‹¤.

    Args:
        question (str): ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì¤„ ì§ˆë¬¸.
        validation_rule (Dict[str, str]): ê²€ì¦ ê·œì¹™.
            - "regex" (str): ì…ë ¥ê°’ì„ ê²€ì¦í•  ì •ê·œì‹ íŒ¨í„´.
            - "message" (str): ê²€ì¦ ì‹¤íŒ¨ ì‹œ ë³´ì—¬ì¤„ ì˜¤ë¥˜ ë©”ì‹œì§€.

    Returns:
        Optional[str]: ìœ íš¨ì„± ê²€ì¦ì„ í†µê³¼í•œ ì‚¬ìš©ì ì…ë ¥ ë¬¸ìì—´. ì·¨ì†Œ ì‹œ None.

    Raises:
        KeyError: validation_rule ë”•ì…”ë„ˆë¦¬ì— 'regex'ë‚˜ 'message' í‚¤ê°€ ì—†ì„ ê²½ìš°.

    Example:
        >>> email_rule = {"regex": r"^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$", "message": "ìœ íš¨í•œ ì´ë©”ì¼ ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”."}
        >>> user_email = ask_for_validated_input("ì´ë©”ì¼ ì£¼ì†Œë¥¼ ì…ë ¥í•˜ì„¸ìš”:", email_rule)
    """
    logger.info(f"ìœ íš¨ì„± ê²€ì¦ì´ í•„ìš”í•œ ì…ë ¥ ìš”ì²­: {question}")
    
    class RegexValidator(Validator):
        def validate(self, document):
            if not re.match(validation_rule["regex"], document.text):
                raise ValidationError(
                    message=validation_rule["message"],
                    cursor_position=len(document.text))

    try:
        answer = questionary.text(question, validate=RegexValidator).ask()
        if answer:
            logger.info("ìœ íš¨ì„± ê²€ì¦ í†µê³¼.")
        else:
            logger.warning("ì‚¬ìš©ìê°€ ì…ë ¥ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.")
        return answer
    except KeyboardInterrupt:
        logger.warning("ì‚¬ìš©ìê°€ ì…ë ¥ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.")
        return None

def select_file_from_directory(prompt: str, directory_path: str) -> Optional[str]:
    """
    íŠ¹ì • ë””ë ‰í† ë¦¬ì˜ íŒŒì¼ ëª©ë¡ì„ ë³´ì—¬ì£¼ê³ , ì‚¬ìš©ìê°€ ê·¸ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•˜ê²Œ í•©ë‹ˆë‹¤.

    Args:
        prompt (str): ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì¤„ ì§ˆë¬¸ ë©”ì‹œì§€.
        directory_path (str): íŒŒì¼ì„ ê²€ìƒ‰í•  ë””ë ‰í† ë¦¬ ê²½ë¡œ.

    Returns:
        Optional[str]: ì‚¬ìš©ìê°€ ì„ íƒí•œ íŒŒì¼ì˜ ì „ì²´ ê²½ë¡œ. ë””ë ‰í† ë¦¬ê°€ ì—†ê±°ë‚˜ íŒŒì¼ì´ ì—†ê±°ë‚˜, ì„ íƒ ì·¨ì†Œ ì‹œ None.
        
    Raises:
        NotADirectoryError: ì£¼ì–´ì§„ directory_pathê°€ ë””ë ‰í† ë¦¬ê°€ ì•„ë‹ ê²½ìš° ë°œìƒ.
        FileNotFoundError: ì£¼ì–´ì§„ directory_pathê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš° ë°œìƒ.

    Example:
        >>> selected_file = select_file_from_directory("ì„¤ì • íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”:", "./configs")
    """
    logger.info(f"'{directory_path}' ë””ë ‰í† ë¦¬ì—ì„œ íŒŒì¼ ì„ íƒ ìš”ì²­.")
    
    path = Path(directory_path).expanduser()
    if not path.exists():
        raise FileNotFoundError(f"ë””ë ‰í† ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {directory_path}")
    if not path.is_dir():
        raise NotADirectoryError(f"ì£¼ì–´ì§„ ê²½ë¡œëŠ” ë””ë ‰í† ë¦¬ê°€ ì•„ë‹™ë‹ˆë‹¤: {directory_path}")
        
    try:
        files = sorted([f.name for f in path.iterdir() if f.is_file()])
        
        if not files:
            logger.warning(f"'{directory_path}' ë””ë ‰í† ë¦¬ì— íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
            return None
        
        # íŒŒì¼ ëª©ë¡ê³¼ í•¨ê»˜ 'ì·¨ì†Œ' ì˜µì…˜ ì¶”ê°€
        files_with_cancel = files + ["[ ì·¨ì†Œ ]"]
        
        selected_file = present_options_and_get_choice(prompt, files_with_cancel)
        
        if selected_file and selected_file != "[ ì·¨ì†Œ ]":
            full_path = str(path / selected_file)
            logger.info(f"ì‚¬ìš©ìê°€ '{full_path}' íŒŒì¼ì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤.")
            return full_path
        else:
            logger.info("ì‚¬ìš©ìê°€ íŒŒì¼ ì„ íƒì„ ì·¨ì†Œí–ˆê±°ë‚˜ ì„ íƒí•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
            return None
            
    except Exception as e:
        logger.error(f"íŒŒì¼ ì„ íƒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return None

def show_diff(text1: str, text2: str, fromfile: str = 'ì›ë³¸', tofile: str = 'ìˆ˜ì •ë³¸'):
    """
    ë‘ í…ìŠ¤íŠ¸ë¥¼ ë¹„êµí•˜ì—¬ ì°¨ì´ì (diff)ì„ í„°ë¯¸ë„ì— ì‹œê°ì ìœ¼ë¡œ ê°•ì¡°í•˜ì—¬ ë³´ì—¬ì¤ë‹ˆë‹¤.

    Args:
        text1 (str): ë¹„êµí•  ì²« ë²ˆì§¸ í…ìŠ¤íŠ¸ (ì›ë³¸).
        text2 (str): ë¹„êµí•  ë‘ ë²ˆì§¸ í…ìŠ¤íŠ¸ (ìˆ˜ì •ë³¸).
        fromfile (str, optional): ì›ë³¸ íŒŒì¼ëª…ìœ¼ë¡œ í‘œì‹œë  ì´ë¦„. Defaults to 'ì›ë³¸'.
        tofile (str, optional): ìˆ˜ì •ë³¸ íŒŒì¼ëª…ìœ¼ë¡œ í‘œì‹œë  ì´ë¦„. Defaults to 'ìˆ˜ì •ë³¸'.

    Returns:
        None: ê²°ê³¼ë¥¼ ì§ì ‘ print() í•¨ìˆ˜ë¡œ ì¶œë ¥í•©ë‹ˆë‹¤.

    Example:
        >>> original_code = "def hello():\\n    print('Hello World')"
        >>> modified_code = "def hello_user(name):\\n    print(f'Hello {name}')"
        >>> show_diff(original_code, modified_code)
    """
    logger.info("ë‘ í…ìŠ¤íŠ¸ì˜ ì°¨ì´ì (diff)ì„ ì¶œë ¥í•©ë‹ˆë‹¤.")
    diff = difflib.unified_diff(
        text1.splitlines(keepends=True),
        text2.splitlines(keepends=True),
        fromfile=fromfile,
        tofile=tofile,
    )
    print("--- í…ìŠ¤íŠ¸ ë¹„êµ ê²°ê³¼ ---")
    for line in diff:
        print(line, end="")
    print("------------------------")


def prompt_with_autocomplete(prompt: str, choices: List[str]) -> Optional[str]:
    """
    ì‚¬ìš©ì ì…ë ¥ì„ ì‹œì‘í•˜ë©´, ì œê³µëœ ì„ íƒì§€ ëª©ë¡ì„ ê¸°ë°˜ìœ¼ë¡œ ìë™ ì™„ì„± ì œì•ˆì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

    Args:
        prompt (str): ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì¤„ ì§ˆë¬¸.
        choices (List[str]): ìë™ ì™„ì„± ì œì•ˆì— ì‚¬ìš©í•  ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸.

    Returns:
        Optional[str]: ì‚¬ìš©ìê°€ ì„ íƒí•˜ê±°ë‚˜ ì…ë ¥í•œ ìµœì¢… ë¬¸ìì—´. ì·¨ì†Œ ì‹œ None.

    Example:
        >>> city_list = ["Seoul", "New York", "London", "Paris", "Tokyo"]
        >>> selected_city = prompt_with_autocomplete("ë„ì‹œë¥¼ ì„ íƒí•˜ì„¸ìš”:", city_list)
    """
    if not choices:
        logger.warning("ìë™ ì™„ì„± ëª©ë¡(choices)ì´ ë¹„ì–´ ìˆì–´ ì¼ë°˜ í…ìŠ¤íŠ¸ ì…ë ¥ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.")
        return questionary.text(prompt).ask()

    logger.info(f"ìë™ ì™„ì„± í”„ë¡¬í”„íŠ¸ ì œì‹œ: {prompt}")
    try:
        result = questionary.autocomplete(
            prompt,
            choices=choices
        ).ask()
        logger.info(f"ì‚¬ìš©ì ì„ íƒ/ì…ë ¥: {result}")
        return result
    except KeyboardInterrupt:
        logger.warning("ì‚¬ìš©ìê°€ ì…ë ¥ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.")
        return None
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
web_network_atomic.py

ì›¹ ë° ë„¤íŠ¸ì›Œí¬ì™€ ê´€ë ¨ëœ ê°€ì¥ ê¸°ë³¸ì ì¸ ë‹¨ì¼ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ì›ì(Atomic) MCP í•¨ìˆ˜ ëª¨ìŒì…ë‹ˆë‹¤.
ê° í•¨ìˆ˜ëŠ” ë³´ì•ˆ, ì•ˆì •ì„±, ë¡œê¹…ì„ ê³ ë ¤í•˜ì—¬ í”„ë¡œë•ì…˜ ë ˆë²¨ ì‚¬ìš©ì„ ëª©í‘œë¡œ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.
"""

import logging
import os
import re
import smtplib
import socket
import ipaddress
import ssl
import subprocess
from email.mime.text import MIMEText
from ftplib import FTP_TLS
from typing import Dict, Any, List, Optional, Union
from urllib.parse import urlparse
from json import JSONDecodeError

import feedparser
import requests
from bs4 import BeautifulSoup
from requests.exceptions import RequestException

# --- ë¡œê±° ì„¤ì • ---
# í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œëŠ” JSON í¬ë§·í„° ë“±ì„ ì‚¬ìš©í•˜ì—¬ êµ¬ì¡°í™”ëœ ë¡œê¹…ì„ í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# --- ë³´ì•ˆ í—¬í¼ í•¨ìˆ˜ ---
def _validate_and_sanitize_url(url: str) -> str:
    """
    URLì˜ ìœ íš¨ì„±ì„ ê²€ì‚¬í•˜ê³  SSRF(Server-Side Request Forgery) ê³µê²©ì„ ë°©ì§€í•©ë‹ˆë‹¤.

    Args:
        url (str): ê²€ì¦í•  URL ë¬¸ìì—´.

    Returns:
        str: ìœ íš¨ì„± ê²€ì‚¬ë¥¼ í†µê³¼í•œ URL.

    Raises:
        ValueError: URL í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆê±°ë‚˜, í—ˆìš©ë˜ì§€ ì•Šì€ í”„ë¡œí† ì½œì„ ì‚¬ìš©í•˜ê±°ë‚˜,
                    ë‚´ë¶€ ë„¤íŠ¸ì›Œí¬ IP ëŒ€ì—­ìœ¼ë¡œ í™•ì¸ë  ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
    """
    if not isinstance(url, str) or not url:
        raise ValueError("URLì€ ë¹„ì–´ ìˆì§€ ì•Šì€ ë¬¸ìì—´ì´ì–´ì•¼ í•©ë‹ˆë‹¤.")

    # ì •ê·œì‹ì„ ì‚¬ìš©í•˜ì—¬ URL êµ¬ì¡°ì˜ ê¸°ë³¸ì ì¸ ìœ íš¨ì„± ê²€ì‚¬
    # RFC 3986ì„ ì—„ê²©í•˜ê²Œ ë”°ë¥´ê¸°ë³´ë‹¤ëŠ” ì¼ë°˜ì ì¸ ì›¹ URL íŒ¨í„´ì— ì¤‘ì 
    if not re.match(r'^https?://[^\s/$.?#].[^\s]*$', url, re.IGNORECASE):
        raise ValueError(f"URL í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤: {url}")

    try:
        parsed_url = urlparse(url)
        hostname = parsed_url.hostname
        if not hostname:
            raise ValueError("URLì—ì„œ í˜¸ìŠ¤íŠ¸ ì´ë¦„ì„ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

        # IP ì£¼ì†Œë¡œ ì§ì ‘ ì ‘ê·¼í•˜ëŠ” ê²½ìš°, ë˜ëŠ” DNS í™•ì¸ ê²°ê³¼ê°€ ë‚´ë¶€ IPì¸ ê²½ìš°ë¥¼ ë°©ì§€
        ip_address_str = socket.gethostbyname(hostname)
        ip_obj = ipaddress.ip_address(ip_address_str) # IP ì£¼ì†Œ ê°ì²´ ìƒì„±
        if ip_obj.is_private:
            raise ValueError(f"SSRF ê³µê²© ë°©ì§€: ë‚´ë¶€ ë„¤íŠ¸ì›Œí¬ IPë¡œì˜ ìš”ì²­ì€ í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤ ({hostname} -> {ip_address_str}).")

    except socket.gaierror:
        # DNS ì¡°íšŒê°€ ì‹¤íŒ¨í•´ë„ ì¼ë‹¨ URL í˜•ì‹ì€ ìœ íš¨í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ í†µê³¼ì‹œí‚´
        # ì‹¤ì œ ìš”ì²­ ì‹œì ì—ì„œ requests ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì˜¤ë¥˜ë¥¼ ë°œìƒì‹œí‚¬ ê²ƒì„
        logger.warning(f"DNS ì¡°íšŒë¥¼ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: {hostname}")
    except Exception as e:
        # ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ ì‹œ ì•ˆì „í•˜ê²Œ ì°¨ë‹¨
        raise ValueError(f"URL ìœ íš¨ì„± ê²€ì‚¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

    return url

def fetch_url_content(url: str, timeout: int = 10) -> str:
    """
    ì£¼ì–´ì§„ URLì˜ HTML ì†ŒìŠ¤ ì½”ë“œë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.

    Args:
        url (str): HTML ì†ŒìŠ¤ ì½”ë“œë¥¼ ê°€ì ¸ì˜¬ ëŒ€ìƒ ì›¹ í˜ì´ì§€ì˜ ì „ì²´ URL.
        timeout (int, optional): HTTP ìš”ì²­ ì‹œ ëŒ€ê¸°í•  ìµœëŒ€ ì‹œê°„(ì´ˆ). ê¸°ë³¸ê°’ì€ 10ì…ë‹ˆë‹¤.

    Returns:
        str: ì„±ê³µ ì‹œ, ê°€ì ¸ì˜¨ HTML ì†ŒìŠ¤ ì½”ë“œ. ì‹¤íŒ¨ ì‹œ ë¹ˆ ë¬¸ìì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        ValueError: URL í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆê±°ë‚˜ ë‚´ë¶€ IPë¥¼ ê°€ë¦¬í‚¬ ê²½ìš° ë°œìƒí•©ë‹ˆë‹¤.
        requests.exceptions.RequestException: ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì˜¤ë¥˜ë‚˜ HTTP ì˜¤ë¥˜ ë°œìƒ ì‹œ ë°œìƒí•©ë‹ˆë‹¤.

    Example:
        >>> html_content = fetch_url_content("https://www.google.com")
        >>> print("google" in html_content.lower())
        True
    """
    logger.info(f"URL ì½˜í…ì¸  ê°€ì ¸ì˜¤ê¸° ì‹œë„: {url}")
    try:
        safe_url = _validate_and_sanitize_url(url)
        headers = {'User-Agent': 'MyAgent/1.0'}
        response = requests.get(safe_url, timeout=timeout, headers=headers, allow_redirects=True)
        response.raise_for_status()  # 200ë²ˆëŒ€ ìƒíƒœ ì½”ë“œê°€ ì•„ë‹ˆë©´ HTTPError ë°œìƒ
        logger.info(f"URL ì½˜í…ì¸  ê°€ì ¸ì˜¤ê¸° ì„±ê³µ: {url}")
        # ì„œë²„ê°€ ëª…ì‹œí•œ ì¸ì½”ë”©ì„ ì‚¬ìš©í•˜ë˜, ì—†ìœ¼ë©´ UTF-8ì„ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©
        response.encoding = response.apparent_encoding or 'utf-8'
        return response.text
    except ValueError as e:
        logger.error(f"URL ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨: {url}, ì˜¤ë¥˜: {e}")
        raise
    except RequestException as e:
        logger.error(f"URL ì½˜í…ì¸ ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {url}, ì˜¤ë¥˜: {e}")
        raise
    return ""

def download_file_from_url(url: str, save_path: str, timeout: int = 60) -> str:
    """
    URLì—ì„œ íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•˜ì—¬ ì§€ì •ëœ ê²½ë¡œì— ì €ì¥í•©ë‹ˆë‹¤.

    Args:
        url (str): ë‹¤ìš´ë¡œë“œí•  íŒŒì¼ì˜ URL.
        save_path (str): íŒŒì¼ì„ ì €ì¥í•  ë¡œì»¬ ê²½ë¡œ. ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•´ì•¼ í•©ë‹ˆë‹¤.
        timeout (int, optional): ìš”ì²­ ëŒ€ê¸° ì‹œê°„(ì´ˆ). ê¸°ë³¸ê°’ì€ 60ì…ë‹ˆë‹¤.

    Returns:
        str: ì„±ê³µ ì‹œ ì €ì¥ëœ íŒŒì¼ì˜ ì „ì²´ ê²½ë¡œ. ì‹¤íŒ¨ ì‹œ ë¹ˆ ë¬¸ìì—´.

    Raises:
        ValueError: URLì´ ìœ íš¨í•˜ì§€ ì•Šê±°ë‚˜ save_pathê°€ ì•ˆì „í•˜ì§€ ì•Šì€ ê²½ìš°.
        requests.exceptions.RequestException: ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë°œìƒ ì‹œ.
        IOError: íŒŒì¼ ì“°ê¸° ì˜¤ë¥˜ ë°œìƒ ì‹œ.

    Example:
        >>> path = download_file_from_url("https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png", "./google.png")
        >>> print(f"íŒŒì¼ ì €ì¥ ìœ„ì¹˜: {path}")
    """
    logger.info(f"íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹œë„: {url} -> {save_path}")
    try:
        safe_url = _validate_and_sanitize_url(url)
        
        # ë³´ì•ˆ: ê²½ë¡œ ì¡°ì‘(Path Traversal) ê³µê²© ë°©ì§€
        save_dir = os.path.dirname(os.path.abspath(save_path))
        if not os.path.isdir(save_dir) or not os.path.abspath(save_path).startswith(save_dir):
            raise ValueError(f"ì €ì¥ ê²½ë¡œê°€ ì•ˆì „í•˜ì§€ ì•Šê±°ë‚˜ ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {save_path}")

        headers = {'User-Agent': 'MyAgent/1.0'}
        with requests.get(safe_url, stream=True, timeout=timeout, headers=headers) as r:
            r.raise_for_status()
            with open(save_path, 'wb') as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)
        logger.info(f"íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì„±ê³µ: {save_path}")
        return os.path.abspath(save_path)
    except ValueError as e:
        logger.error(f"ì…ë ¥ê°’ ì˜¤ë¥˜: {e}")
        raise
    except RequestException as e:
        logger.error(f"íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: {url}, ì˜¤ë¥˜: {e}")
        raise
    except IOError as e:
        logger.error(f"íŒŒì¼ ì €ì¥ ì¤‘ I/O ì˜¤ë¥˜: {save_path}, ì˜¤ë¥˜: {e}")
        raise
    return ""

def api_get_request(url: str, headers: Optional[Dict] = None, params: Optional[Dict] = None, timeout: int = 10) -> Dict:
    """
    GET ë°©ì‹ìœ¼ë¡œ APIë¥¼ í˜¸ì¶œí•˜ê³  JSON ì‘ë‹µì„ ë”•ì…”ë„ˆë¦¬ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        url (str): í˜¸ì¶œí•  APIì˜ ì—”ë“œí¬ì¸íŠ¸ URL.
        headers (dict, optional): ìš”ì²­ì— í¬í•¨í•  HTTP í—¤ë”.
        params (dict, optional): URLì— ì¶”ê°€í•  ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°.
        timeout (int, optional): ìš”ì²­ ëŒ€ê¸° ì‹œê°„(ì´ˆ). ê¸°ë³¸ê°’ì€ 10ì…ë‹ˆë‹¤.

    Returns:
        dict: APIì˜ JSON ì‘ë‹µì„ íŒŒì‹±í•œ ë”•ì…”ë„ˆë¦¬.

    Raises:
        ValueError: URLì´ ìœ íš¨í•˜ì§€ ì•Šì„ ê²½ìš°.
        requests.exceptions.RequestException: ë„¤íŠ¸ì›Œí¬ ë˜ëŠ” HTTP ì˜¤ë¥˜ ë°œìƒ ì‹œ.

    Example:
        >>> data = api_get_request("https://api.github.com/users/google")
        >>> print(data.get('name'))
        Google
    """
    logger.info(f"API GET ìš”ì²­: {url}")
    try:
        safe_url = _validate_and_sanitize_url(url)
        response = requests.get(safe_url, headers=headers, params=params, timeout=timeout)
        response.raise_for_status()
        return response.json()
    except JSONDecodeError as e:
        # requestsì˜ JSONDecodeErrorë¥¼ ì¡ì•„ì„œ ValueErrorë¡œ ë³€í™˜í•˜ì—¬ ë‹¤ì‹œ ë°œìƒì‹œí‚´
        raise ValueError("JSONìœ¼ë¡œ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤") from e
    except ValueError as e:
        logger.error(f"URL ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨: {e}")
        raise
    except RequestException as e:
        logger.error(f"API GET ìš”ì²­ ì‹¤íŒ¨: {url}, ì˜¤ë¥˜: {e}")
        raise
    except ValueError: # requests.JSONDecodeErrorëŠ” ValueErrorë¥¼ ìƒì†
        logger.error(f"API ì‘ë‹µì´ ìœ íš¨í•œ JSONì´ ì•„ë‹™ë‹ˆë‹¤: {url}")
        raise ValueError("API ì‘ë‹µì„ JSONìœ¼ë¡œ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

def api_post_request(url: str, headers: Optional[Dict] = None, data: Optional[Dict] = None, timeout: int = 10) -> Dict:
    """
    POST ë°©ì‹ìœ¼ë¡œ APIë¥¼ í˜¸ì¶œí•˜ê³  JSON ì‘ë‹µì„ ë”•ì…”ë„ˆë¦¬ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

    Args:
        url (str): í˜¸ì¶œí•  APIì˜ ì—”ë“œí¬ì¸íŠ¸ URL.
        headers (dict, optional): ìš”ì²­ì— í¬í•¨í•  HTTP í—¤ë”.
        data (dict, optional): ìš”ì²­ ë³¸ë¬¸(body)ì— í¬í•¨í•  JSON ë°ì´í„°.
        timeout (int, optional): ìš”ì²­ ëŒ€ê¸° ì‹œê°„(ì´ˆ). ê¸°ë³¸ê°’ì€ 10ì…ë‹ˆë‹¤.

    Returns:
        dict: APIì˜ JSON ì‘ë‹µì„ íŒŒì‹±í•œ ë”•ì…”ë„ˆë¦¬.

    Raises:
        ValueError: URLì´ ìœ íš¨í•˜ì§€ ì•Šì„ ê²½ìš°.
        requests.exceptions.RequestException: ë„¤íŠ¸ì›Œí¬ ë˜ëŠ” HTTP ì˜¤ë¥˜ ë°œìƒ ì‹œ.

    Example:
        >>> payload = {'title': 'foo', 'body': 'bar', 'userId': 1}
        >>> result = api_post_request("https://jsonplaceholder.typicode.com/posts", data=payload)
        >>> print(result.get('id'))
        101
    """
    logger.info(f"API POST ìš”ì²­: {url}")
    try:
        safe_url = _validate_and_sanitize_url(url)
        response = requests.post(safe_url, headers=headers, json=data, timeout=timeout)
        response.raise_for_status()
        return response.json()
    except ValueError as e:
        logger.error(f"URL ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨: {e}")
        raise
    except RequestException as e:
        logger.error(f"API POST ìš”ì²­ ì‹¤íŒ¨: {url}, ì˜¤ë¥˜: {e}")
        raise
    except ValueError:
        logger.error(f"API ì‘ë‹µì´ ìœ íš¨í•œ JSONì´ ì•„ë‹™ë‹ˆë‹¤: {url}")
        raise ValueError("API ì‘ë‹µì„ JSONìœ¼ë¡œ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

# api_put_requestì™€ api_delete_requestëŠ” api_post_requestì™€ êµ¬ì¡°ê°€ ë§¤ìš° ìœ ì‚¬í•©ë‹ˆë‹¤.
def api_put_request(url: str, headers: Optional[Dict] = None, data: Optional[Dict] = None, timeout: int = 10) -> Dict:
    """PUT ë°©ì‹ìœ¼ë¡œ ë°ì´í„°ë¥¼ ì „ì†¡í•˜ê³  ì„œë²„ì˜ ë¦¬ì†ŒìŠ¤ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤."""
    logger.info(f"API PUT ìš”ì²­: {url}")
    try:
        safe_url = _validate_and_sanitize_url(url)
        response = requests.put(safe_url, headers=headers, json=data, timeout=timeout)
        response.raise_for_status()
        return response.json()
    except ValueError as e:
        logger.error(f"URL ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨: {e}")
        raise
    except RequestException as e:
        logger.error(f"API PUT ìš”ì²­ ì‹¤íŒ¨: {url}, ì˜¤ë¥˜: {e}")
        raise
    except ValueError:
        logger.error(f"API ì‘ë‹µì´ ìœ íš¨í•œ JSONì´ ì•„ë‹™ë‹ˆë‹¤: {url}")
        raise ValueError("API ì‘ë‹µì„ JSONìœ¼ë¡œ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")


def api_delete_request(url: str, headers: Optional[Dict] = None, timeout: int = 10) -> Dict:
    """DELETE ë°©ì‹ìœ¼ë¡œ ì„œë²„ì˜ íŠ¹ì • ë¦¬ì†ŒìŠ¤ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤."""
    logger.info(f"API DELETE ìš”ì²­: {url}")
    try:
        safe_url = _validate_and_sanitize_url(url)
        response = requests.delete(safe_url, headers=headers, timeout=timeout)
        response.raise_for_status()
        # DELETE ìš”ì²­ì€ ì‘ë‹µ ë³¸ë¬¸ì´ ì—†ëŠ” ê²½ìš°ê°€ ë§ìœ¼ë¯€ë¡œ ì˜ˆì™¸ ì²˜ë¦¬
        return response.json() if response.text else {}
    except ValueError as e:
        logger.error(f"URL ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨: {e}")
        raise
    except RequestException as e:
        logger.error(f"API DELETE ìš”ì²­ ì‹¤íŒ¨: {url}, ì˜¤ë¥˜: {e}")
        raise
    except ValueError:
        logger.error(f"API ì‘ë‹µì´ ìœ íš¨í•œ JSONì´ ì•„ë‹™ë‹ˆë‹¤: {url}")
        raise ValueError("API ì‘ë‹µì„ JSONìœ¼ë¡œ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

def get_http_status(url: str, timeout: int = 5) -> int:
    """
    ì£¼ì–´ì§„ URLì— ì ‘ì†í•˜ì—¬ HTTP ìƒíƒœ ì½”ë“œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. (HEAD ìš”ì²­ ì‚¬ìš©)

    Args:
        url (str): ìƒíƒœ ì½”ë“œë¥¼ í™•ì¸í•  URL.
        timeout (int, optional): ìš”ì²­ ëŒ€ê¸° ì‹œê°„(ì´ˆ). ê¸°ë³¸ê°’ì€ 5ì…ë‹ˆë‹¤.

    Returns:
        int: HTTP ìƒíƒœ ì½”ë“œ (ì˜ˆ: 200, 404). ì˜¤ë¥˜ ë°œìƒ ì‹œ -1ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        ValueError: URLì´ ìœ íš¨í•˜ì§€ ì•Šì„ ê²½ìš°.
        requests.exceptions.RequestException: ì‹¬ê°í•œ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë°œìƒ ì‹œ.

    Example:
        >>> status = get_http_status("https://www.google.com")
        >>> print(status)
        200
    """
    logger.info(f"HTTP ìƒíƒœ ì½”ë“œ í™•ì¸: {url}")
    try:
        safe_url = _validate_and_sanitize_url(url)
        headers = {'User-Agent': 'MyAgent/1.0'}
        # HEAD ìš”ì²­ì€ ë³¸ë¬¸ì„ ê°€ì ¸ì˜¤ì§€ ì•Šì•„ ë” íš¨ìœ¨ì ì…ë‹ˆë‹¤.
        response = requests.head(safe_url, timeout=timeout, headers=headers, allow_redirects=True)
        return response.status_code
    except ValueError as e:
        logger.error(f"URL ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨: {e}")
        raise
    except RequestException as e:
        logger.error(f"HTTP ìƒíƒœ í™•ì¸ ì¤‘ ì˜¤ë¥˜: {url}, ì˜¤ë¥˜: {e}")
        # ì¼ë¶€ HTTP ì˜¤ë¥˜(4xx, 5xx)ëŠ” ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¤ì§€ ì•Šê³  ìƒíƒœ ì½”ë“œë¥¼ ë°˜í™˜
        if e.response is not None:
            return e.response.status_code
        raise
    return -1

def ping_host(hostname: str) -> bool:
    """
    íŠ¹ì • í˜¸ìŠ¤íŠ¸ë‚˜ IP ì£¼ì†Œê°€ ì‘ë‹µí•˜ëŠ”ì§€ (ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì´ ê°€ëŠ¥í•œì§€) í™•ì¸í•©ë‹ˆë‹¤.

    [!!] ë³´ì•ˆ ê²½ê³ : ì´ í•¨ìˆ˜ëŠ” OSì˜ 'ping' ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.
    ì…ë ¥ê°’(hostname)ì€ ëª…ë ¹ì–´ ì£¼ì…(Command Injection) ê³µê²©ì„ ë°©ì§€í•˜ê¸° ìœ„í•´
    ì—„ê²©í•˜ê²Œ ê²€ì¦ë©ë‹ˆë‹¤.

    Args:
        hostname (str): í•‘ í…ŒìŠ¤íŠ¸ë¥¼ ìˆ˜í–‰í•  í˜¸ìŠ¤íŠ¸ ì´ë¦„ ë˜ëŠ” IP ì£¼ì†Œ.

    Returns:
        bool: í˜¸ìŠ¤íŠ¸ê°€ ì‘ë‹µí•˜ë©´ True, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ False.

    Raises:
        ValueError: hostname í˜•ì‹ì´ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°.

    Example:
        >>> is_alive = ping_host("8.8.8.8")
        >>> print(f"Google DNS is alive: {is_alive}")
    """
    logger.info(f"Ping ì‹œë„: {hostname}")
    # ë³´ì•ˆ: ëª…ë ¹ì–´ ì£¼ì… ë°©ì§€ë¥¼ ìœ„í•œ í˜¸ìŠ¤íŠ¸ ì´ë¦„/IP ì •ê·œì‹ ê²€ì¦
    # IPv4, IPv6, ê·¸ë¦¬ê³  ì¼ë°˜ì ì¸ ë„ë©”ì¸ ì´ë¦„ì„ í—ˆìš©
    if not re.match(r'^[a-zA-Z0-9\.\-:]+$', hostname):
        raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ í˜¸ìŠ¤íŠ¸ ì´ë¦„ í˜•ì‹ì…ë‹ˆë‹¤: {hostname}")

    # OSì— ë”°ë¼ ping ëª…ë ¹ì–´ íŒŒë¼ë¯¸í„°ê°€ ë‹¤ë¦„
    param = '-n' if os.name == 'nt' else '-c'
    command = ['ping', param, '1', hostname]

    try:
        # shell=False ë¡œ ì„¤ì •í•˜ì—¬ ì…¸ì„ í†µí•˜ì§€ ì•Šê³  ì§ì ‘ í”„ë¡œì„¸ìŠ¤ë¥¼ ì‹¤í–‰ (ë³´ì•ˆ ê°•í™”)
        result = subprocess.run(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            check=False, # returncodeê°€ 0ì´ ì•„ë‹ˆì–´ë„ ì˜ˆì™¸ ë°œìƒ ì•ˆí•¨
            timeout=5 # 5ì´ˆ íƒ€ì„ì•„ì›ƒ
        )
        if result.returncode == 0:
            logger.info(f"Ping ì„±ê³µ: {hostname}")
            return True
        else:
            logger.warning(f"Ping ì‹¤íŒ¨: {hostname}, Return Code: {result.returncode}")
            return False
    except FileNotFoundError:
        logger.error("'ping' ëª…ë ¹ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. OSì— ì„¤ì¹˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.")
        return False
    except subprocess.TimeoutExpired:
        logger.warning(f"Ping ì‹œê°„ ì´ˆê³¼: {hostname}")
        return False
    except Exception as e:
        logger.error(f"Ping ì‹¤í–‰ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {e}")
        return False

def resolve_dns(hostname: str) -> str:
    """
    ë„ë©”ì¸ ì´ë¦„ì— í•´ë‹¹í•˜ëŠ” IP ì£¼ì†Œë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.

    Args:
        hostname (str): IP ì£¼ì†Œë¥¼ ì¡°íšŒí•  ë„ë©”ì¸ ì´ë¦„.

    Returns:
        str: ì¡°íšŒëœ IP ì£¼ì†Œ. ì‹¤íŒ¨ ì‹œ ë¹ˆ ë¬¸ìì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        ValueError: hostname í˜•ì‹ì´ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°.

    Example:
        >>> ip = resolve_dns("google.com")
        >>> print(f"Google.com IP: {ip}")
    """
    logger.info(f"DNS ì¡°íšŒ ì‹œë„: {hostname}")
    if not isinstance(hostname, str) or not hostname:
        raise ValueError("í˜¸ìŠ¤íŠ¸ ì´ë¦„ì€ ë¹„ì–´ìˆì§€ ì•Šì€ ë¬¸ìì—´ì´ì–´ì•¼ í•©ë‹ˆë‹¤.")
    
    try:
        ip_address = socket.gethostbyname(hostname)
        logger.info(f"DNS ì¡°íšŒ ì„±ê³µ: {hostname} -> {ip_address}")
        return ip_address
    except socket.gaierror as e:
        logger.warning(f"DNS ì¡°íšŒë¥¼ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: {hostname}, ì˜¤ë¥˜: {e}")
    return ""

def parse_rss_feed(rss_url: str, timeout: int = 15) -> List[Dict[str, str]]:
    """
    RSS í”¼ë“œ URLì—ì„œ ê²Œì‹œë¬¼ ëª©ë¡(ì œëª©, ë§í¬, ì„¤ëª… ë“±)ì„ íŒŒì‹±í•˜ì—¬ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
    'feedparser' ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

    Args:
        rss_url (str): íŒŒì‹±í•  RSS í”¼ë“œì˜ URL.
        timeout (int): URL ìš”ì²­ ëŒ€ê¸° ì‹œê°„(ì´ˆ). ê¸°ë³¸ê°’ 15ì´ˆ.

    Returns:
        list: ê° ê²Œì‹œë¬¼ ì •ë³´(title, link, summary)ê°€ ë‹´ê¸´ ë”•ì…”ë„ˆë¦¬ì˜ ë¦¬ìŠ¤íŠ¸.
              ì‹¤íŒ¨ ì‹œ ë¹ˆ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

    Raises:
        ValueError: URLì´ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°.

    Example:
        >>> bbc_news = parse_rss_feed("http://feeds.bbci.co.uk/news/rss.xml")
        >>> if bbc_news: print(bbc_news[0]['title'])
    """
    logger.info(f"RSS í”¼ë“œ íŒŒì‹± ì‹œë„: {rss_url}")
    try:
        # RSS í”¼ë“œëŠ” httpë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ê°€ ë§ìœ¼ë¯€ë¡œ _validate_and_sanitize_url ì¬ì •ì˜
        if not re.match(r'^https?://[^\s/$.?#].[^\s]*$', rss_url, re.IGNORECASE):
             raise ValueError(f"URL í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤: {rss_url}")
        
        # feedparserëŠ” ë‚´ë¶€ì ìœ¼ë¡œ http ìš”ì²­ì„ í•˜ë¯€ë¡œ íƒ€ì„ì•„ì›ƒ ì„¤ì •ì´ ì§ì ‘ì ìœ¼ë¡œ ë¶ˆê°€.
        # socketì˜ default timeoutì„ ì„¤ì •í•˜ì—¬ ê°„ì ‘ì ìœ¼ë¡œ ì œì–´.
        socket.setdefaulttimeout(timeout)
        feed = feedparser.parse(rss_url)
        socket.setdefaulttimeout(None) # ì›ë˜ëŒ€ë¡œ ë³µêµ¬

        if feed.bozo:
            logger.warning(f"RSS í”¼ë“œ íŒŒì‹± ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤: {rss_url}, ì´ìœ : {feed.bozo_exception}")

        entries = []
        for entry in feed.entries:
            entries.append({
                'title': entry.get('title', ''),
                'link': entry.get('link', ''),
                'summary': entry.get('summary', '')
            })
        logger.info(f"RSS í”¼ë“œì—ì„œ {len(entries)}ê°œì˜ í•­ëª©ì„ íŒŒì‹±í–ˆìŠµë‹ˆë‹¤.")
        return entries

    except ValueError as e:
        logger.error(f"URL ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨: {e}")
        raise
    except Exception as e:
        logger.error(f"RSS í”¼ë“œ íŒŒì‹± ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {rss_url}, ì˜¤ë¥˜: {e}")
        return []

def send_email_smtp(to_email: str, subject: str, body: str) -> bool:
    """
    SMTP ì„œë²„ë¥¼ í†µí•´ ê°„ë‹¨í•œ í…ìŠ¤íŠ¸ ì´ë©”ì¼ì„ ë°œì†¡í•©ë‹ˆë‹¤.
    ë¯¼ê° ì •ë³´(ì„œë²„, í¬íŠ¸, ê³„ì •)ëŠ” í™˜ê²½ ë³€ìˆ˜ì—ì„œ ë¡œë“œí•©ë‹ˆë‹¤.

    í™˜ê²½ ë³€ìˆ˜ ì„¤ì • ì˜ˆì‹œ:
    export SMTP_SERVER="smtp.gmail.com"
    export SMTP_PORT="587"
    export SMTP_SENDER_EMAIL="my_email@gmail.com"
    export SMTP_SENDER_PASSWORD="my_app_password"

    Args:
        to_email (str): ìˆ˜ì‹ ì ì´ë©”ì¼ ì£¼ì†Œ.
        subject (str): ì´ë©”ì¼ ì œëª©.
        body (str): ì´ë©”ì¼ ë³¸ë¬¸.

    Returns:
        bool: ì´ë©”ì¼ ë°œì†¡ ì„±ê³µ ì‹œ True, ì‹¤íŒ¨ ì‹œ False.

    Raises:
        ValueError: í™˜ê²½ ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì´ë©”ì¼ í˜•ì‹ì´ ì˜ëª»ëœ ê²½ìš°.

    Example:
        >>> # í™˜ê²½ ë³€ìˆ˜ ì„¤ì • í›„
        >>> # success = send_email_smtp("recipient@example.com", "Test", "This is a test email.")
        >>> # print(f"Email sent: {success}")
    """
    logger.info(f"ì´ë©”ì¼ ë°œì†¡ ì‹œë„: -> {to_email}")
    # --- ë¯¼ê° ì •ë³´ ë¡œë“œ (í™˜ê²½ ë³€ìˆ˜ ì‚¬ìš©) ---
    smtp_server = os.getenv("SMTP_SERVER")
    smtp_port_str = os.getenv("SMTP_PORT")
    sender_email = os.getenv("SMTP_SENDER_EMAIL")
    password = os.getenv("SMTP_SENDER_PASSWORD")

    if not all([smtp_server, smtp_port_str, sender_email, password]):
        raise ValueError("SMTP ê´€ë ¨ í™˜ê²½ ë³€ìˆ˜ê°€ ëª¨ë‘ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
    
    if not re.match(r'[^@]+@[^@]+\.[^@]+', to_email):
        raise ValueError("ìˆ˜ì‹ ì ì´ë©”ì¼ ì£¼ì†Œ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.")

    try:
        smtp_port = int(smtp_port_str)
        msg = MIMEText(body)
        msg['Subject'] = subject
        msg['From'] = sender_email
        msg['To'] = to_email

        context = ssl.create_default_context()
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls(context=context)
            server.login(sender_email, password)
            server.sendmail(sender_email, to_email, msg.as_string())
        logger.info(f"ì´ë©”ì¼ ë°œì†¡ ì„±ê³µ: -> {to_email}")
        return True
    except (ValueError, smtplib.SMTPException) as e:
        logger.error(f"ì´ë©”ì¼ ë°œì†¡ ì‹¤íŒ¨: {e}")
        return False

def get_http_headers(url: str, timeout: int = 5) -> Dict[str, str]:
    """
    URLì— ìš”ì²­í–ˆì„ ë•Œ ì„œë²„ê°€ ë°˜í™˜í•˜ëŠ” ì „ì²´ HTTP í—¤ë” ì •ë³´ë¥¼ ë”•ì…”ë„ˆë¦¬ë¡œ ê°€ì ¸ì˜µë‹ˆë‹¤.

    Args:
        url (str): í—¤ë”ë¥¼ í™•ì¸í•  URL.
        timeout (int): ìš”ì²­ ëŒ€ê¸° ì‹œê°„(ì´ˆ).

    Returns:
        dict: ì„œë²„ê°€ ë°˜í™˜í•œ HTTP í—¤ë” ë”•ì…”ë„ˆë¦¬.

    Raises:
        ValueError: URLì´ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°.
        requests.exceptions.RequestException: ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë°œìƒ ì‹œ.

    Example:
        >>> headers = get_http_headers("https://www.google.com")
        >>> print(headers.get('Content-Type'))
        text/html; charset=UTF-8
    """
    logger.info(f"HTTP í—¤ë” í™•ì¸: {url}")
    try:
        safe_url = _validate_and_sanitize_url(url)
        headers = {'User-Agent': 'MyAgent/1.0'}
        response = requests.head(safe_url, timeout=timeout, headers=headers, allow_redirects=True)
        response.raise_for_status()
        return dict(response.headers)
    except ValueError as e:
        logger.error(f"URL ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨: {e}")
        raise
    except RequestException as e:
        logger.error(f"HTTP í—¤ë” í™•ì¸ ì¤‘ ì˜¤ë¥˜: {url}, ì˜¤ë¥˜: {e}")
        raise

def get_ssl_certificate_info(hostname: str, port: int = 443) -> Dict:
    """
    íŠ¹ì • í˜¸ìŠ¤íŠ¸ì˜ SSL ì¸ì¦ì„œ ì •ë³´ë¥¼ (ìœ íš¨ê¸°ê°„, ë°œê¸‰ì ë“±) ì¡°íšŒí•©ë‹ˆë‹¤.

    Args:
        hostname (str): ì¸ì¦ì„œë¥¼ í™•ì¸í•  í˜¸ìŠ¤íŠ¸ ì´ë¦„.
        port (int): í¬íŠ¸ ë²ˆí˜¸, ê¸°ë³¸ê°’ 443.

    Returns:
        dict: ì¸ì¦ì„œì˜ ì£¼ìš” ì •ë³´(ë°œê¸‰ ëŒ€ìƒ, ë°œê¸‰ì, ë§Œë£Œì¼ ë“±)ê°€ ë‹´ê¸´ ë”•ì…”ë„ˆë¦¬.

    Raises:
        ValueError: hostname í˜•ì‹ì´ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°.
        ssl.SSLError: SSL ê´€ë ¨ ì˜¤ë¥˜ ë°œìƒ ì‹œ.
        socket.error: ì†Œì¼“ ì—°ê²° ì˜¤ë¥˜ ë°œìƒ ì‹œ.

    Example:
        >>> cert_info = get_ssl_certificate_info("www.google.com")
        >>> print(f"Issuer: {cert_info.get('issuer')}")
    """
    logger.info(f"SSL ì¸ì¦ì„œ ì •ë³´ ì¡°íšŒ: {hostname}:{port}")
    # ë³´ì•ˆ: ëª…ë ¹ì–´ ì£¼ì… ë°©ì§€ë¥¼ ìœ„í•œ í˜¸ìŠ¤íŠ¸ ì´ë¦„ ê²€ì¦
    if not re.match(r'^[a-zA-Z0-9\.\-]+$', hostname):
        raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ í˜¸ìŠ¤íŠ¸ ì´ë¦„ í˜•ì‹ì…ë‹ˆë‹¤: {hostname}")

    context = ssl.create_default_context()
    try:
        with socket.create_connection((hostname, port), timeout=5) as sock:
            with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                cert = ssock.getpeercert()
                
                issuer = dict(x[0] for x in cert.get('issuer', []))
                subject = dict(x[0] for x in cert.get('subject', []))
                
                info = {
                    'issuer': issuer.get('commonName', ''),
                    'subject': subject.get('commonName', ''),
                    'version': cert.get('version'),
                    'serial_number': cert.get('serialNumber'),
                    'not_before': cert.get('notBefore'),
                    'not_after': cert.get('notAfter'),
                }
                logger.info(f"SSL ì¸ì¦ì„œ ì •ë³´ ì¡°íšŒ ì„±ê³µ: {hostname}")
                return info
    except (ssl.SSLError, socket.error, ValueError) as e:
        logger.error(f"SSL ì¸ì¦ì„œ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {hostname}, ì˜¤ë¥˜: {e}")
        raise

def fetch_dynamic_content(url: str, timeout: int = 30) -> str:
    """
    [ì£¼ì˜] JavaScript ë Œë”ë§ì´ í•„ìš”í•œ ë™ì  ì›¹ í˜ì´ì§€ì˜ ìµœì¢… HTML ì†ŒìŠ¤ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
    ì´ í•¨ìˆ˜ëŠ” Seleniumê³¼ ì›¹ ë“œë¼ì´ë²„(ì˜ˆ: ChromeDriver)ê°€ ì„¤ì¹˜ëœ í™˜ê²½ì—ì„œë§Œ ë™ì‘í•©ë‹ˆë‹¤.
    ìƒëŒ€ì ìœ¼ë¡œ ë¬´ê²ê³  ëŠë¦° ì‘ì—…ì…ë‹ˆë‹¤.

    Args:
        url (str): ì½˜í…ì¸ ë¥¼ ê°€ì ¸ì˜¬ ë™ì  ì›¹ í˜ì´ì§€ URL.
        timeout (int): í˜ì´ì§€ ë¡œë“œë¥¼ ê¸°ë‹¤ë¦´ ìµœëŒ€ ì‹œê°„(ì´ˆ).

    Returns:
        str: JavaScript ë Œë”ë§ í›„ì˜ ìµœì¢… HTML ì†ŒìŠ¤ ì½”ë“œ.

    Raises:
        ValueError: URLì´ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°.
        ImportError: 'selenium' ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì€ ê²½ìš°.
        Exception: ì›¹ ë“œë¼ì´ë²„ ì‹¤í–‰ ë˜ëŠ” í˜ì´ì§€ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ ì‹œ.

    Example:
        >>> # html = fetch_dynamic_content("https://twitter.com/elonmusk")
        >>> # print("Elon Musk" in html)
    """
    try:
        from selenium import webdriver
        from selenium.webdriver.chrome.options import Options
        from selenium.webdriver.chrome.service import Service
        from webdriver_manager.chrome import ChromeDriverManager
    except ImportError:
        logger.error("ì´ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ 'selenium'ê³¼ 'webdriver-manager'ê°€ í•„ìš”í•©ë‹ˆë‹¤. (pip install selenium webdriver-manager)")
        raise ImportError("'selenium' ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

    logger.info(f"ë™ì  ì½˜í…ì¸  ê°€ì ¸ì˜¤ê¸° ì‹œë„: {url}")
    safe_url = _validate_and_sanitize_url(url)

    chrome_options = Options()
    chrome_options.add_argument("--headless")  # UI ì—†ì´ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‹¤í–‰
    chrome_options.add_argument("--no-sandbox")
    chrome_options.add_argument("--disable-dev-shm-usage")
    chrome_options.add_argument("user-agent=MyDynamicAgent/1.0")

    driver = None
    try:
        # ì›¹ ë“œë¼ì´ë²„ ìë™ ì„¤ì¹˜ ë° ì„¤ì •
        service = Service(ChromeDriverManager().install())
        driver = webdriver.Chrome(service=service, options=chrome_options)
        driver.set_page_load_timeout(timeout)
        driver.get(safe_url)
        content = driver.page_source
        logger.info(f"ë™ì  ì½˜í…ì¸  ê°€ì ¸ì˜¤ê¸° ì„±ê³µ: {url}")
        return content
    except Exception as e:
        logger.error(f"ë™ì  ì½˜í…ì¸  ê°€ì ¸ì˜¤ê¸° ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        raise
    finally:
        if driver:
            driver.quit()

def _ftp_operation(upload: bool, host: str, user: str, pwd: str, local_path: str, remote_path: str) -> bool:
    """
    [ê²½ê³ ] FTPëŠ” ì•”í˜¸ë¥¼ í‰ë¬¸ìœ¼ë¡œ ì „ì†¡í•˜ëŠ” ì˜¤ë˜ëœ í”„ë¡œí† ì½œì…ë‹ˆë‹¤.
    ê°€ëŠ¥í•˜ë©´ SFTP ì‚¬ìš©ì„ ê¶Œì¥í•©ë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” ë³´ì•ˆ ì—°ê²°(FTP over TLS)ì„ ì‹œë„í•©ë‹ˆë‹¤.

    ë‚´ë¶€ì ìœ¼ë¡œ FTP ì—…ë¡œë“œ/ë‹¤ìš´ë¡œë“œë¥¼ ì²˜ë¦¬í•˜ëŠ” í—¬í¼ í•¨ìˆ˜.
    ë¯¼ê° ì •ë³´(user, pwd)ëŠ” í™˜ê²½ ë³€ìˆ˜ì—ì„œ ê°€ì ¸ì˜¤ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.
    """
    logger.info(f"FTP {'ì—…ë¡œë“œ' if upload else 'ë‹¤ìš´ë¡œë“œ'} ì‹œë„: {host}")
    if not re.match(r'^[a-zA-Z0-9\.\-]+$', host):
        raise ValueError("ìœ íš¨í•˜ì§€ ì•Šì€ í˜¸ìŠ¤íŠ¸ ì´ë¦„ í˜•ì‹ì…ë‹ˆë‹¤.")

    try:
        # ë³´ì•ˆ ê°•í™”ë¥¼ ìœ„í•´ ëª…ì‹œì  FTP over TLS ì‚¬ìš©
        with FTP_TLS(host, timeout=10) as ftps:
            ftps.login(user, pwd)
            ftps.prot_p()  # ë°ì´í„° ì±„ë„ ì•”í˜¸í™”
            
            if upload:
                with open(local_path, 'rb') as f:
                    ftps.storbinary(f'STOR {remote_path}', f)
                logger.info(f"FTP ì—…ë¡œë“œ ì„±ê³µ: {local_path} -> ftp://{host}/{remote_path}")
            else: # download
                with open(local_path, 'wb') as f:
                    ftps.retrbinary(f'RETR {remote_path}', f.write)
                logger.info(f"FTP ë‹¤ìš´ë¡œë“œ ì„±ê³µ: ftp://{host}/{remote_path} -> {local_path}")
        return True
    except Exception as e:
        logger.error(f"FTP ì‘ì—… ì‹¤íŒ¨: {e}")
        return False

def ftp_upload_file(host: str, user: str, pwd: str, local_path: str, remote_path: str) -> bool:
    """
    FTP í”„ë¡œí† ì½œ(TLS)ì„ ì‚¬ìš©í•´ ë¡œì»¬ íŒŒì¼ì„ ì›ê²© ì„œë²„ì— ì—…ë¡œë“œí•©ë‹ˆë‹¤.
    ìê²© ì¦ëª…ì€ ì½”ë“œì— í•˜ë“œì½”ë”©í•˜ì§€ ë§ê³  í™˜ê²½ ë³€ìˆ˜ ë“±ì„ í†µí•´ ì•ˆì „í•˜ê²Œ ì „ë‹¬í•˜ì„¸ìš”.

    Args:
        host (str): FTP ì„œë²„ í˜¸ìŠ¤íŠ¸ ì´ë¦„.
        user (str): FTP ì‚¬ìš©ì ì´ë¦„.
        pwd (str): FTP ë¹„ë°€ë²ˆí˜¸.
        local_path (str): ì—…ë¡œë“œí•  ë¡œì»¬ íŒŒì¼ ê²½ë¡œ.
        remote_path (str): ì„œë²„ì— ì €ì¥ë  íŒŒì¼ ê²½ë¡œ.

    Returns:
        bool: ì„±ê³µ ì‹œ True, ì‹¤íŒ¨ ì‹œ False.

    Raises:
        ValueError: í˜¸ìŠ¤íŠ¸ ì´ë¦„ì´ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°.
    """
    return _ftp_operation(True, host, user, pwd, local_path, remote_path)


def ftp_download_file(host: str, user: str, pwd: str, remote_path: str, local_path: str) -> bool:
    """
    FTP í”„ë¡œí† ì½œ(TLS)ì„ ì‚¬ìš©í•´ ì›ê²© ì„œë²„ì˜ íŒŒì¼ì„ ë¡œì»¬ë¡œ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.
    ìê²© ì¦ëª…ì€ ì½”ë“œì— í•˜ë“œì½”ë”©í•˜ì§€ ë§ê³  í™˜ê²½ ë³€ìˆ˜ ë“±ì„ í†µí•´ ì•ˆì „í•˜ê²Œ ì „ë‹¬í•˜ì„¸ìš”.

    Args:
        host (str): FTP ì„œë²„ í˜¸ìŠ¤íŠ¸ ì´ë¦„.
        user (str): FTP ì‚¬ìš©ì ì´ë¦„.
        pwd (str): FTP ë¹„ë°€ë²ˆí˜¸.
        remote_path (str): ë‹¤ìš´ë¡œë“œí•  ì›ê²© íŒŒì¼ ê²½ë¡œ.
        local_path (str): ë¡œì»¬ì— ì €ì¥ë  íŒŒì¼ ê²½ë¡œ.

    Returns:
        bool: ì„±ê³µ ì‹œ True, ì‹¤íŒ¨ ì‹œ False.
    
    Raises:
        ValueError: í˜¸ìŠ¤íŠ¸ ì´ë¦„ì´ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°.
    """
    return _ftp_operation(False, host, user, pwd, local_path, remote_path)
